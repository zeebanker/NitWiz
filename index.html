<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NitWiz - Poker Player Intelligence</title>

    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#101830">

    <!-- iOS PWA -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="NitWiz">
    <link rel="apple-touch-icon" href="icon-192.png">

    <!-- Prevent phone number detection -->
    <meta name="format-detection" content="telephone=no">

    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800&family=Inter:wght@400;600;700;800&family=Space+Grotesk:wght@700&family=Allura&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>

    <!-- Firebase Init — Auth System -->
    <script>
        // ⚠️ REPLACE with your own config from Firebase Console
const firebaseConfig = {
  apiKey: "AIzaSyDuRndLhamDfvt4b4acZ3l_bmsgzVJAotE",
  authDomain: "nitwiz-94482.firebaseapp.com",
  projectId: "nitwiz-94482",
  storageBucket: "nitwiz-94482.firebasestorage.app",
  messagingSenderId: "212021722345",
  appId: "1:212021722345:web:deaa3bb42a60e1cd8d4478"
};

        // ⚠️ SET YOUR ADMIN EMAIL HERE
        const ADMIN_EMAIL = "zeebanker@gmail.com";

        firebase.initializeApp(firebaseConfig);
        const fbDb = firebase.firestore();
        const fbAuth = firebase.auth();

        let _fbSaveTimer = null;
        let _appReady = false; // guard: don't save to Firebase until cloud data is loaded
        let _userInitiated = false; // guard: don't auto-save until user actually changes something
        let _currentUser = null;

        function getDocRef() {
            if (!_currentUser) return null;
            return fbDb.collection('vaults').doc(_currentUser.uid);
        }

        function syncShowError() {
            var btn = document.getElementById('firebase-sync-btn');
            if (btn) btn.style.display = 'block';
        }

        function syncClear() {
            var btn = document.getElementById('firebase-sync-btn');
            if (btn) btn.style.display = 'none';
            // Stamp last synced time
            var el = document.getElementById('last-sync-label');
            if (el) {
                var now = new Date();
                var mm = String(now.getMonth() + 1).padStart(2, '0');
                var dd = String(now.getDate()).padStart(2, '0');
                var yy = String(now.getFullYear()).slice(-2);
                var hh = String(now.getHours()).padStart(2, '0');
                var min = String(now.getMinutes()).padStart(2, '0');
                var ss = String(now.getSeconds()).padStart(2, '0');
                el.textContent = 'Last sync\'d ' + mm + '/' + dd + '/' + yy + ' ' + hh + ':' + min + ':' + ss;
                el.style.color = 'rgba(255,255,255,0.22)';
            }
        }

        // Periodic heartbeat — push to Firebase every 3 minutes
        setInterval(function() {
            if (_currentUser && _appReady && _userInitiated) _doFirebaseSave();
        }, 3 * 60 * 1000);

        // Push when tab loses focus or is hidden
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden' && _currentUser && _appReady && _userInitiated) {
                _doFirebaseSave();
            }
        });

        // Push before page unload
        window.addEventListener('beforeunload', function() {
            if (_currentUser && _appReady && _userInitiated) _doFirebaseSave();
        });

        window.addEventListener('offline', syncShowError);
        window.addEventListener('online', function() {
            if (_currentUser) saveToFirebase();
        });

        function saveToFirebase() {
            if (!_appReady) return; // don't overwrite cloud before we've loaded from it
            if (!_userInitiated) return; // don't save until user actually changes something
            if (_fbSaveTimer) clearTimeout(_fbSaveTimer);
            _fbSaveTimer = setTimeout(_doFirebaseSave, 1000);
        }

        function _doFirebaseSave() {
            const ref = getDocRef();
            if (!ref) return;
            if (!navigator.onLine) { syncShowError(); return; }
            ref.set({
                email: _currentUser.email,
                uid: _currentUser.uid,
                pokerDatabase: localStorage.getItem('pokerDatabase') || '{}',
                handHistory: localStorage.getItem('nitwiz_handHistory') || '{}',
                sessionData: localStorage.getItem('nitwiz_sessionData') || '{}',
                lastPlayer: localStorage.getItem('nitwiz_lastPlayer') || '',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                syncClear();
            }).catch(err => {
                console.warn('Firebase save failed:', err);
                syncShowError();
            });
        }

        function loadFromFirebase() {
            const ref = getDocRef();
            if (!ref) return Promise.resolve(false);
            return ref.get().then(doc => {
                if (doc.exists) {
                    const data = doc.data();
                    if (data.pokerDatabase) localStorage.setItem('pokerDatabase', data.pokerDatabase);
                    if (data.handHistory) localStorage.setItem('nitwiz_handHistory', data.handHistory);
                    if (data.sessionData) localStorage.setItem('nitwiz_sessionData', data.sessionData);
                    if (data.lastPlayer) localStorage.setItem('nitwiz_lastPlayer', data.lastPlayer);
                    return true;
                }
                return false;
            }).catch(err => {
                console.warn('loadFromFirebase failed:', err);
                syncShowError();
                return false;
            });
        }

        function handleSyncButton() {
            if (_currentUser) _doFirebaseSave();
        }

        function manualSyncWithFeedback() {
            handleSyncButton();
            var btn = document.getElementById('manual-sync-btn');
            var icon = document.getElementById('manual-sync-icon');
            var label = document.getElementById('manual-sync-label');
            if (!btn) return;
            // Flash to green checkmark
            btn.style.borderColor = 'rgba(74,222,128,0.5)';
            btn.style.color = 'rgba(74,222,128,0.9)';
            if (icon) icon.innerHTML = '<polyline points="20 6 9 17 4 12"></polyline>';
            if (label) label.textContent = 'Synced!';
            // Restore after 1.5s
            setTimeout(function() {
                btn.style.borderColor = 'rgba(141,196,240,0.3)';
                btn.style.color = 'rgba(141,196,240,0.6)';
                if (icon) icon.innerHTML = '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>';
                if (label) label.textContent = 'Sync Now';
            }, 1500);
        }

        // === AUTH FUNCTIONS ===
        function isAdmin() {
            return _currentUser && _currentUser.email && 
                _currentUser.email.toLowerCase() === ADMIN_EMAIL.toLowerCase();
        }

        function toggleLoginPassword(btn) {
            var input = document.getElementById('login-password');
            var isHidden = input.type === 'password';
            input.type = isHidden ? 'text' : 'password';
            // Swap icon: open eye vs eye-off
            btn.querySelector('svg').innerHTML = isHidden
                ? '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94"></path><path d="M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19"></path><line x1="1" y1="1" x2="23" y2="23"></line>'
                : '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>';
            btn.style.color = isHidden ? '#ff8c38' : 'rgba(255,255,255,0.4)';
        }

        async function handleForgotPassword() {
            var email = document.getElementById('login-email').value.trim();
            var errorEl = document.getElementById('login-error');
            if (!email) {
                errorEl.textContent = 'Enter your email above first.';
                errorEl.style.color = '#ff8c38';
                return;
            }
            try {
                await fbAuth.sendPasswordResetEmail(email);
                errorEl.textContent = 'Reset email sent — check your inbox.';
                errorEl.style.color = '#4ade80';
            } catch(err) {
                if (err.code === 'auth/user-not-found') {
                    errorEl.textContent = 'No account found for that email.';
                } else {
                    errorEl.textContent = 'Error: ' + err.message;
                }
                errorEl.style.color = '#ff6b6b';
            }
        }

        async function handleLogin() {
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;
            const errorEl = document.getElementById('login-error');
            const btn = document.getElementById('login-btn');
            errorEl.textContent = '';

            if (!email || !password) {
                errorEl.textContent = 'Please enter email and password.';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Signing in...';

            try {
                await fbAuth.signInWithEmailAndPassword(email, password);
                // onAuthStateChanged handles the rest
            } catch (err) {
                btn.disabled = false;
                btn.textContent = 'Sign In';
                if (err.code === 'auth/user-not-found' || err.code === 'auth/wrong-password' || err.code === 'auth/invalid-credential') {
                    errorEl.textContent = 'Invalid email or password.';
                } else if (err.code === 'auth/too-many-requests') {
                    errorEl.textContent = 'Too many attempts. Try again later.';
                } else {
                    errorEl.textContent = 'Login failed: ' + err.message;
                }
            }
        }

        async function handleRequestAccess() {
            const email = document.getElementById('request-email').value.trim();
            const name = document.getElementById('request-name').value.trim();
            const errorEl = document.getElementById('request-error');
            const successEl = document.getElementById('request-success');
            const btn = document.getElementById('request-btn');
            errorEl.textContent = '';
            successEl.textContent = '';

            if (!email) {
                errorEl.textContent = 'Please enter your email.';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Submitting...';

            try {
                // Check if already requested
                const existing = await fbDb.collection('accessRequests').doc(email.toLowerCase()).get();
                if (existing.exists) {
                    const status = existing.data().status;
                    if (status === 'pending') {
                        errorEl.textContent = 'You already have a pending request. Please wait for approval.';
                    } else if (status === 'approved') {
                        errorEl.textContent = 'You\'ve been approved! Go back to sign in.';
                    } else if (status === 'denied') {
                        errorEl.textContent = 'Your request was denied. Contact the admin.';
                    }
                    btn.disabled = false;
                    btn.textContent = 'Request Access';
                    return;
                }

                await fbDb.collection('accessRequests').doc(email.toLowerCase()).set({
                    email: email.toLowerCase(),
                    name: name || 'Not provided',
                    status: 'pending',
                    requestedAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                successEl.textContent = 'Request submitted! You\'ll receive access once approved.';
                document.getElementById('request-email').value = '';
                document.getElementById('request-name').value = '';
            } catch (err) {
                errorEl.textContent = 'Failed to submit: ' + err.message;
            }

            btn.disabled = false;
            btn.textContent = 'Request Access';
        }

        async function handleSignUp() {
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-password').value;
            const confirmPw = document.getElementById('signup-confirm').value;
            const errorEl = document.getElementById('signup-error');
            const btn = document.getElementById('signup-btn');
            errorEl.textContent = '';

            if (!email || !password) {
                errorEl.textContent = 'Please fill in all fields.';
                return;
            }
            if (password.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters.';
                return;
            }
            if (password !== confirmPw) {
                errorEl.textContent = 'Passwords do not match.';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Creating account...';

            try {
                // Admin can sign up without approval — skip Firestore check entirely
                if (email.toLowerCase() !== ADMIN_EMAIL.toLowerCase()) {
                    // Check if email is approved
                    const approved = await fbDb.collection('accessRequests').doc(email.toLowerCase()).get();
                    if (!approved.exists || approved.data().status !== 'approved') {
                        errorEl.textContent = 'Your email has not been approved yet. Request access first.';
                        btn.disabled = false;
                        btn.textContent = 'Create Account';
                        return;
                    }
                }

                await fbAuth.createUserWithEmailAndPassword(email, password);

                // Mark as registered if they had an access request
                try {
                    const reqDoc = await fbDb.collection('accessRequests').doc(email.toLowerCase()).get();
                    if (reqDoc.exists) {
                        await fbDb.collection('accessRequests').doc(email.toLowerCase()).update({
                            status: 'registered',
                            registeredAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                } catch(e) { /* ignore — admin may not have an access request doc */ }

                // onAuthStateChanged handles the rest
            } catch (err) {
                btn.disabled = false;
                btn.textContent = 'Create Account';
                if (err.code === 'auth/email-already-in-use') {
                    errorEl.textContent = 'An account with this email already exists. Go back to sign in.';
                } else {
                    errorEl.textContent = 'Sign up failed: ' + err.message;
                }
            }
        }

        async function handleLogout() {
            if (await nwConfirm('Sign out of NitWiz?')) {
                fbAuth.signOut();
            }
        }

        function showLoginScreen() {
            document.getElementById('auth-screen').style.display = 'flex';
            document.getElementById('main-container').style.display = 'none';
            const bNavOut = document.getElementById('bottom-nav');
            if (bNavOut) bNavOut.classList.remove('visible');
            document.getElementById('splash-screen').style.display = 'none';
            showAuthPanel('login');
        }

        function showSplashScreen() {
            const splash = document.getElementById('splash-screen');
            const authScreen = document.getElementById('auth-screen');
            const main = document.getElementById('main-container');
            const bNav = document.getElementById('bottom-nav');
            if (authScreen) authScreen.style.display = 'none';
            if (main) main.style.display = 'none';
            if (bNav) bNav.classList.remove('visible');
            if (splash) {
                splash.classList.remove('fade-out');
                splash.style.display = 'flex';
            }
            var vEl = document.getElementById('splash-version');
            if (vEl && typeof APP_VERSION !== 'undefined') vEl.textContent = 'v' + APP_VERSION;
        }

        function showAuthPanel(panel) {
            document.querySelectorAll('.auth-panel').forEach(p => p.style.display = 'none');
            document.getElementById('auth-' + panel).style.display = 'block';
            // Clear errors
            document.querySelectorAll('.auth-error, .auth-success').forEach(el => el.textContent = '');
        }

        // === ADMIN FUNCTIONS ===
        async function loadAccessRequests() {
            if (!isAdmin()) return;
            const list = document.getElementById('admin-requests-list');
            const statsEl = document.getElementById('admin-stats');
            if (!list) return;
            list.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">Loading...</div>';

            try {
                const snap = await fbDb.collection('accessRequests').orderBy('requestedAt', 'desc').get();

                // Calculate stats
                let pending = 0, approved = 0, registered = 0;
                snap.forEach(doc => {
                    const s = doc.data().status;
                    if (s === 'pending') pending++;
                    else if (s === 'approved') approved++;
                    else if (s === 'registered') registered++;
                });

                if (statsEl) {
                    statsEl.innerHTML = `
                        <div class="admin-stat"><div class="admin-stat-number">${pending}</div><div class="admin-stat-label">Pending</div></div>
                        <div class="admin-stat"><div class="admin-stat-number">${approved}</div><div class="admin-stat-label">Approved</div></div>
                        <div class="admin-stat"><div class="admin-stat-number">${registered}</div><div class="admin-stat-label">Active</div></div>
                    `;
                }

                if (snap.empty) {
                    list.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">No access requests yet.</div>';
                    return;
                }

                list.innerHTML = '';
                snap.forEach(doc => {
                    const d = doc.data();
                    const div = document.createElement('div');
                    div.className = 'admin-request-card';
                    div.setAttribute('data-status', d.status);

                    const statusBadge = {
                        'pending': '○ Pending',
                        'approved': '● Approved',
                        'denied': '● Denied',
                        'registered': '✓ Registered'
                    }[d.status] || d.status;

                    const dateStr = d.requestedAt ? new Date(d.requestedAt.seconds * 1000).toLocaleDateString() : 'Unknown';

                    div.innerHTML = `
                        <div class="admin-request-info">
                            <div class="admin-request-email">${d.email}</div>
                            <div class="admin-request-name">${d.name || ''}</div>
                            <div class="admin-request-meta">${dateStr} • ${statusBadge}</div>
                        </div>
                        <div class="admin-request-actions">
                            ${d.status === 'pending' ? `
                                <button class="btn-approve" onclick="approveRequest('${d.email}')">Approve</button>
                                <button class="btn-deny" onclick="denyRequest('${d.email}')">Deny</button>
                            ` : ''}
                            ${d.status === 'approved' ? `
                                <button class="btn-deny" onclick="denyRequest('${d.email}')">Revoke</button>
                            ` : ''}
                            ${d.status === 'denied' ? `
                                <button class="btn-approve" onclick="approveRequest('${d.email}')">Approve</button>
                            ` : ''}
                            ${d.status === 'registered' ? `
                                <button class="btn-deny" onclick="denyRequest('${d.email}')">Revoke</button>
                            ` : ''}
                        </div>
                    `;
                    list.appendChild(div);
                });
            } catch (err) {
                list.innerHTML = '<div style="color:#ff6b6b;padding:1rem;">Error loading requests: ' + err.message + '</div>';
            }
        }

        async function approveRequest(email) {
            try {
                await fbDb.collection('accessRequests').doc(email).update({
                    status: 'approved',
                    approvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    approvedBy: _currentUser.email
                });
                loadAccessRequests();
            } catch (err) {
                nwAlert('Failed to approve: ' + err.message);
            }
        }

        async function denyRequest(email) {
            if (!await nwConfirm('Deny/revoke access for ' + email + '?', true)) return;
            try {
                await fbDb.collection('accessRequests').doc(email).update({
                    status: 'denied',
                    deniedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                loadAccessRequests();
            } catch (err) {
                nwAlert('Failed to deny: ' + err.message);
            }
        }

        // === ADMIN USER DATA BROWSER ===
        async function loadAllUserVaults() {
            if (!isAdmin()) return;
            const list = document.getElementById('admin-user-list');
            list.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">Loading user data...</div>';

            try {
                const snap = await fbDb.collection('vaults').get();
                if (snap.empty) {
                    list.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">No user data found.</div>';
                    return;
                }

                list.innerHTML = '';
                snap.forEach(doc => {
                    const d = doc.data();
                    let playerCount = 0;
                    try {
                        const db = JSON.parse(d.pokerDatabase || '{}');
                        playerCount = (db.realPlayers || []).length;
                    } catch(e) {}

                    const email = d.email || 'Unknown';
                    const updated = d.updatedAt ? new Date(d.updatedAt.seconds * 1000).toLocaleDateString() : 'Unknown';
                    const isSelf = _currentUser && doc.id === _currentUser.uid;

                    const div = document.createElement('div');
                    div.className = 'admin-user-card';
                    div.onclick = function() { viewUserVault(doc.id, email); };
                    div.innerHTML = `
                        <div>
                            <div class="admin-user-email">${email}${isSelf ? ' (you)' : ''}</div>
                            <div class="admin-user-meta">${playerCount} players • Updated ${updated}</div>
                        </div>
                        <div class="admin-user-arrow">›</div>
                    `;
                    list.appendChild(div);
                });
            } catch (err) {
                list.innerHTML = '<div style="color:#ff6b6b;padding:1rem;">Error: ' + err.message + '</div>';
            }
        }

        async function viewUserVault(uid, email) {
            if (!isAdmin()) return;
            const viewer = document.getElementById('admin-user-viewer');
            const title = document.getElementById('admin-viewer-title');
            const stats = document.getElementById('admin-viewer-stats');
            const playerList = document.getElementById('admin-user-players-list');

            title.textContent = email;
            stats.innerHTML = '';
            playerList.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">Loading...</div>';
            viewer.style.display = 'block';

            // Scroll to viewer
            viewer.scrollIntoView({ behavior: 'smooth', block: 'start' });

            try {
                const doc = await fbDb.collection('vaults').doc(uid).get();
                if (!doc.exists) {
                    playerList.innerHTML = '<div style="color:#ff6b6b;padding:1rem;">Vault not found.</div>';
                    return;
                }

                const data = doc.data();
                let db = {};
                try { db = JSON.parse(data.pokerDatabase || '{}'); } catch(e) {}

                const players = db.realPlayers || [];
                const archetypes = db.archetypes || [];

                // Show stats
                const playersWithObs = players.filter(p => p.observations || (p.observationsList && p.observationsList.length) || (p.weaknesses && p.weaknesses.length)).length;
                const playersWithArchetype = players.filter(p => p.archetype).length;

                stats.innerHTML = `
                    <div class="admin-stat"><div class="admin-stat-number">${players.length}</div><div class="admin-stat-label">Players</div></div>
                    <div class="admin-stat"><div class="admin-stat-number">${playersWithObs}</div><div class="admin-stat-label">With Notes</div></div>
                    <div class="admin-stat"><div class="admin-stat-number">${archetypes.length}</div><div class="admin-stat-label">Archetypes</div></div>
                `;

                if (players.length === 0) {
                    playerList.innerHTML = '<div style="text-align:center;color:#888;padding:1rem;">No players tracked.</div>';
                    return;
                }

                // Sort players: ones with data first
                const sorted = [...players].sort((a, b) => {
                    const aScore = (a.observations ? 1 : 0) + (a.archetype ? 1 : 0) + ((a.observationsList || []).length > 0 ? 1 : 0);
                    const bScore = (b.observations ? 1 : 0) + (b.archetype ? 1 : 0) + ((b.observationsList || []).length > 0 ? 1 : 0);
                    if (bScore !== aScore) return bScore - aScore;
                    return a.name.localeCompare(b.name);
                });

                playerList.innerHTML = '';
                sorted.forEach(player => {
                    const div = document.createElement('div');
                    div.className = 'admin-player-card';

                    let details = [];
                    if (player.archetype) details.push('<span>Archetype:</span> ' + player.archetype);
                    if (player.skillLevel) details.push('<span>Skill:</span> ' + player.skillLevel + '/4');
                    if (player.vpip) details.push('<span>VPIP:</span> ' + player.vpip + '/4');
                    if (player.pfrAggression) details.push('<span>PFR Agg:</span> ' + player.pfrAggression + '/4');
                    if (player.postflopAggression) details.push('<span>Post Agg:</span> ' + player.postflopAggression + '/4');

                    let obsHtml = '';
                    if (player.observations) {
                        obsHtml = '<div class="admin-player-obs">' + escapeHtml(player.observations) + '</div>';
                    }
                    if (player.observationsList && player.observationsList.length) {
                        obsHtml += player.observationsList.map(o =>
                            '<div class="admin-player-obs">' + escapeHtml(o) + '</div>'
                        ).join('');
                    }
                    if (player.weaknesses && player.weaknesses.length) {
                        obsHtml += '<div class="admin-player-obs" style="border-left:2px solid #ff8c38;margin-left:0;padding-left:0.6rem;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#ff8c38" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:3px;"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>' + player.weaknesses.map(w => escapeHtml(w)).join(' • ') + '</div>';
                    }

                    div.innerHTML = `
                        <div class="admin-player-name">${escapeHtml(player.name)}</div>
                        ${details.length ? '<div class="admin-player-detail">' + details.join(' &nbsp;•&nbsp; ') + '</div>' : ''}
                        ${obsHtml}
                    `;
                    playerList.appendChild(div);
                });
            } catch (err) {
                playerList.innerHTML = '<div style="color:#ff6b6b;padding:1rem;">Error loading data: ' + err.message + '</div>';
            }
        }

        function closeUserViewer() {
            document.getElementById('admin-user-viewer').style.display = 'none';
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        }

        // === AUTH STATE LISTENER ===
        // Enter key support for auth forms
        document.addEventListener('keydown', function(e) {
            if (e.key !== 'Enter') return;
            const active = document.activeElement;
            if (active && active.id === 'login-password') handleLogin();
            if (active && active.id === 'signup-confirm') handleSignUp();
            if (active && active.id === 'request-email') handleRequestAccess();
        });

        fbAuth.onAuthStateChanged(async function(user) {
            if (document.readyState === 'loading') {
                await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));
            }

            if (user) {
                _currentUser = user;
                // Don't touch the splash here — hideSplash() drives navigation.
                // If the splash is already gone (post-login flow), load the app now.
                const splash = document.getElementById('splash-screen');
                const splashVisible = splash && splash.style.display !== 'none';
                if (!splashVisible) {
                    await _loadApp(user);
                }
                // If splash IS visible, hideSplash() will call _loadApp() when tapped.
            } else {
                _currentUser = null;
                _appReady = false;
                _userInitiated = false;
                showSplashScreen();
            }
        });

        async function _loadApp(user) {
            const authScreen = document.getElementById('auth-screen');
            const main = document.getElementById('main-container');
            const bNav = document.getElementById('bottom-nav');
            if (authScreen) authScreen.style.display = 'none';
            if (main) { main.style.display = 'block'; main.style.opacity = '1'; }
            if (bNav) bNav.classList.add('visible');

            syncClear();

            const adminBtn = document.getElementById('admin-dashboard-btn');
            if (adminBtn) adminBtn.style.display = isAdmin() ? 'flex' : 'none';

            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) logoutBtn.title = 'Signed in as ' + user.email;

            await loadFromFirebase();
            _appReady = true;
            loadDatabase();
            // Re-load hand history now that Firebase data is in localStorage
            try {
                const saved = localStorage.getItem('nitwiz_handHistory');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    hhStoredHands = parsed.hands || [];
                    hhCurrentHandNumber = parsed.nextHandNumber || (hhStoredHands.length + 1);
                }
                const savedSession = localStorage.getItem('nitwiz_sessionData');
                if (savedSession) {
                    window._pendingSessionRestore = JSON.parse(savedSession);
                }
            } catch(e) { console.warn('Failed to reload hand history after Firebase load:', e); }
            _userInitiated = true; // any saves from here on are user-driven
            switchTab('dashboard');
            setTimeout(function() { try { hhUpdateStreetStates(); } catch(e) {} }, 200);
        }
    </script>

    <style>
        /* === AUTH SCREEN === */
        #auth-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            min-height: 100dvh;
            background: 
                linear-gradient(135deg, rgba(16, 24, 48, 0.7) 0%, rgba(22, 34, 62, 0.8) 50%, rgba(18, 30, 54, 0.7) 100%),
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95));
            padding: 1rem;
        }

        .auth-container {
            width: 100%;
            max-width: 380px;
            text-align: center;
        }

        .auth-logo {
            font-family: 'Outfit', sans-serif;
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ff8c38, #ffc068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            margin-bottom: 0.3rem;
        }

        .auth-subtitle {
            font-size: 0.65rem;
            letter-spacing: 0.4em;
            color: #6ea8dc;
            text-transform: uppercase;
            margin-bottom: 2rem;
        }

        .auth-panel {
            display: none;
        }

        .auth-card {
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.95), rgba(18, 28, 52, 0.98));
            border: 1px solid rgba(255, 140, 56, 0.2);
            border-radius: 16px;
            padding: 2rem 1.5rem;
            backdrop-filter: blur(10px);
        }

        .auth-card h2 {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 1.5rem;
        }

        .auth-input {
            width: 100%;
            padding: 0.85rem 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 10px;
            background: rgba(16, 24, 48, 0.6);
            color: #fff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .auth-input:focus {
            border-color: #ff8c38;
        }

        .auth-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .auth-btn {
            width: 100%;
            padding: 0.9rem;
            margin-top: 0.5rem;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #ff8c38, #e06a10);
            color: #fff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.1s;
        }

        .auth-btn:hover { opacity: 0.9; }

        .auth-pw-wrapper {
            position: relative;
            width: 100%;
        }
        .auth-pw-wrapper .auth-input {
            width: 100%;
            padding-right: 2.8rem;
            box-sizing: border-box;
        }
        .auth-pw-toggle {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-65%);
            background: none;
            border: none;
            cursor: pointer;
            color: rgba(255,255,255,0.4);
            padding: 0;
            display: flex;
            align-items: center;
            transition: color 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .auth-pw-toggle:hover { color: #ff8c38; }
        .auth-forgot {
            text-align: right;
            margin-top: -0.35rem;
            margin-bottom: 0.75rem;
        }
        .auth-forgot span {
            font-family: 'Outfit', sans-serif;
            font-size: 0.78rem;
            color: rgba(255,140,56,0.7);
            cursor: pointer;
            transition: color 0.2s;
        }
        .auth-forgot span:hover { color: #ff8c38; }
        .auth-btn:active { transform: scale(0.98); }
        .auth-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .auth-error {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 0.75rem;
            min-height: 1.2em;
        }

        .auth-success {
            color: #4ade80;
            font-size: 0.8rem;
            margin-top: 0.75rem;
            min-height: 1.2em;
        }

        .auth-link {
            color: #ff8c38;
            cursor: pointer;
            text-decoration: none;
            font-weight: 600;
        }

        .auth-link:hover {
            text-decoration: underline;
        }

        .auth-footer {
            margin-top: 1.2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .auth-divider {
            display: flex;
            align-items: center;
            margin: 1.2rem 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
        }

        .auth-divider::before, .auth-divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid rgba(255, 140, 56, 0.15);
        }

        .auth-divider span {
            padding: 0 0.75rem;
        }

        /* === ADMIN PANEL === */
        .admin-request-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.85rem 1rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.7), rgba(18, 28, 52, 0.9));
            border: 1px solid rgba(255, 140, 56, 0.15);
            border-radius: 10px;
        }

        .admin-request-card[data-status="pending"] {
            border-left: 3px solid #eab308;
        }
        .admin-request-card[data-status="approved"],
        .admin-request-card[data-status="registered"] {
            border-left: 3px solid #4ade80;
        }
        .admin-request-card[data-status="denied"] {
            border-left: 3px solid #ff6b6b;
        }

        .admin-request-info {
            flex: 1;
            min-width: 0;
        }

        .admin-request-email {
            font-weight: 700;
            color: #fff;
            font-size: 0.85rem;
            word-break: break-all;
        }

        .admin-request-name {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
        }

        .admin-request-meta {
            color: rgba(255, 255, 255, 0.65);
            font-size: 0.7rem;
            margin-top: 0.2rem;
        }

        .admin-request-actions {
            display: flex;
            gap: 0.4rem;
            margin-left: 0.75rem;
            flex-shrink: 0;
        }

        .btn-approve {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-deny {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #ff6b6b, #ef4444);
            color: #fff;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-approve:active, .btn-deny:active {
            transform: scale(0.95);
        }

        .admin-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .admin-stat {
            text-align: center;
            padding: 0.75rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.7), rgba(18, 28, 52, 0.9));
            border: 1px solid rgba(255, 140, 56, 0.15);
            border-radius: 10px;
        }

        .admin-stat-number {
            font-size: 1.5rem;
            font-weight: 800;
            color: #ff8c38;
        }

        .admin-stat-label {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Admin user browser */
        .admin-user-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.7), rgba(18, 28, 52, 0.9));
            border: 1px solid rgba(255, 140, 56, 0.15);
            border-radius: 10px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .admin-user-card:active {
            border-color: #ff8c38;
            transform: scale(0.98);
        }

        .admin-user-email {
            font-weight: 600;
            color: #fff;
            font-size: 0.85rem;
        }

        .admin-user-meta {
            color: rgba(255, 255, 255, 0.65);
            font-size: 0.7rem;
        }

        .admin-user-arrow {
            color: #ff8c38;
            font-size: 1.2rem;
        }

        .admin-player-card {
            padding: 0.75rem 1rem;
            margin-bottom: 0.4rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.5), rgba(18, 28, 52, 0.7));
            border: 1px solid rgba(255, 140, 56, 0.1);
            border-radius: 8px;
        }

        .admin-player-name {
            font-weight: 700;
            color: #fff;
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .admin-player-detail {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.72rem;
            line-height: 1.4;
        }

        .admin-player-detail span {
            color: #ff8c38;
            font-weight: 600;
        }

        .admin-player-obs {
            margin-top: 0.4rem;
            padding: 0.5rem 0.7rem;
            background: rgba(16, 24, 48, 0.5);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.72rem;
            font-style: italic;
            white-space: pre-wrap;
        }

        /* Logout button */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior-y: contain;
            /* Better text rendering */
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            /* Smooth scrolling */
            scroll-behavior: smooth;
            /* Prevent elastic bounce in standalone mode */
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #101830;
        }

        body {
            /* Allow body to scroll instead */
            overflow-y: auto;
            overflow-x: hidden;
            height: 100%;
            width: 100%;
        }

        :root {
            --bg-dark: #101830;
            --bg-mid: #16223e;
            --purple-primary: #ff8c38;
            --purple-light: #ffc068;
            --cyan-accent: #6ea8dc;
            --orange-accent: #ff8c38;
            --white: #ffffff;
            
            /* Legacy mappings */
            --dark-bg: #101830;
            --blue-accent: #6ea8dc;
            --orange-primary: #ff8c38;
            --card-white: #ffffff;
            --shadow-dark: rgba(16, 24, 48, 0.8);
        }

        body {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #101830;
            background-image: 
                /* Dark overlay */
                linear-gradient(135deg, rgba(16, 24, 48, 0.7) 0%, rgba(22, 34, 62, 0.8) 50%, rgba(18, 30, 54, 0.7) 100%),
                /* Brushed metal texture */
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)),
                /* Base metallic color */
                linear-gradient(180deg, rgba(16, 24, 48, 0.95), rgba(18, 28, 52, 0.98));
            color: var(--white);
            min-height: 100vh;
            padding: 1rem;
            position: relative;
            /* Touch optimizations */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            -webkit-overflow-scrolling: touch;
        }

        /* Add metallic shine effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(
                    115deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.05) 30%,
                    transparent 50%,
                    rgba(255, 255, 255, 0.05) 70%,
                    transparent 100%
                );
            pointer-events: none;
            z-index: 0;
        }

        /* Remove old effect */
        body::after {
            display: none;
        }

        /* SPLASH SCREEN */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, rgba(16, 24, 48, 0.7) 0%, rgba(22, 34, 62, 0.8) 50%, rgba(18, 30, 54, 0.7) 100%),
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)),
                linear-gradient(180deg, rgba(16, 24, 48, 0.95), rgba(18, 28, 52, 0.98));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            cursor: pointer;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        .splash-metal-sheet {
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.95), rgba(18, 28, 52, 0.98));
            border: 2px solid rgba(255, 140, 56, 0.2);
            border-radius: 16px;
            padding: 4rem 6rem;
            box-shadow: 
                0 12px 32px rgba(0, 0, 0, 0.5),
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 0 40px rgba(255, 140, 56, 0.05);
            text-align: center;
        }

        .splash-logo {
            font-family: 'Outfit', sans-serif;
            font-size: 4.5rem;
            font-weight: 800;
            color: rgba(255, 140, 56, 0.85);
            filter: drop-shadow(0 2px 8px rgba(255, 140, 56, 0.3));
            letter-spacing: 2px;
            margin-bottom: 0.3rem;
        }

        .splash-subtitle {
            font-family: 'Outfit', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            color: #6ea8dc;
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            letter-spacing: 4px;
            margin-bottom: 1.5rem;
        }

        .splash-logo-icon {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .splash-logo-icon svg {
            filter: 
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))
                drop-shadow(0 -2px 2px rgba(0, 0, 0, 0.7))
                drop-shadow(2px 0 0 rgba(255, 255, 255, 0.2))
                drop-shadow(-2px 0 2px rgba(0, 0, 0, 0.5))
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .splash-suits-metal {
            font-size: 1.6rem;
            letter-spacing: 0.6rem;
            color: rgba(255, 140, 56, 0.85);
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            filter: none;
            margin-bottom: 3rem;
        }

        .splash-card-suits {
            display: flex;
            gap: 2rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 6rem;
        }

        .splash-card-suits .suit {
            width: 48px;
            height: 48px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))
                    drop-shadow(0 -2px 2px rgba(0, 0, 0, 0.6));
        }


        .splash-card-container {
            display: flex;
            justify-content: center;
            margin-bottom: 1.2rem;
        }

        .splash-card {
            width: 120px;
            height: 168px;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.04) 40%,
                rgba(0, 0, 0, 0.02) 60%,
                rgba(0, 0, 0, 0.04) 100%
            );
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            position: relative;
            padding: 0.7rem;
            display: flex;
            flex-direction: column;
            box-shadow:
                -2px -2px 3px rgba(255, 255, 255, 0.35),
                2px 2px 4px rgba(0, 0, 0, 0.4),
                0 0 12px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -1px 1px rgba(0, 0, 0, 0.1);
        }

        .splash-card .card-corner {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.1rem;
        }

        .splash-card .card-corner.top-left {
            top: 0.5rem;
            left: 0.5rem;
        }

        .splash-card .card-corner.bottom-right {
            bottom: 0.5rem;
            right: 0.5rem;
            transform: rotate(180deg);
        }

        .splash-card .card-rank {
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
            line-height: 1;
        }

        .splash-card .card-suit-corner {
            width: 14px;
            height: 14px;
            opacity: 0.6;
            filter:
                brightness(0) saturate(100%)
                invert(65%) sepia(30%) saturate(600%) hue-rotate(175deg) brightness(95%) contrast(85%)
                drop-shadow(-1px -1px 0 rgba(255, 255, 255, 0.45))
                drop-shadow(1px 1px 1px rgba(0, 0, 0, 0.4));
        }

        .splash-card .card-center {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .splash-card .brain-icon-large {
            width: 76px;
            height: auto;
            opacity: 0.85;
            filter:
                brightness(0) saturate(100%)
                invert(65%) sepia(30%) saturate(600%) hue-rotate(175deg) brightness(95%) contrast(85%)
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))
                drop-shadow(0 -2px 2px rgba(0, 0, 0, 0.7))
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .splash-copyright {
            font-family: 'Outfit', sans-serif;
            font-size: 0.7rem;
            color: rgba(200, 200, 200, 0.6);
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            filter: none;
            letter-spacing: 0.5px;
            margin-top: 3rem;
        }

        /* DASHBOARD GRID BUTTONS */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            padding: 0 0.5rem;
            max-width: 400px;
            margin: 0 auto;
            margin-bottom: 2rem;
        }

        /* Let the last item (if odd count) center itself */
        .dashboard-grid > .dashboard-btn:last-child:nth-child(odd) {
            grid-column: 1 / -1;
            max-width: 50%;
            justify-self: center;
        }

        .dashboard-btn {
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.15);
            border-radius: 14px;
            padding: 1rem 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-height: 80px;
            width: 100%;
        }

        .dashboard-btn:hover {
            transform: translateY(-4px);
            background: linear-gradient(135deg, rgba(255, 140, 56, 0.85), rgba(230, 115, 30, 0.95));
            border-color: rgba(141, 196, 240, 0.5);
            box-shadow: 
                0 8px 20px rgba(255, 140, 56, 0.2),
                0 0 15px rgba(255, 140, 56, 0.1);
        }

        .dashboard-btn:hover svg {
            stroke: #16223e;
            opacity: 1;
        }

        .dashboard-btn:hover span {
            color: #ffffff;
        }

        .dashboard-btn:active {
            transform: translateY(0px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .dashboard-btn svg {
            width: 30px;
            height: 30px;
            filter: none;
            stroke: #ff8c38;
            opacity: 0.85;
        }

        .dashboard-btn span {
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            filter: none;
            letter-spacing: 0.5px;
            text-align: center;
            line-height: 1.2;
        }

        /* sync-dot CSS removed */

        /* CUSTOM MODAL SYSTEM */
        .nw-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .nw-modal-overlay.visible {
            opacity: 1;
        }

        .nw-modal {
            background: linear-gradient(145deg, #1a2440, #141c34);
            border: 1px solid rgba(255, 140, 56, 0.25);
            border-radius: 14px;
            padding: 1.5rem;
            min-width: 260px;
            max-width: 340px;
            width: 100%;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 140, 56, 0.08);
            transform: scale(0.95) translateY(8px);
            transition: transform 0.15s ease;
        }

        .nw-modal-overlay.visible .nw-modal {
            transform: scale(1) translateY(0);
        }

        .nw-modal-message {
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            line-height: 1.5;
            margin-bottom: 1.25rem;
        }

        .nw-modal-input {
            width: 100%;
            padding: 0.65rem 0.85rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            outline: none;
            margin-bottom: 1.25rem;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }

        .nw-modal-input:focus {
            border-color: rgba(255, 140, 56, 0.45);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.1);
        }

        .nw-modal-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .nw-modal-buttons {
            display: flex;
            gap: 0.6rem;
        }

        .nw-modal-btn {
            flex: 1;
            padding: 0.7rem;
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
        }

        .nw-modal-btn.cancel {
            background: rgba(255, 255, 255, 0.07);
            color: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nw-modal-btn.cancel:active {
            background: rgba(255, 255, 255, 0.12);
        }

        .nw-modal-btn.confirm {
            background: linear-gradient(135deg, #ff8c38, #e06a10);
            color: #fff;
        }

        .nw-modal-btn.confirm:active {
            background: linear-gradient(135deg, #e07830, #c85e0e);
            transform: scale(0.98);
        }

        .nw-modal-btn.danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #fff;
        }

        .nw-modal-btn.danger:active {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: scale(0.98);
        }

        /* DASHBOARD STATS STRIP (#1) */
        .dashboard-stats-strip {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            max-width: 400px;
            margin: 0 auto 1rem;
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid rgba(255, 140, 56, 0.08);
        }

        .dash-stat-card {
            text-align: center;
        }

        .dash-stat-number {
            font-family: 'Outfit', sans-serif;
            font-size: 1.3rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.2;
        }

        .dash-stat-label {
            font-family: 'Outfit', sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            line-height: 1.3;
            margin-top: 0.1rem;
        }

        .dash-stat-sub {
            font-family: 'Outfit', sans-serif;
            font-size: 0.6rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.25);
            margin-top: 0.05rem;
        }

        /* GLOBAL SEARCH (#2) */
        .global-search-bar {
            max-width: 400px;
            margin: 0 auto 1rem;
            padding: 0 0.5rem;
            position: relative;
        }

        .global-search-bar input {
            width: 100%;
            padding: 0.65rem 0.85rem 0.65rem 2.4rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.15);
            border-radius: 10px;
            color: #fff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }

        .global-search-bar input:focus {
            border-color: rgba(255, 140, 56, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.08);
        }

        .global-search-bar input::placeholder {
            color: rgba(255, 255, 255, 0.35);
            font-weight: 400;
        }

        .global-search-icon {
            position: absolute;
            left: calc(0.5rem + 0.75rem);
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: rgba(255, 140, 56, 0.45);
        }

        .global-search-clear {
            position: absolute;
            right: calc(0.5rem + 0.6rem);
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            padding: 4px;
            display: none;
            line-height: 1;
        }

        .global-search-clear:active {
            color: #ff8c38;
        }

        .global-search-results {
            position: absolute;
            top: 100%;
            left: 0.5rem;
            right: 0.5rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.98), rgba(18, 28, 52, 0.99));
            border: 1px solid rgba(255, 140, 56, 0.2);
            border-radius: 10px;
            margin-top: 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .global-search-results.visible {
            display: block;
        }

        .search-result-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.65rem 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid rgba(255, 140, 56, 0.06);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:active {
            background: rgba(255, 140, 56, 0.1);
        }

        .search-result-icon {
            flex-shrink: 0;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 140, 56, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .search-result-icon svg {
            width: 14px;
            height: 14px;
            stroke: #ff8c38;
            fill: none;
            stroke-width: 2;
        }

        .search-result-text {
            flex: 1;
            min-width: 0;
        }

        .search-result-name {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-name mark {
            background: rgba(255, 140, 56, 0.3);
            color: #ff8c38;
            border-radius: 2px;
            padding: 0 1px;
        }

        .search-result-meta {
            font-family: 'Outfit', sans-serif;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-badge {
            flex-shrink: 0;
            font-family: 'Outfit', sans-serif;
            font-size: 0.6rem;
            font-weight: 700;
            padding: 0.15rem 0.45rem;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .search-result-badge.player {
            background: rgba(141, 196, 240, 0.15);
            color: #8dc4f0;
        }

        .search-result-badge.archetype {
            background: rgba(255, 140, 56, 0.15);
            color: #ffc068;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.35);
        }

        /* EXIT BUTTON */
        .exit-btn {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            padding: 0;
            border-radius: 10px;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -2px 3px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .exit-btn:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 3px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -2px 3px rgba(0, 0, 0, 0.2);
        }

        .exit-btn:active {
            transform: translateX(-50%) translateY(0px);
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .exit-btn svg {
            width: 28px;
            height: 28px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3))
                    drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.4));
            stroke: #ff6b6b;
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }



        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95));
            border-radius: 16px;
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        header::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(135deg, 
                rgba(255, 140, 56, 0.4) 0%, 
                transparent 50%, 
                rgba(110, 168, 220, 0.4) 100%);
            border-radius: 16px;
            z-index: -1;
            opacity: 0.6;
        }

        h1 {
            font-family: 'Allura', cursive;
            font-size: 4rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.7);
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
            margin-bottom: 0.5rem;
            line-height: 1.2;
        }

        .card-suits {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 0.5rem;
            font-size: 2rem;
            font-style: italic;
            transform: skewX(-12deg);
        }

        .suit {
            color: rgba(255, 255, 255, 0.7);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .suit.spade::before { content: '♠'; }
        .suit.club::before { content: '♣'; }
        .suit.heart::before { content: '♥'; }
        .suit.diamond::before { content: '♦'; }

        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.875rem 1.75rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.875rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.7);
        }

        .tab:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 140, 56, 0.25);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 0 15px rgba(255, 140, 56, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, #ff8c38, #e06a10);
            color: var(--white);
            border-color: #ff8c38;
            box-shadow: 0 6px 20px rgba(255, 140, 56, 0.4);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes qoHandNumPulse {
            0%   { color: #ff8c38; }
            10%  { color: #ffffff; }
            23%  { color: #ff8c38; }
            36%  { color: #ffffff; }
            49%  { color: #ff8c38; }
            62%  { color: #ffffff; }
            100% { color: #ff8c38; }
        }

        .qo-hand-num-pulse {
            animation: qoHandNumPulse 1s ease-in-out forwards;
        }

        @keyframes chipPop {
            0%   { transform: scale(1); }
            30%  { transform: scale(1.6); }
            65%  { transform: scale(0.9); }
            85%  { transform: scale(1.08); }
            100% { transform: scale(1); }
        }

        .chip-pop {
            animation: chipPop 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            z-index: 10;
            position: relative;
        }

        /* Hover / touch-hold brightness boost for all tappable chips and buttons */
        .persona-dim-chip:hover,
        .player-dim-chip:hover,
        .player-toggle-chip:hover,
        .qo-seat-chip:hover,
        .qo-action-btn:hover,
        .desc-chip:hover,
        .hh-pos-chip:hover,
        #qo-add-player-btn:hover,
        #players-add-player-btn:hover,
        #arch-add-btn:hover,
        #qo-next-hand-btn:hover,
        #manual-sync-btn:hover {
            filter: brightness(1.4);
            transition: filter 0.15s ease;
        }

        #manual-sync-btn:active {
            transform: translateY(1px);
            filter: brightness(0.9);
        }

        #manual-sync-btn {
            transition: filter 0.15s ease, border-color 0.15s ease, color 0.15s ease;
        }

        .section {
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95));
            border-radius: 14px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-sizing: border-box;
            overflow: hidden;
            max-width: 100%;
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.4),
                0 2px 6px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        /* Subtle top edge glow */
        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 140, 56, 0.2) 50%, 
                transparent 100%);
            border-radius: 14px 14px 0 0;
            z-index: 1;
        }

        .section-title {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 1.35rem;
            font-weight: 800;
            color: #fff;
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            filter: none;
            font-variant: small-caps;
            letter-spacing: 1.4px;
            margin-bottom: 1.5rem;
            line-height: 1.2;
        }

        /* Inline name edit input on card title */
        .card-name-edit-input {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 1.35rem;
            font-weight: 800;
            font-variant: small-caps;
            letter-spacing: 1.4px;
            color: #fff;
            background: rgba(22, 34, 62, 0.5);
            border: none;
            border-bottom: 2px solid #ff8c38;
            outline: none;
            padding: 0 0.25rem;
            width: 100%;
            line-height: 1.2;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            font-size: 1.0rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.7);
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            text-shadow: none;
            filter: none;
            letter-spacing: 0.5px;
            font-variant: small-caps;
        }

        .form-group input[type="text"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 10px;
            color: var(--white);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9375rem;
            transition: all 0.3s ease;
        }

        .form-group input[type="text"]:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--purple-primary);
            background: rgba(22, 34, 62, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.1);
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            padding: 0.875rem 2rem;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9375rem;
            font-weight: 600;
            letter-spacing: 0.3px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 1rem;
            margin-bottom: 1rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            color: var(--white);
            box-shadow: 0 4px 12px rgba(255, 140, 56, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.95), rgba(18, 28, 52, 1));
            border: 1px solid rgba(255, 140, 56, 0.5);
            color: #ff8c38;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .btn-new-arch {
            background: linear-gradient(135deg, #8dc4f0 0%, #5a9fd4 100%);
            color: #16223e;
            font-weight: 700;
            box-shadow: 0 4px 12px rgba(141, 196, 240, 0.3);
        }
        .btn-new-arch:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, #ff8c38 0%, #ffa726 100%);
            color: #16223e;
            box-shadow: 0 6px 20px rgba(255, 140, 56, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--white);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.55);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #ff6b6b 100%);
            color: var(--white);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }

        /* METALLIC ICON BUTTONS */
        .btn-metallic {
            width: 56px;
            height: 56px;
            padding: 0;
            margin: 0;
            border-radius: 10px;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.18);
            border-bottom: 2px solid rgba(255, 140, 56, 0.12);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
        }

        .btn-metallic:hover {
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(255, 140, 56, 0.85), rgba(230, 115, 30, 0.95));
            border-color: rgba(141, 196, 240, 0.4);
            box-shadow:
                0 4px 8px rgba(255, 140, 56, 0.15),
                0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn-metallic:hover svg {
            stroke: #16223e;
            opacity: 1;
        }

        .btn-metallic:active {
            transform: translateY(1px);
            background: linear-gradient(145deg, rgba(18, 28, 52, 0.95), rgba(22, 34, 62, 0.85));
            border-bottom: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .btn-metallic svg {
            stroke: #ff8c38;
            filter: none;
            opacity: 0.85;
        }

        .btn-metallic.btn-delete svg {
            stroke: #ff8c38;
        }

        .btn-metallic.btn-delete:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }

        .btn-metallic.btn-delete:hover svg {
            stroke: #ffffff;
        }

        .btn-metallic.btn-save svg {
            stroke: #ff8c38;
        }

        .btn-metallic.btn-new svg {
            stroke: #ff8c38;
        }

        .btn-metallic.btn-exit svg {
            stroke: #ff8c38;
        }

        .btn-metallic.btn-home svg {
            stroke: none;
            fill: #6ea8dc;
        }
        .btn-metallic.btn-home:hover svg {
            stroke: none;
            fill: #16223e;
        }
        .btn-metallic.btn-exit:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }
        .btn-metallic.btn-exit:hover svg {
            stroke: #ffffff;
        }

        .list-container {
            display: grid;
            gap: 1rem;
        }

        .list-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--blue-accent);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .list-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: var(--orange-primary);
            transform: translateX(5px);
        }

        .list-item.selected {
            border-left-color: var(--orange-primary);
            background: rgba(255, 154, 0, 0.1);
        }

        /* Persona cards in archetype list */
        .list-item.persona-item {
            border-left: 3px solid rgba(255, 140, 56, 0.3);
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border-radius: 10px;
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            padding: 1.25rem 1.5rem;
            margin-bottom: 1rem;
        }
        .list-item.persona-item:hover {
            background: linear-gradient(145deg, rgba(18, 26, 48, 0.9), rgba(12, 20, 40, 0.95));
            border-color: rgba(255, 140, 56, 0.25);
        }
        .persona-badge {
            display: inline-block;
            font-family: 'Outfit', sans-serif;
            font-size: 0.55rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.7);
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.2));
            margin-left: 10px;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2px 7px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.4);
        }
        .persona-item .list-item-title {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--orange-primary);
            
            font-variant: small-caps;
            letter-spacing: 1.2px;
        }
        .persona-subtitle {
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            font-style: italic;
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-detail {
            display: none;
            margin-top: 1rem;
        }
        .persona-detail.open {
            display: block;
        }
        .persona-street {
            margin-bottom: 0.75rem;
        }
        .persona-street-title {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-variant: small-caps;
            color: rgba(255, 255, 255, 0.7);
            
            margin-bottom: 0.5rem;
            padding-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: flex-start;
            gap: 6px;
            align-items: center;
        }
        .persona-street-title::after {
            content: '▸';
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.65);
            transition: transform 0.2s;
            filter: none;
            text-shadow: none;
        }
        .persona-street-title.open::after {
            transform: rotate(90deg);
        }
        .persona-street-body {
            display: none;
            padding: 0.4rem 0;
        }
        .persona-street-body.open {
            display: block;
        }
        .persona-do-dont {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-top: 0.4rem;
        }
        @media (max-width: 420px) {
            .persona-do-dont {
                grid-template-columns: 1fr;
            }
        }
        .persona-do, .persona-dont {
            font-family: 'Outfit', sans-serif;
            font-size: 0.78rem;
            line-height: 1.5;
        }
        .persona-do-label, .persona-dont-label {
            font-family: 'Outfit', sans-serif;
            font-weight: 800;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-variant: small-caps;
            margin-bottom: 4px;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 
                0 1px 0 rgba(255,255,255,0.3),
                0 -1px 1px rgba(0,0,0,0.6);
            
        }
        .persona-do-label {
            background: rgba(74, 222, 128, 0.15); color: #4ade80;
        }
        .persona-dont-label {
            background: rgba(255, 107, 107, 0.15); color: #ff6b6b;
        }
        .persona-do li, .persona-dont li {
            list-style: none;
            padding: 2px 0;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-do li::before {
            content: '✓ ';
            color: #4ade80;
            font-weight: 800;
            filter: none;
            
        }
        .persona-dont li::before {
            content: '✗ ';
            color: #ff6b6b;
            font-weight: 800;
            filter: none;
            
        }
        .persona-table {
            width: 100%;
            font-size: 0.75rem;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }
        .persona-table th, .persona-table td {
            padding: 5px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-table th {
            font-weight: 800;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-variant: small-caps;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-quote {
            font-family: 'Outfit', sans-serif;
            font-style: italic;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 1rem;
            padding: 0.5rem 0.75rem;
            border-left: 3px solid rgba(0,0,0,0.2);
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-section-divider {
            font-family: 'Outfit', sans-serif;
            font-size: 0.92rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-variant: small-caps;
            color: #ff8c38;
            
            margin: 1.2rem 0 0.6rem;
            padding-top: 0.85rem;
            padding-bottom: 0.3rem;
        }
        .persona-section-divider.collapsible {
            cursor: pointer;
            display: flex;
            justify-content: flex-start;
            gap: 6px;
            color: #ff8c38;
            background: none;
            -webkit-background-clip: unset;
            text-shadow: none;
            filter: none;
            align-items: center;
        }
        .persona-section-divider.collapsible::after {
            content: '▾';
            font-size: 0.75rem;
            color: #ff8c38;
            transition: transform 0.2s;
            filter: none;
            text-shadow: none;
        }
        .persona-section-divider.collapsible.collapsed::after {
            content: '▸';
            color: #ff8c38;
        }
        .persona-section-body {
            display: block;
        }
        .persona-section-body.collapsed {
            display: none;
        }
        /* Metallic body text for inline persona detail elements */
        .persona-detail-text {
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-meta-label {
            font-weight: 800;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-variant: small-caps;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-strengths-leaks {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-strengths-label {
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-leaks-label {
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
            
        }
        .persona-quick-id {
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.75rem;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.7);
            background-color: rgba(0,0,0,0.05);
            /* text gradient applied inline */
        }
        @media (max-width: 420px) {
            .list-item.persona-item {
                padding: 1rem;
            }
            .persona-strengths-leaks {
                grid-template-columns: 1fr;
            }
        }

        /* Persona dimension displays (read-only slider/chip mirrors) */
        .persona-dim-section {
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
        }
        .persona-dim-section-title {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-variant: small-caps;
            color: #ff8c38;
            
            margin-bottom: 0.5rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid rgba(255, 140, 56, 0.15);
        }
        .persona-dim-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.35rem;
            gap: 0.5rem;
        }
        .persona-dim-label {
            font-family: 'Outfit', sans-serif;
            font-size: 0.82rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 0;
        }
        .persona-dim-chips {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        .persona-dim-chip {
            font-family: 'Outfit', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 3px 7px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.13);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            box-shadow: none;
            transition: all 0.2s ease;
        }
        .persona-dim-chip.active {
            border: 1px solid rgba(255, 140, 56, 0.4);
            background: linear-gradient(180deg, 
                rgba(255, 140, 56, 0.25) 0%, 
                rgba(224, 106, 16, 0.35) 100%);
            color: #ffc068;
            font-weight: 800;
            text-shadow: none;
            box-shadow: 
                0 0 8px rgba(255, 140, 56, 0.15),
                0 2px 4px rgba(0,0,0,0.2);
            letter-spacing: 0.02em;
        }
        /* Unassessed dimension row — white text with border, none active */
        .persona-dim-chips.unassessed .player-dim-chip {
            color: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
        }

        /* Interactive player chips */
        .player-dim-chip {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }
        .player-dim-chip:active {
            transform: scale(0.93);
        }
        /* Toggle chips (multi-select) */
        .player-toggle-chip {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }
        .player-toggle-chip:active {
            transform: scale(0.93);
        }
        .player-toggle-chip.active {
            border: 1px solid rgba(255, 140, 56, 0.4);
            background: linear-gradient(180deg, 
                rgba(255, 140, 56, 0.25) 0%, 
                rgba(224, 106, 16, 0.35) 100%);
            color: #ffc068;
            font-weight: 800;
            text-shadow: none;
            box-shadow: 
                0 0 8px rgba(255, 140, 56, 0.15),
                0 2px 4px rgba(0,0,0,0.2);
            letter-spacing: 0.02em;
        }
        .persona-toggle-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 0.35rem;
        }
        .custom-toggle-chip {
            cursor: pointer;
            position: relative;
        }
        .custom-toggle-chip::after {
            content: '×';
            margin-left: 4px;
            font-size: 0.7rem;
            opacity: 0.6;
        }
        @media (max-width: 360px) {
            .persona-dim-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }
            .persona-dim-chips {
                justify-content: flex-start;
            }
            .persona-dim-chip {
                font-size: 0.65rem;
                padding: 3px 6px;
            }
        }

        .list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .list-item-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--orange-primary);
        }

        .list-item-meta {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .tag {
            padding: 0.25rem 0.75rem;
            background: rgba(255, 154, 0, 0.2);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--orange-primary);
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        /* MOBILE OPTIMIZATION */
        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }

            /* Body & Container */
            body {
                padding: 0.5rem;
                padding-top: max(0.5rem, env(safe-area-inset-top));
                padding-left: max(0.5rem, env(safe-area-inset-left));
                padding-right: max(0.5rem, env(safe-area-inset-right));
                padding-bottom: max(0.5rem, env(safe-area-inset-bottom));
            }

            .container {
                padding: 0;
            }

            /* Splash Screen - Mobile */
            .splash-metal-sheet {
                padding: 3rem 2rem;
                margin: 1rem;
            }

            .splash-logo {
                font-size: 3rem;
                margin-bottom: 1.5rem;
            }

            .splash-card-suits {
                gap: 1.5rem;
                margin-bottom: 4rem;
            }

            .splash-card-suits .suit {
                width: 36px;
                height: 36px;
            }

            /* Dashboard - Mobile Grid */
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.6rem;
                padding: 0 0.5rem;
                margin-bottom: 1.5rem;
            }

            .dashboard-btn {
                min-height: 75px;
                padding: 0.75rem 0.5rem;
                aspect-ratio: auto;
            }

            .dashboard-btn svg {
                width: 24px;
                height: 24px;
            }

            .dashboard-btn span {
                font-size: 0.75rem;
            }

            .dashboard-stats-strip {
                padding: 0 0.5rem;
            }

            /* Drum Picker - Mobile */
            .combo-lock-frame {
                width: 100%;
            }

            .combo-lock-frame .apple-picker-container {
                height: 220px;
            }

            .apple-picker-item {
                height: 40px;
                font-size: 0.85rem;
            }

            .apple-picker-item.selected {
                font-size: 1rem;
            }
            
            .apple-picker-selection-bar {
                height: 40px;
            }

            /* Form Elements - Mobile */
            .section {
                padding: 1rem;
                margin-bottom: 1rem;
                overflow: hidden;
            }

            .form-subsection {
                padding: 0.75rem;
            }

            .section-title {
                font-size: 1.25rem;
            }

            .form-subsection-header {
                font-size: 0.95rem;
            }

            /* Sliders - Larger Touch Targets */
            .range-slider::-webkit-slider-thumb {
                width: 28px;
                height: 34px;
            }

            .range-slider::-moz-range-thumb {
                width: 28px;
                height: 34px;
            }

            .slider-value-labels {
                font-size: 0.75rem;
            }

            /* Buttons - Larger Touch Targets */
            .btn-metallic {
                width: 54px;
                height: 54px;
                min-width: 54px;
                min-height: 54px;
            }

            .btn-metallic svg {
                width: 22px;
                height: 22px;
            }

            /* Button Row - Mobile Spacing */
            .form-group:has(.btn-metallic) > div {
                max-width: 100% !important;
                gap: 0.5rem;
            }

            /* Exit Button - Mobile */
            .exit-btn {
                width: 54px;
                height: 54px;
                bottom: 1rem;
            }

            .exit-btn svg {
                width: 22px;
                height: 22px;
            }

            /* Text Areas */
            textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            input[type="text"],
            input[type="number"] {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            /* Form Groups */
            .form-group {
                margin-bottom: 1.5rem;
            }

            .slider-layout {
                gap: 0.6rem;
            }

            .slider-layout label {
                min-width: 100px;
                font-size: 0.82rem;
            }

            .slider-value-labels {
                font-size: 0.7rem;
                padding: 0 4px;
                gap: 2px;
            }

            .slider-value-label {
                text-align: center;
            }

            /* Descriptor Chips - Mobile */
            .desc-selector {
                gap: 0.4rem 0.5rem;
            }

            .desc-chip {
                font-size: 0.72rem;
                padding: 0.3rem 0.1rem;
                letter-spacing: 0.3px;
            }

            .form-group.slider-layout:has(.desc-selector) {
                flex-direction: column;
                gap: 0.3rem;
            }

            .form-group.slider-layout:has(.desc-selector) > label {
                min-width: unset;
                padding-top: 0;
            }

            .form-group.slider-layout.session-format-row {
                flex-direction: row !important;
                gap: 0.6rem !important;
            }
            .form-group.slider-layout.session-format-row > label {
                min-width: 100px !important;
            }

            /* Notecard - Mobile */
            .notecard-section {
                min-height: 80px;
            }

            .notecard-entry {
                font-size: 0.78rem;
            }

            .notecard-inline-input {
                font-size: 16px; /* Prevents iOS zoom */
            }

            .notecard-edit-btn,
            .notecard-add-btn {
                padding: 0.5rem;
            }

            /* Form subsection spacing */
            .form-subsection {
                margin-bottom: 1rem;
                padding: 0.75rem;
            }
        }

        /* Small Phones - Stack sliders vertically */
        @media (max-width: 480px) {
            .form-group.slider-layout {
                flex-direction: column;
                gap: 0.3rem;
            }

            .form-group.slider-layout > label {
                min-width: unset;
                padding-top: 0;
                margin-bottom: 0.15rem;
            }

            .slider-value-labels {
                font-size: 0.72rem;
                padding: 0 2px;
            }
        }

        /* Extra Small Phones */
        @media (max-width: 375px) {
            .splash-logo {
                font-size: 2.5rem;
            }

            .splash-card-suits {
                gap: 1rem;
            }

            .splash-card-suits .suit {
                width: 30px;
                height: 30px;
            }

            .dashboard-btn {
                min-height: 100px;
                padding: 1.5rem 1rem;
            }

            .dashboard-btn svg {
                width: 32px;
                height: 32px;
            }

            .dashboard-btn span {
                font-size: 0.95rem;
            }

            .combo-lock-frame {
                width: 100%;
            }
            .combo-lock-frame .apple-picker-container {
                height: 200px;
            }

            .btn-metallic {
                width: 48px;
                height: 48px;
                min-width: 48px;
                min-height: 48px;
            }

            .slider-layout label {
                min-width: 80px !important;
                font-size: 0.78rem;
            }

            .slider-value-labels {
                font-size: 0.65rem !important;
                padding: 0 2px !important;
            }

            .desc-chip {
                font-size: 0.68rem;
                padding: 0.25rem 0.05rem;
            }

            .desc-selector {
                gap: 0.35rem;
            }
        }

        /* Landscape Phones */
        @media (max-width: 768px) and (orientation: landscape) {
            .splash-metal-sheet {
                padding: 2rem;
            }

            .splash-logo {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }

            .splash-card-suits {
                margin-bottom: 2rem;
            }

            .combo-lock-frame .apple-picker-container {
                height: 180px;
            }

            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
        }

        /* Touch Improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Larger tap targets for touch devices */
            .btn,
            .dashboard-btn,
            .btn-metallic,
            .exit-btn,
            .apple-picker-item {
                -webkit-tap-highlight-color: rgba(255, 140, 56, 0.2);
            }

            /* Remove hover states on touch */
            .btn:hover,
            .dashboard-btn:hover,
            .btn-metallic:hover {
                transform: none;
            }

            /* Active states for touch feedback */
            .btn:active,
            .dashboard-btn:active {
                transform: scale(0.98);
            }

            .btn-metallic:active {
                transform: translateY(1px);
            }
        }

        /* Tablet Portrait */
        @media (min-width: 769px) and (max-width: 1024px) {
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .combo-lock-frame {
                width: 100%;
            }
        }

        .brief-player {
            background: rgba(0, 0, 0, 0.3);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 4px solid var(--blue-accent);
        }

        .brief-player-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--orange-primary);
            margin-bottom: 0.5rem;
        }

        .brief-section {
            margin-top: 1rem;
        }

        .brief-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--blue-accent);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .brief-list {
            list-style: none;
            padding-left: 0;
        }

        .brief-list li {
            padding: 0.25rem 0;
            padding-left: 1.5rem;
            position: relative;
        }

        .brief-list li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: var(--orange-primary);
        }

        .brief-list.warnings li:before {
            content: "⚠";
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: rgba(22, 34, 62, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 140, 56, 0.1);
            transition: all 0.2s ease;
        }

        .checkbox-group:hover {
            background: rgba(22, 34, 62, 0.5);
            border-color: rgba(255, 140, 56, 0.2);
        }

        .toggle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        /* Toggle switch styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 56px;
            height: 28px;
        }

        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 140, 56, 0.3) 0%, rgba(255, 140, 56, 0.2) 100%);
            border-radius: 28px;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 2px rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
        }

        /* Y letter on LEFT - revealed when slider moves RIGHT */
        .toggle-slider::before {
            content: 'Y';
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
            z-index: 0;
        }

        /* N letter on RIGHT - revealed when slider is LEFT */
        .toggle-slider::after {
            content: 'N';
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
            z-index: 0;
        }

        /* Slider knob */
        .toggle-knob {
            position: absolute;
            height: 20px;
            width: 20px;
            left: 2px;
            top: 2px;
            background: 
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)),
                linear-gradient(180deg, rgba(22, 34, 62, 0.8) 0%, rgba(22, 34, 62, 0.7) 100%);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
            z-index: 1;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            border-color: #ff8c38;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.2),
                0 0 12px rgba(255, 140, 56, 0.4);
        }

        /* Brighten Y when checked (slider RIGHT, revealing LEFT) */
        .toggle-switch input:checked + .toggle-slider::before {
            color: rgba(255, 255, 255, 0.8);
        }

        /* Dim N when checked */
        .toggle-switch input:checked + .toggle-slider::after {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Move knob when checked */
        .toggle-switch input:checked + .toggle-slider .toggle-knob {
            transform: translateX(28px);
            background: 
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)),
                linear-gradient(180deg, rgba(22, 34, 62, 0.75) 0%, rgba(22, 34, 62, 0.8) 100%);
        }

        .toggle-label {
            margin: 0;
            cursor: pointer;
            font-size: 1.0rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 1px;
            font-variant: small-caps;
        }

        .toggle-status {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(255, 255, 255, 0.65);
            text-align: center;
        }

        .toggle-switch input:checked ~ .toggle-status {
            color: #ff8c38;
        }

        /* Old checkbox styling - keep for other sections */
        .checkbox-group input[type="checkbox"]:not(.toggle-switch input) {
            width: 20px;
            height: 20px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 2px solid rgba(255, 140, 56, 0.4);
            border-radius: 4px;
            background: rgba(22, 34, 62, 0.6);
            transition: all 0.2s ease;
            position: relative;
        }

        .checkbox-group input[type="checkbox"]:not(.toggle-switch input):checked {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            border-color: #ff8c38;
        }

        .checkbox-group input[type="checkbox"]:not(.toggle-switch input):checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-size: 1.0rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 1px;
            font-variant: small-caps;
        }

        /* Inline radio/checkbox labels inside form groups */
        .inline-label {
            margin: 0;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 0.5px;
            font-variant: small-caps;
        }

        /* Modern radio button styling */
        input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 140, 56, 0.4);
            border-radius: 50%;
            background: rgba(22, 34, 62, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        /* SLIDER CONTROLS - Replacing radio buttons for Low/Med/High */
        .slider-control-group {
            margin-top: 0.5rem;
        }

        /* Form group with slider - label on left, slider on right */
        .form-group.slider-layout {
            display: flex;
            align-items: flex-start;
            gap: 2rem;
        }

        .form-group.slider-layout > label {
            min-width: 180px;
            margin-bottom: 0;
            padding-top: 0.5rem;
        }

        .form-group.slider-layout .slider-control-group {
            flex: 1;
            margin-top: 0;
        }

        .slider-value-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            padding: 0 10px;
        }

        .slider-value-label {
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            
            font-variant: small-caps;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .slider-value-label.active {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            -webkit-background-clip: text;
            text-shadow: 0 0 8px rgba(255, 140, 56, 0.6);
            filter: drop-shadow(0 0 4px rgba(255, 140, 56, 0.4));
        }

        .slider-etched-line {
            position: relative;
            height: 8px;
            /* Recessed metallic channel */
            background:
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)),
                linear-gradient(180deg, rgba(255, 255, 255, 0.35) 0%, rgba(18, 28, 52, 0.85) 50%, rgba(255, 255, 255, 0.35) 100%);
            border-radius: 4px;
            border-top: 1px solid rgba(0, 0, 0, 0.35);
            border-bottom: 1px solid rgba(255, 255, 255, 0.45);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 -1px 2px rgba(255, 255, 255, 0.15),
                
            margin: 0 10px;
        }

        /* Notch marks at the three positions */
        .slider-etched-line::before {
            content: '';
            position: absolute;
            top: -3px;
            bottom: -3px;
            left: 50%;
            width: 2px;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(0,0,0,0.25) 0%, rgba(255,255,255,0.2) 100%);
            border-radius: 1px;
        }

        .range-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            outline: none;
            cursor: pointer;
            position: relative;
            top: -8px;
            margin: 0;
            padding: 0;
        }

        /* Track — invisible, the etched-line is the visual track */
        .range-slider::-webkit-slider-runnable-track {
            height: 8px;
            background: transparent;
            border-radius: 4px;
        }

        .range-slider::-moz-range-track {
            height: 8px;
            background: transparent;
            border: none;
            border-radius: 4px;
        }

        /* Thumb — machined metal knob */
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            margin-top: -10px;
            /* Brushed steel knob */
            background:
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)) 0px,
                    rgba(22, 34, 62, 0.75) 1px,
                    rgba(22, 34, 62, 0.8) 2px
                ),
                linear-gradient(90deg, rgba(18, 28, 52, 0.85) 0%, rgba(22, 34, 62, 0.8) 30%, rgba(22, 34, 62, 0.75) 50%, rgba(22, 34, 62, 0.8) 70%, rgba(18, 28, 52, 0.85) 100%);
            border: 1.5px solid #8a8e96;
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.35),
                0 1px 3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                inset 1px 0 0 rgba(255, 255, 255, 0.35),
                inset -1px 0 0 rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.15s ease;
        }

        .range-slider::-moz-range-thumb {
            width: 22px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            background:
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)) 0px,
                    rgba(22, 34, 62, 0.75) 1px,
                    rgba(22, 34, 62, 0.8) 2px
                ),
                linear-gradient(90deg, rgba(18, 28, 52, 0.85) 0%, rgba(22, 34, 62, 0.8) 30%, rgba(22, 34, 62, 0.75) 50%, rgba(22, 34, 62, 0.8) 70%, rgba(18, 28, 52, 0.85) 100%);
            border: 1.5px solid #8a8e96;
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.35),
                0 1px 3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                inset 1px 0 0 rgba(255, 255, 255, 0.35),
                inset -1px 0 0 rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.15s ease;
        }

        /* Hover — lift effect */
        .range-slider::-webkit-slider-thumb:hover {
            box-shadow:
                0 5px 12px rgba(0, 0, 0, 0.4),
                0 2px 5px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                inset 1px 0 0 rgba(255, 255, 255, 0.03),
                inset -1px 0 0 rgba(0, 0, 0, 0.15),
                0 0 8px rgba(255, 140, 56, 0.15);
        }

        .range-slider::-moz-range-thumb:hover {
            box-shadow:
                0 5px 12px rgba(0, 0, 0, 0.4),
                0 2px 5px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                inset 1px 0 0 rgba(255, 255, 255, 0.03),
                inset -1px 0 0 rgba(0, 0, 0, 0.15),
                0 0 8px rgba(255, 140, 56, 0.15);
        }

        /* Active — pressed down */
        .range-slider::-webkit-slider-thumb:active {
            box-shadow:
                0 1px 4px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.15),
                inset 0 -1px 0 rgba(255, 255, 255, 0.03),
                0 0 12px rgba(255, 140, 56, 0.2);
        }

        .range-slider::-moz-range-thumb:active {
            box-shadow:
                0 1px 4px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.15),
                inset 0 -1px 0 rgba(255, 255, 255, 0.03),
                0 0 12px rgba(255, 140, 56, 0.2);
        }

        /* Purple position indicator — sits inside the track */
        .slider-container {
            position: relative;
        }

        .slider-container::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: radial-gradient(circle at 40% 40%, #ffc068 0%, #ff8c38 60%, #e06a10 100%);
            pointer-events: none;
            box-shadow:
                0 0 4px rgba(255, 140, 56, 0.5),
                inset 
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: left 0.1s ease;
        }

        /* ============================================
           COMBINATION LOCK DRUM PICKER
           ============================================ */

        /* Outer frame — the lock housing bolted to the case */
        .combo-lock-frame {
            position: relative;
            width: 100%;
            margin: 0 auto;
            padding: 14px 18px;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95));
            border-radius: 10px;
            border: 1px solid rgba(255, 140, 56, 0.15);
            box-shadow:
                0 6px 20px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Mounting bolts */
        .combo-bolt {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
        }
        .combo-bolt-left { left: -4px; }
        .combo-bolt-right { right: -4px; }

        .combo-bolt-head {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background:
                radial-gradient(circle at 35% 35%, rgba(22, 34, 62, 0.75) 0%, rgba(22, 34, 62, 0.7) 40%, rgba(18, 28, 52, 0.85) 100%);
            border: 1px solid rgba(255, 140, 56, 0.2);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.4),
                ;
            position: relative;
        }

        /* Phillips-head screw cross */
        .combo-bolt-head::before,
        .combo-bolt-head::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            background: linear-gradient(180deg, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.15) 100%);
            border-radius: 1px;
        }
        .combo-bolt-head::before {
            width: 7px;
            height: 1.5px;
            transform: translate(-50%, -50%);
        }
        .combo-bolt-head::after {
            width: 1.5px;
            height: 7px;
            transform: translate(-50%, -50%);
        }

        /* The drum window — recessed slot in the housing */
        .combo-lock-frame .apple-picker-container {
            position: relative;
            height: 260px;
            width: 100%;
            max-width: none;
            margin: 0;
            overflow: hidden;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(18, 28, 52, 0.95), rgba(16, 24, 48, 0.98));
            border: 1px solid rgba(255, 140, 56, 0.15);
            box-shadow:
                inset 0 4px 8px rgba(0, 0, 0, 0.35),
                inset 0 -4px 8px rgba(0, 0, 0, 0.2),
                inset 4px 0 8px rgba(0, 0, 0, 0.15),
                inset -4px 0 8px rgba(0, 0, 0, 0.15);
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .combo-lock-frame .apple-picker-container:active {
            cursor: grabbing;
        }

        /* Grip ridges on drum sides */
        .drum-ridge {
            position: absolute;
            top: 10%;
            bottom: 10%;
            width: 6px;
            z-index: 12;
            pointer-events: none;
        }
        .drum-ridge-left { left: 0; }
        .drum-ridge-right { right: 0; }

        .drum-ridge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(0deg, 
                rgba(255, 140, 56, 0.08) 0px, 
                rgba(255, 255, 255, 0.03) 1px, 
                transparent 2px);
            background-size: 100% 4px;
        }

        /* Top curvature shadow — drum rolling away from viewer */
        .combo-lock-frame .apple-picker-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 44%;
            background: linear-gradient(
                180deg,
                rgba(16, 24, 48, 0.98) 0%,
                rgba(10, 16, 32, 0.88) 20%,
                rgba(12, 18, 36, 0.55) 50%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 10;
            border-radius: 6px 6px 0 0;
        }

        /* Bottom curvature shadow */
        .combo-lock-frame .apple-picker-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 44%;
            background: linear-gradient(
                0deg,
                rgba(16, 24, 48, 0.98) 0%,
                rgba(10, 16, 32, 0.88) 20%,
                rgba(12, 18, 36, 0.55) 50%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 10;
            border-radius: 0 0 6px 6px;
        }

        /* Selection window — the reading notch */
        .apple-picker-selection-bar {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 44px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: 11;
            border-top: none;
            border-bottom: none;
            background: none;
            box-shadow: none;
        }

        /* Left & right selection arrows / indicator marks */
        .apple-picker-selection-bar::before,
        .apple-picker-selection-bar::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 0;
            height: 0;
            transform: translateY(-50%);
        }
        .apple-picker-selection-bar::before {
            left: -1px;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid rgba(255, 140, 56, 0.4);
            filter: none;
        }
        .apple-picker-selection-bar::after {
            right: -1px;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 8px solid rgba(255, 140, 56, 0.4);
            filter: none;
        }

        /* Touch capture overlay — invisible, sits on top of everything in the drum */
        .drum-touch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 20;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Scroll area */
        .apple-picker-scroll {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            touch-action: none;
        }

        /* The moving list */
        .drum-cylinder {
            position: absolute;
            width: 100%;
            left: 0;
            will-change: transform;
            touch-action: none;
        }

        /* Individual drum plate — etched into the cylinder surface */
        .apple-picker-item {
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            touch-action: none;
            /* Laser-etched text — matching app style, softer */
            color: rgba(255, 255, 255, 0.7);
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.15));
            font-variant: small-caps;
            letter-spacing: 0.8px;
            cursor: pointer;
            padding: 0 2rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: filter 0.12s;
            /* Groove between plates */
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
        }

        /* Alternating subtle tint for depth */
        .apple-picker-item:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        /* Selected item — bold orange text */
        .apple-picker-item.selected {
            font-size: 1.1rem;
            font-weight: 800;
            letter-spacing: 1.2px;
            color: #ff8c38;
            background: none;
            -webkit-background-clip: unset;
            text-shadow: 0 0 8px rgba(255, 140, 56, 0.3);
            filter: none;
        }

        .apple-picker-overlay-top,
        .apple-picker-overlay-bottom {
            display: none;
        }

        /* Inline edit input inside drum item */
        .drum-inline-edit {
            width: 85%;
            height: 34px;
            border: none;
            border-bottom: 2px solid rgba(255, 140, 56, 0.6);
            background: rgba(22, 34, 62, 0.8);
            color: #ffc068;
            font-family: 'Outfit', sans-serif;
            font-size: 1.05rem;
            font-weight: 700;
            text-align: center;
            letter-spacing: 0.8px;
            font-variant: small-caps;
            outline: none;
            border-radius: 3px 3px 0 0;
            box-shadow:
                inset 0 1px 3px rgba(0, 0, 0, 0.15),
                0 0 8px rgba(255, 140, 56, 0.15);
        }

        .drum-inline-edit:focus {
            border-bottom-color: rgba(255, 140, 56, 0.9);
            background: rgba(22, 34, 62, 0.9);
            box-shadow:
                inset 0 1px 3px rgba(0, 0, 0, 0.15),
                0 0 12px rgba(255, 140, 56, 0.25);
        }

        .apple-picker-item.editing {
            background: rgba(255, 140, 56, 0.04) !important;
        }

        /* ============================================
           DESCRIPTOR CHIPS — Tap to Select (text only)
           ============================================ */
        .desc-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            flex: 1;
            padding-top: 0.35rem;
        }

        .desc-chip {
            padding: 0.2rem 0.1rem;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            font-variant: small-caps;
            letter-spacing: 0.5px;
            background: none;
            transition: all 0.3s ease;
            /* Unselected — etched metal text */
            color: rgba(255, 255, 255, 0.7);
            
            box-shadow: none;
        }

        .desc-chip:hover {
            filter: drop-shadow(0 0 3px rgba(255, 140, 56, 0.3));
        }

        .desc-chip:active {
            transform: none;
        }

        /* Selected — purple glow text */
        .desc-chip.active {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 8px rgba(255, 140, 56, 0.6);
            filter: drop-shadow(0 0 4px rgba(255, 140, 56, 0.4));
            box-shadow: none;
            border: none;
        }

        .desc-chip.active:hover {
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            -webkit-background-clip: text;
        }

        /* ============================================
           KEY WEAKNESSES — Input + Etched Plates
           ============================================ */
        .weakness-input {
            width: 100%;
            padding: 0.5rem 0.6rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 6px;
            color: var(--white);
            font-family: 'Outfit', sans-serif;
            font-size: 0.82rem;
            transition: all 0.3s ease;
        }

        .weakness-input:focus {
            outline: none;
            border-color: var(--purple-primary);
            background: rgba(22, 34, 62, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.1);
        }

        /* ============================================
           NOTECARD LAYOUT — Read-only + Pen Edit
           ============================================ */
        .notecard-section {
            min-height: 100px;
        }

        .notecard-layout {
            min-height: 80px;
        }

        .notecard-display {
            display: flex;
            flex-direction: column;
            min-height: 80px;
        }

        .notecard-entries {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        /* Read-only etched entry */
        .notecard-entry {
            display: flex;
            align-items: center;
            font-family: 'Outfit', sans-serif;
            font-size: 0.82rem;
            font-weight: 600;
            line-height: 1.5;
            color: #ffffff;
            padding: 0.15rem 0;
        }

        .notecard-entry-text::before {
            content: '• ';
            opacity: 0.4;
        }

        .notecard-entry-text {
            flex: 1;
        }

        /* Delete × shown only in edit mode */
        .notecard-entry-delete {
            display: none;
            width: 18px;
            height: 18px;
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            align-items: center;
            justify-content: center;
            opacity: 0.4;
            transition: opacity 0.2s;
            flex-shrink: 0;
            margin-left: 0.5rem;
        }

        .notecard-entry-delete:hover {
            opacity: 0.8;
        }

        .notecard-entry-delete svg {
            stroke: #ff6b6b;
        }

        /* Edit mode — show delete buttons */
        .notecard-entries.editing .notecard-entry-delete {
            display: flex;
        }

        .notecard-entries.editing .notecard-entry {
            /* Subtle background hint when editable */
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            background: linear-gradient(135deg, rgba(255, 140, 56, 0.3) 0%, rgba(255, 140, 56, 0.2) 100%);
            -webkit-background-clip: text;
        }

        /* Inline add input (appears in the entries list) */
        .notecard-inline-input {
            width: 100%;
            padding: 0.3rem 0.4rem;
            background: rgba(22, 34, 62, 0.5);
            border: 1px solid rgba(255, 140, 56, 0.35);
            border-radius: 4px;
            color: #ffffff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.82rem;
            outline: none;
            margin-top: 0.2rem;
        }

        .notecard-inline-input:focus {
            border-color: var(--purple-primary);
            box-shadow: 0 0 0 2px rgba(255, 140, 56, 0.1);
        }

        .notecard-empty {
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-style: italic;
            opacity: 0.7;
            color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 0;
        }

        /* Bottom actions row */
        .notecard-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.3rem;
            margin-top: 0.5rem;
        }

        .notecard-edit-btn,
        .notecard-add-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.3rem;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .notecard-edit-btn svg,
        .notecard-add-btn svg {
            stroke: #ff8c38;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }

        .notecard-edit-btn:hover,
        .notecard-add-btn:hover {
            opacity: 1;
        }

        .notecard-edit-btn.active {
            opacity: 0.9;
        }

        .notecard-edit-btn.active svg {
            stroke: #ff8c38;
            filter: drop-shadow(0 0 4px rgba(255, 140, 56, 0.4));
        }

        .notecard-add-btn {
            display: inline-flex;
        }

        input[type="radio"]:checked {
            border-color: #ff8c38;
            background: rgba(22, 34, 62, 0.8);
        }

        input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        input[type="radio"]:hover {
            border-color: rgba(255, 140, 56, 0.6);
        }

        /* Radio group container */
        .radio-group-container {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .radio-option-modern {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            background: rgba(22, 34, 62, 0.3);
            border: 1px solid rgba(255, 140, 56, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .radio-option-modern:hover {
            background: rgba(22, 34, 62, 0.5);
            border-color: rgba(255, 140, 56, 0.3);
        }

        .radio-option-modern input[type="radio"]:checked ~ label,
        .radio-option-modern:has(input[type="radio"]:checked) {
            background: rgba(255, 140, 56, 0.15);
            border-color: rgba(255, 140, 56, 0.4);
        }

        .radio-option-modern label {
            margin: 0;
            cursor: pointer;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            
            font-variant: small-caps;
        }

        /* Section dividers and contrast */
        .form-section-divider {
            margin: 3rem 0 2rem 0;
            padding: 1.5rem;
            background: 
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)) 0px,
                    rgba(18, 28, 52, 0.85) 0.5px,
                    rgba(22, 34, 62, 0.7) 1px,
                    rgba(18, 28, 52, 0.85) 1.5px,
                    rgba(255, 140, 56, 0.2) 2px
                ),
                linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, rgba(18, 28, 52, 0.85) 50%, rgba(255, 255, 255, 0.4) 100%);
            border-left: 4px solid var(--purple-primary);
            border-radius: 12px;
            position: relative;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .form-section-divider::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(180deg, #ff8c38 0%, #6ea8dc 100%);
            border-radius: 4px 0 0 4px;
            box-shadow: 0 0 16px rgba(255, 140, 56, 0.6);
        }

        .form-section-header {
            font-family: 'Outfit', sans-serif;
            font-size: 0.92rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-variant: small-caps;
            color: rgba(255, 255, 255, 0.7);
            
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .form-section-header::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, var(--purple-primary) 0%, var(--cyan-accent) 100%);
            border-radius: 2px;
            box-shadow: 0 0 12px var(--purple-primary);
        }

        /* Alternating subsection backgrounds */
        .form-subsection {
            margin: 1.5rem 0;
            padding: 1.5rem;
            box-sizing: border-box;
            overflow: hidden;
            max-width: 100%;
            background: 
                /* Brushed nickel */
                linear-gradient(90deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.9)),
                linear-gradient(180deg, rgba(22, 34, 62, 0.75) 0%, rgba(22, 34, 62, 0.65) 50%, rgba(22, 34, 62, 0.75) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15),
                inset 1px 0 0 rgba(255, 255, 255, 0.03),
                inset -1px 0 0 rgba(0, 0, 0, 0.1);
        }

        .form-subsection:nth-child(even) {
            /* Same style for all cards */
        }

        .form-subsection-header {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: #ff8c38;
            
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-bottom: 2px solid rgba(255, 140, 56, 0.4);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0.5rem;
            font-variant: small-caps;
            white-space: nowrap;
        }

        .form-subsection-header::before {
            display: none;
        }

        .import-export {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: 
                linear-gradient(135deg, rgba(139, 146, 168, 0.1) 0%, rgba(90, 98, 120, 0.08) 100%),
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)) 0px,
                    transparent 1px,
                    rgba(255, 255, 255, 0.02) 2px,
                    transparent 3px
                ),
                rgba(22, 34, 62, 0.5);
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(139, 146, 168, 0.25);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--orange-primary);
            font-family: 'Orbitron', sans-serif;
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 0.5rem;
        }

        .search-box {
            margin-bottom: 1rem;
        }

        .search-box input {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(82, 115, 163, 0.4);
            border-radius: 8px;
            color: var(--white);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
        }

        .search-box input:focus {
            outline: none;
            border-color: var(--blue-accent);
            box-shadow: 0 0 20px rgba(82, 115, 163, 0.3);
        }

        /* Session Info Inputs */
        .session-info-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 10px;
            color: var(--white);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9375rem;
            transition: all 0.3s ease;
        }

        .session-info-input:focus {
            outline: none;
            border-color: var(--purple-primary);
            background: rgba(22, 34, 62, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.1);
        }

        .session-info-input.hidden {
            display: none;
        }

        .session-info-display {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            
            cursor: pointer;
            padding: 0.5rem 0;
            letter-spacing: 0.5px;
        }

        .session-info-display:hover {
            filter: drop-shadow(0 0 3px rgba(255, 140, 56, 0.3));
        }

        .session-info-display.hidden {
            display: none;
        }

        .session-info-placeholder {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 0.5rem 0;
        }

        .session-info-placeholder:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        .session-info-placeholder.hidden {
            display: none;
        }

        .hh-header {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-bottom: 1rem;
        }
        .hh-title {
        font-size: 1.1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        font-variant: small-caps;
        color: rgba(255, 255, 255, 0.7);
        
        }
        .hh-label {
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: rgba(255, 255, 255, 0.7);
        
        }
        /* ===== PLAYER & POSITION SELECT ===== */
        .hh-player-select-row {
            margin-bottom: 1rem;
        }
        .hh-player-dropdown {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(22, 34, 62, 0.6);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 10px;
            color: var(--white);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9375rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .hh-player-dropdown:focus {
            outline: none;
            border-color: var(--purple-primary);
            background: rgba(22, 34, 62, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.1);
        }
        .hh-player-dropdown option {
            background: #16223e;
            color: var(--white);
        }
        .hh-player-dropdown.hidden {
            display: none;
        }
        
        .hh-selection-inputs {
            display: block;
        }
        
        .hh-selection-inputs.hidden {
            display: none;
        }
        
        .hh-selection-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 0;
            margin-bottom: 1rem;
            cursor: pointer;
        }
        
        .hh-selection-display.hidden {
            display: none;
        }
        
        .hh-selection-display:hover {
            opacity: 0.7;
        }
        
        .hh-player-display,
        .hh-position-display {
            font-family: 'Outfit', sans-serif;
            font-size: 0.72rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.3),
                0 -1px 1px rgba(0, 0, 0, 0.6),
                1px 0 0 rgba(255, 255, 255, 0.15),
                -1px 0 1px rgba(0, 0, 0, 0.4);
            
        }
        
        .hh-display-separator {
            font-family: 'Outfit', sans-serif;
            font-size: 0.6rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
            opacity: 0.5;
        }
        
        .hh-positions {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        
        .hh-positions.hidden {
            display: none;
        }
        
        .hh-pos-chip {
            padding: 0.4rem 0.75rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 2px rgba(0, 0, 0, 0.15);
        }
        
        .hh-pos-chip:hover {
            background: linear-gradient(135deg, rgba(22, 34, 62, 0.8) 0%, rgba(22, 34, 62, 0.8) 50%, rgba(22, 34, 62, 0.7) 100%);
            transform: translateY(-1px);
        }
        
        .hh-pos-chip:active,
        .hh-pos-chip.active {
            background: linear-gradient(135deg, rgba(22, 34, 62, 0.7) 0%, rgba(18, 28, 52, 0.9) 50%, rgba(255, 140, 56, 0.2) 100%);
            transform: translateY(0px);
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.2),
                inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .hh-pos-chip.taken-by-hero {
            opacity: 0.35;
            text-decoration: line-through;
            text-decoration-color: #8dc4f0;
            border-color: rgba(141, 196, 240, 0.25);
            pointer-events: none;
        }
        
        /* ===== QUICK OBSERVATIONS SEAT CHIPS ===== */
        .qo-seat-chip {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1.5px solid rgba(255, 140, 56, 0.15);
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .qo-seat-chip:active {
            transform: scale(0.95);
        }
        .qo-seat-chip.active {
            border-color: rgba(141, 196, 240, 0.5);
            color: #ffffff;
        }

        /* ===== HAND HISTORY TABLE ===== */
        .hh-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
        }
        
        .hh-table thead {
            border-bottom: 2px solid rgba(255, 140, 56, 0.4);
        }
        
        .hh-table th {
            font-family: 'Outfit', sans-serif;
            font-size: 0.72rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            padding: 0.5rem 0.25rem;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.3),
                0 -1px 1px rgba(0, 0, 0, 0.6);
        }
        
        .hh-th-street {
            width: 60px;
        }
        
        .hh-th-cards {
            width: 120px;
        }
        
        .hh-th-actions {
            width: auto;
        }
        
        .hh-table-row {
            border-bottom: 1px solid rgba(255, 140, 56, 0.15);
            transition: opacity 0.2s;
        }
        
        .hh-table-row.hh-street-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .hh-table-row:last-child {
            border-bottom: none;
        }
        
        .hh-td-street {
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 900;
            color: #e06a10;
            text-align: center;
            padding: 0.6rem 0.35rem;
            vertical-align: top;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            background: rgba(255, 140, 56, 0.04);
        }
        
        .hh-td-cards {
            padding: 0.5rem 0.5rem;
            vertical-align: top;
        }
        
        .hh-td-actions {
            padding: 0.5rem 0.5rem;
            vertical-align: top;
        }
        
        .hh-td-actions {
            display: flex;
            align-items: flex-start;
            gap: 0.3rem;
        }
        
        .hh-street-actions {
            display: flex;
            align-items: center;
            gap: 0;
            flex: 1;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            padding: 2px 0;
        }
        
        .hh-add-action {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            border-radius: 4px;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .hh-add-action:hover {
            background: linear-gradient(135deg, rgba(22, 34, 62, 0.8) 0%, rgba(22, 34, 62, 0.8) 50%, rgba(22, 34, 62, 0.7) 100%);
            transform: translateY(-1px);
        }
        
        .hh-add-action:active {
            transform: translateY(0px);
            box-shadow: 
                0 1px 2px rgba(0, 0, 0, 0.2),
                inset 0 1px 2px rgba(0, 0, 0, 0.15);
        }
        
        .hh-cc-input,
        .hh-pf-note {
            width: 100%;
            padding: 0.4rem 0.5rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 6px;
            color: #ffffff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .hh-cc-input:focus,
        .hh-pf-note:focus {
            outline: none;
            border-color: var(--purple-primary);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 140, 56, 0.1);
            color: #ffffff;
        }
        
        .hh-cc-input::placeholder,
        .hh-pf-note::placeholder {
            color: rgba(255, 255, 255, 0.65);
        }
        
        #pf-note-wrap,
        #cc-wrap-flop,
        #cc-wrap-turn,
        #cc-wrap-river {
            font-family: 'Outfit', sans-serif;
            font-size: 0.72rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .hh-street-label {
        width: 22px;
        flex-shrink: 0;
        font-family: 'Outfit', sans-serif;
        font-size: 0.7rem;
        font-weight: 800;
        color: rgba(255, 255, 255, 0.7);
        text-align: right;
        }
        .hh-street-actions {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0;
        flex: 1;
        padding: 2px 0;
        }
        
        .hh-two-column-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.75rem;
        width: 100%;
        padding: 0.25rem 0;
        }
        
        .hh-player-column {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        background: rgba(255, 140, 56, 0.02);
        padding: 0.5rem;
        border-radius: 4px;
        border: 1px solid rgba(255, 140, 56, 0.1);
        }
        
        .hh-player-column-header {
        font-family: 'Outfit', sans-serif;
        font-size: 0.72rem;
        font-weight: 800;
        color: #e06a10;
        text-align: center;
        padding: 0.3rem 0;
        background: rgba(255, 140, 56, 0.08);
        border-radius: 3px;
        margin-bottom: 0.15rem;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        }
        
        .hh-action-cell {
        display: flex;
        align-items: center;
        flex-shrink: 0;
        gap: 4px;
        min-height: 32px;
        }
        .hh-action-cell .hh-dash {
        color: rgba(255, 255, 255, 0.65);
        font-size: 0.6rem;
        padding: 0 0.15rem;
        user-select: none;
        }
        .hh-action-select {
        padding: 0.25rem 14px 0.25rem 0.3rem;
        background: rgba(255,255,255,0.35);
        border: 1.5px solid rgba(255, 140, 56, 0.2);
        border-radius: 4px;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 600;
        appearance: none;
        -webkit-appearance: none;
        cursor: pointer;
        min-width: 52px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 24 24' fill='none' stroke='%235a5e66' stroke-width='3'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 3px center;
        }
        .hh-action-select:focus { outline: none; border-color: #ff8c38; box-shadow: 0 0 0 2px rgba(147,51,234,0.15); }
        .hh-action-select.has-value {
        border-color: rgba(168,85,247,0.5);
        background-color: rgba(168,85,247,0.08);
        font-weight: 700;
        }
        .hh-action-select option { background: rgba(22, 34, 62, 0.8); color: rgba(255, 255, 255, 0.7); }
        .hh-action-select optgroup { 
            font-weight: 700; 
            color: rgba(255, 255, 255, 0.7);
            font-style: normal;
        }
        
        .hh-player-select {
        padding: 0.25rem 14px 0.25rem 0.3rem;
        background: rgba(255,255,255,0.35);
        border: 1.5px solid rgba(255, 140, 56, 0.2);
        border-radius: 4px;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 600;
        appearance: none;
        -webkit-appearance: none;
        cursor: pointer;
        min-width: 80px;
        margin-right: 4px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 24 24' fill='none' stroke='%235a5e66' stroke-width='3'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 3px center;
        }
        .hh-player-select:focus { outline: none; border-color: #ff8c38; box-shadow: 0 0 0 2px rgba(147,51,234,0.15); }
        .hh-player-select option { background: rgba(22, 34, 62, 0.8); color: rgba(255, 255, 255, 0.7); }
        
        .hh-player-label {
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-right: 4px;
        padding: 0.25rem 0.3rem;
        }
        
        .hh-action-display {
        font-family: 'Outfit', sans-serif;
        font-size: 0.73rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        padding: 0.35rem 0.5rem;
        cursor: pointer;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 140, 56, 0.15);
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: space-between;
        min-height: 32px;
        }
        
        .hh-action-display:hover {
        background: rgba(255, 140, 56, 0.1);
        border-color: rgba(255, 140, 56, 0.3);
        transform: translateY(-1px);
        }
        
        .hh-player-name {
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-right: 2px;
        }
        
        .hh-action-amt {
        width: 48px;
        padding: 0.25rem 0.25rem;
        background: rgba(255,255,255,0.35);
        border: 1.5px solid rgba(255, 140, 56, 0.2);
        border-radius: 4px;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 600;
        display: none;
        margin-left: 2px;
        }
        .hh-action-amt.visible { display: block; }
        .hh-action-amt:focus { outline: none; border-color: #ff8c38; box-shadow: 0 0 0 2px rgba(147,51,234,0.15); }
        .hh-action-note {
        width: 44px;
        padding: 0.25rem 0.2rem;
        background: none;
        border: none;
        border-bottom: 1px solid rgba(255, 140, 56, 0.2);
        border-radius: 0;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.58rem;
        font-weight: 600;
        font-style: italic;
        margin-left: 1px;
        }
        .hh-action-note:focus { outline: none; border-bottom-color: #ff8c38; }
        .hh-action-note::placeholder { color: rgba(255, 255, 255, 0.65); font-weight: 500; }
        .hh-at-note {
        font-family: 'Outfit', sans-serif;
        font-size: 0.58rem;
        font-weight: 600;
        font-style: italic;
        color: rgba(255, 255, 255, 0.7);
        }
        .hh-action-x {
        border: none;
        background: none;
        color: #ff6b6b;
        font-size: 0.55rem;
        cursor: pointer;
        opacity: 0;
        padding: 0 0.1rem;
        transition: opacity 0.15s;
        margin-left: 1px;
        }
        .hh-action-cell:hover .hh-action-x { opacity: 0.5; }
        .hh-action-x:hover { opacity: 1 !important; }
        .hh-add-action {
        width: 28px;
        height: 28px;
        min-width: 28px;
        border-radius: 50%;
        border: 2px solid #ff8c38;
        background: linear-gradient(135deg, rgba(168,85,247,0.1) 0%, rgba(147,51,234,0.1) 100%);
        color: #ff8c38;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
        box-shadow: 0 1px 3px rgba(168,85,247,0.2);
        }
        .hh-add-action:hover { 
            border-color: #ff8c38; 
            background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(168,85,247,0.4);
        }
        .hh-add-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        .hh-add-action:active {
            transform: scale(0.95);
        }
        /* Players count - borderless */
        .hh-players-count {
        width: 28px;
        min-width: 28px;
        flex-shrink: 0;
        padding: 0.2rem 0;
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 700;
        text-align: center;
        appearance: none;
        -webkit-appearance: none;
        cursor: pointer;
        }
        .hh-players-count:focus { outline: none; }
        .hh-players-count option { background: rgba(22, 34, 62, 0.8); color: rgba(255, 255, 255, 0.7); }
        /* Column header row */
        .hh-grid-header {
        display: flex;
        align-items: center;
        margin-bottom: 0.15rem;
        padding-bottom: 0.15rem;
        }
        .hh-grid-header-spacer {
        /* Label + add button width */
        width: 52px;
        flex-shrink: 0;
        }
        .hh-grid-header-actions {
        flex: 1;
        }
        .hh-grid-header-cc {
        width: 56px;
        min-width: 56px;
        flex-shrink: 0;
        text-align: center;
        font-family: 'Outfit', sans-serif;
        font-size: 0.6rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: rgba(255, 255, 255, 0.65);
        }
        .hh-grid-header-players {
        width: 28px;
        min-width: 28px;
        flex-shrink: 0;
        display: flex;
        justify-content: center;
        color: rgba(255, 255, 255, 0.65);
        }
        .hh-grid-header-players svg {
        opacity: 0.6;
        }
        /* Read-only mode */
        .hh-card-inner.readonly .hh-seat { pointer-events: none; }
        .hh-card-inner.readonly .hh-pos-chip { pointer-events: none; }
        .hh-card-inner.readonly .hh-add-action { display: none; }
        .hh-card-inner.readonly .hh-action-x { display: none; }
        .hh-card-inner.readonly .hh-outcome-chip { pointer-events: none; }
        .hh-card-inner.readonly .hh-result-input { display: none; }
        .hh-card-inner.readonly .hh-players-count { pointer-events: none; }
        /* Plain text action (replaces dropdown in readonly) */
        .hh-action-text {
        font-family: 'Outfit', sans-serif;
        font-size: 0.7rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.7);
        white-space: nowrap;
        }
        .hh-action-text .hh-at-amt {
        font-family: 'Outfit', sans-serif;
        color: #ff8c38;
        }
        /* Hand number indicator */
        .hh-hand-number {
        font-family: 'Outfit', sans-serif;
        font-size: 0.72rem;
        font-weight: 700;
        color: #ff8c38;
        margin-left: auto;
        }
        /* Readonly shows value text */
        .hh-shows-text {
        font-family: 'Outfit', sans-serif;
        font-size: 0.72rem;
        font-weight: 700;
        color: #ff8c38;
        }
        /* Community cards input */
        .hh-cc-input {
        width: 70px;
        min-width: 70px;
        flex-shrink: 0;
        padding: 0.35rem 0.4rem;
        background: rgba(0, 0, 0, 0.4);
        border: 1.5px solid rgba(255, 140, 56, 0.3);
        border-radius: 4px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 0.55rem;
        font-weight: 600;
        text-align: center;
        text-transform: uppercase;
        transition: all 0.15s;
        }
        .hh-cc-input:focus {
        outline: none;
        border-color: #ff8c38;
        background: rgba(0, 0, 0, 0.5);
        box-shadow: 0 0 0 2px rgba(255, 140, 56, 0.15);
        }
        .hh-cc-input::placeholder {
        color: rgba(255, 255, 255, 0.65);
        font-weight: 500;
        font-size: 0.5rem;
        text-transform: lowercase;
        }
        .hh-cc-text {
        width: 56px;
        min-width: 56px;
        flex-shrink: 0;
        text-align: center;
        font-family: 'Outfit', sans-serif;
        font-size: 0.65rem;
        font-weight: 700;
        color: #ff8c38;
        }
        .hh-card-inner.readonly .hh-cc-input { display: none; }

        /* ===== TAP-GRID CARD PICKER ===== */
        .cc-card-slots {
            display: flex;
            align-items: center;
            gap: 0;
            justify-content: center;
            margin: 0.5rem 0;
        }
        .cc-card-slot {
            width: 42px;
            height: 56px;
            border-radius: 5px;
            border: 1.5px solid rgba(255, 140, 56, 0.2);
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.3);
            margin: 0 2px;
            transition: all 0.15s;
            flex-direction: column;
            line-height: 1;
            gap: 1px;
        }
        .cc-card-slot.filled {
            border-color: rgba(255, 140, 56, 0.4);
            font-size: 0.8rem;
        }
        .cc-card-slot.filled.suit-h, .cc-card-slot.filled.suit-d { color: #ff8c38; }
        .cc-card-slot.filled.suit-s, .cc-card-slot.filled.suit-c { color: #e0e0e0; }
        .cc-card-slot.active {
            border-color: #ff8c38;
            box-shadow: 0 0 8px rgba(255, 140, 56, 0.4);
        }
        .cc-slot-sep {
            width: 8px;
            height: 32px;
            border-radius: 1px;
            margin: 0 3px;
            background: linear-gradient(180deg, transparent, rgba(255, 140, 56, 0.2), transparent);
        }
        .cc-slot-label {
            font-family: 'Outfit', sans-serif;
            font-size: 0.6rem;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            margin: 0 4px;
            white-space: nowrap;
        }
        @media (max-width: 420px) {
            .cc-card-slot {
                width: 40px;
                height: 52px;
                margin: 0 1px;
            }
            .cc-slot-sep {
                width: 4px;
                margin: 0 1px;
            }
            .cc-slot-label {
                font-size: 0.5rem;
                margin: 0 2px;
            }
        }
        @media (max-width: 360px) {
            .cc-card-slot {
                width: 38px;
                height: 50px;
                margin: 0;
                font-size: 0.8rem;
            }
            .cc-slot-sep {
                width: 3px;
                margin: 0;
            }
            .cc-slot-label {
                display: none;
            }
            .cc-card-slots {
                gap: 0;
            }
        }
        .cc-picker-panel {
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.95), rgba(14, 22, 44, 0.98));
            border: 1px solid rgba(255, 140, 56, 0.25);
            border-radius: 8px;
            padding: 0.6rem;
            margin-top: 0.5rem;
        }
        .cc-picker-label {
            font-family: 'Outfit', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.4rem;
        }
        .cc-rank-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 0.5rem;
        }
        .cc-rank-btn {
            flex: 1 1 0;
            min-width: 28px;
            padding: 6px 2px;
            border-radius: 4px;
            border: 1px solid rgba(255, 140, 56, 0.12);
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
        }
        .cc-rank-btn:active { transform: scale(0.93); }
        .cc-rank-btn.used { opacity: 0.2; pointer-events: none; }
        .cc-suit-row {
            display: flex;
            gap: 6px;
        }
        .cc-suit-btn {
            flex: 1;
            padding: 8px 2px;
            border-radius: 5px;
            border: 1.5px solid rgba(255, 140, 56, 0.12);
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            font-size: 1.3rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
        }
        .cc-suit-btn:active { transform: scale(0.93); }
        .cc-suit-btn.suit-s, .cc-suit-btn.suit-c { color: #e0e0e0; }
        .cc-suit-btn.suit-h, .cc-suit-btn.suit-d { color: #ff8c38; }
        .cc-suit-btn.used { opacity: 0.2; pointer-events: none; }

        /* ===== CARD ROLLER STYLES ===== */
        .cc-roller-panel {
            display: inline-flex;
            align-items: center;
            gap: 0;
            padding: 10px 14px;
            max-width: 100%;
            box-sizing: border-box;
            background:
                linear-gradient(90deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.9)) 0.5px, rgba(22, 34, 62, 0.75) 1px, rgba(22, 34, 62, 0.8) 1.5px, rgba(22, 34, 62, 0.7) 2px),
                linear-gradient(180deg, rgba(22, 34, 62, 0.7) 0%, rgba(22, 34, 62, 0.8) 20%, rgba(22, 34, 62, 0.65) 50%, rgba(22, 34, 62, 0.7) 80%, rgba(22, 34, 62, 0.75) 100%);
            border-radius: 10px;
            border: 2px solid rgba(255, 140, 56, 0.18);
            box-shadow:
                0 6px 16px rgba(0,0,0,0.4),
                0 2px 4px rgba(0,0,0,0.2),
                inset 0 2px 0 rgba(255,255,255,0.7),
                inset 0 -2px 0 rgba(0,0,0,0.3),
                inset 2px 0 0 rgba(255,255,255,0.3),
                inset -2px 0 0 rgba(0,0,0,0.2);
            position: relative;
            margin: 8px 0;
        }
        .cc-roller-panel::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, rgba(168,85,247,0.3) 0%, transparent 30%, transparent 70%, rgba(34,211,238,0.3) 100%);
            border-radius: 11px;
            z-index: -1;
            opacity: 0.5;
        }
        .cc-roller-pair {
            display: flex;
            align-items: center;
            border-radius: 8px;
            border: 1px solid rgba(255, 140, 56, 0.15);
            flex-shrink: 1;
            min-width: 0;
            box-shadow:
                inset 0 3px 8px rgba(0,0,0,0.4),
                inset 0 -2px 5px rgba(0,0,0,0.2),
                inset 3px 0 6px rgba(0,0,0,0.15),
                inset -3px 0 6px rgba(0,0,0,0.15),
                0 2px 0 rgba(255,255,255,0.6);
            background:
                radial-gradient(ellipse 120% 80% at 50% 50%, rgba(22, 34, 62, 0.75) 0%, rgba(255, 140, 56, 0.2) 60%, rgba(255, 140, 56, 0.18) 100%),
                linear-gradient(180deg, rgba(255, 140, 56, 0.2) 0%, rgba(22, 34, 62, 0.65) 50%, rgba(255, 140, 56, 0.2) 100%);
            padding: 4px 2px;
            overflow: hidden;
            position: relative;
        }
        .cc-roller-pair::after {
            content: '';
            position: absolute;
            inset: 2px;
            box-shadow: inset 0 0 10px rgba(168,85,247,0.1);
            border-radius: 6px;
            pointer-events: none;
        }
        .cc-roller-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 36px;
            min-width: 0;
            flex-shrink: 1;
            user-select: none;
            touch-action: none;
        }
        .cc-roller-arrow {
            cursor: pointer;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            transition: 0.15s;
        }
        .cc-roller-arrow.up {
            border-bottom: 7px solid #7a7e86;
            margin-bottom: 3px;
        }
        .cc-roller-arrow.up:hover { border-bottom-color: rgba(255, 255, 255, 0.7); }
        .cc-roller-arrow.down {
            border-top: 7px solid #7a7e86;
            margin-top: 3px;
        }
        .cc-roller-arrow.down:hover { border-top-color: rgba(255, 255, 255, 0.7); }
        .cc-roller-val {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 28px;
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.65);
            text-shadow: 0 1px 0 rgba(255,255,255,0.6), 0 -1px 1px rgba(0,0,0,0.3);
            line-height: 1;
        }
        .cc-roller-ridge {
            width: 2px;
            height: 28px;
            flex-shrink: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.35) 0%, rgba(255, 140, 56, 0.2) 30%, rgba(22, 34, 62, 0.65) 50%, rgba(255, 140, 56, 0.2) 70%, rgba(255, 255, 255, 0.35) 100%);
            box-shadow: -1px 0 1px rgba(0,0,0,0.25), 1px 0 1px rgba(255,255,255,0.3);
        }
        .cc-roller-sep {
            width: 3px;
            height: 40px;
            flex-shrink: 0;
            border-radius: 1px;
            margin: 0 4px;
            background: linear-gradient(180deg, rgba(255, 140, 56, 0.2) 0%, rgba(22, 34, 62, 0.7) 30%, rgba(22, 34, 62, 0.7) 50%, rgba(22, 34, 62, 0.7) 70%, rgba(255, 140, 56, 0.2) 100%);
            box-shadow: -1px 0 2px rgba(0,0,0,0.2), 1px 0 2px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        .cc-roller-label {
            font-family: 'Outfit', sans-serif;
            font-size: 0.55rem;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 1px 0 rgba(255,255,255,0.3), 0 -1px 1px rgba(0,0,0,0.5);
            margin-right: 6px;
        }
        .cc-board-labels {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            padding: 0 16px;
            gap: 0;
        }
        .cc-board-label-cell {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cc-board-label-line {
            flex: 1;
            height: 1.5px;
            background: linear-gradient(90deg, transparent 0%, rgba(90,94,102,0.5) 15%, rgba(90,94,102,0.5) 85%, transparent 100%);
        }
        .cc-board-label-text {
            font-family: 'Outfit', sans-serif;
            font-size: 0.55rem;
            font-weight: 700;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-variant: small-caps;
            color: rgba(255, 255, 255, 0.7);
            
            white-space: nowrap;
            padding: 0 2px;
        }
        .cc-board-label-sep {
            flex-shrink: 0;
        }
        #hh-community-board {
            margin: 8px 0;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        /* Responsive: shrink community card rollers on small screens */
        @media (max-width: 420px) {
            .cc-roller-panel {
                padding: 8px 6px;
            }
            .cc-roller-col {
                width: 24px;
            }
            .cc-roller-val {
                font-size: 0.85rem;
                height: 24px;
            }
            .cc-roller-ridge {
                height: 24px;
                width: 1.5px;
            }
            .cc-roller-sep {
                width: 2px;
                height: 34px;
                margin: 0 2px;
            }
            .cc-roller-pair {
                padding: 3px 1px;
            }
            .cc-roller-arrow {
                border-left-width: 5px;
                border-right-width: 5px;
            }
            .cc-roller-arrow.up {
                border-bottom-width: 6px;
                margin-bottom: 2px;
            }
            .cc-roller-arrow.down {
                border-top-width: 6px;
                margin-top: 2px;
            }
            .cc-board-labels {
                padding: 0 8px;
            }
        }
        @media (max-width: 360px) {
            .cc-roller-panel {
                padding: 5px 4px;
            }
            .cc-roller-col {
                width: 20px;
            }
            .cc-roller-val {
                font-size: 0.75rem;
                height: 20px;
            }
            .cc-roller-ridge {
                height: 20px;
                width: 1px;
            }
            .cc-roller-sep {
                width: 2px;
                height: 28px;
                margin: 0 1px;
            }
            .cc-roller-pair {
                padding: 2px 0px;
                border-width: 1.5px;
                border-radius: 6px;
            }
            .cc-roller-arrow {
                border-left-width: 4px;
                border-right-width: 4px;
            }
            .cc-roller-arrow.up {
                border-bottom-width: 5px;
                margin-bottom: 1px;
            }
            .cc-roller-arrow.down {
                border-top-width: 5px;
                margin-top: 1px;
            }
            .cc-board-labels {
                padding: 0 6px;
            }
        }
        @media (max-width: 320px) {
            .cc-roller-panel {
                padding: 4px 3px;
            }
            .cc-roller-col {
                width: 18px;
            }
            .cc-roller-val {
                font-size: 0.7rem;
                height: 18px;
            }
            .cc-roller-ridge {
                height: 18px;
            }
            .cc-roller-sep {
                height: 24px;
                margin: 0 1px;
            }
            .cc-roller-pair {
                padding: 2px 0;
                border-width: 1px;
                border-radius: 5px;
            }
            .cc-board-labels {
                padding: 0 4px;
            }
        }
        /* Preflop inline note */
        .hh-pf-note {
        width: 88px;
        min-width: 88px;
        flex-shrink: 0;
        padding: 0.2rem 0.25rem;
        background: none;
        border: none;
        border-bottom: 1px solid rgba(255, 140, 56, 0.2);
        border-radius: 0;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.62rem;
        font-weight: 600;
        font-style: italic;
        }
        .hh-pf-note:focus { outline: none; border-bottom-color: #ff8c38; }
        .hh-pf-note::placeholder { color: rgba(255, 255, 255, 0.65); font-weight: 500; }
        .hh-card-inner.readonly .hh-pf-note { display: none; }
        .hh-pf-note-text {
        min-width: 88px;
        flex-shrink: 0;
        font-family: 'Outfit', sans-serif;
        font-size: 0.62rem;
        font-weight: 600;
        font-style: italic;
        color: rgba(255, 255, 255, 0.7);
        }
        /* Players count plain text */
        .hh-pc-text {
        width: 28px;
        min-width: 28px;
        flex-shrink: 0;
        text-align: center;
        font-family: 'Outfit', sans-serif;
        font-size: 0.68rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.7);
        }
        /* ===== OUTCOME ===== */
        .hh-showdown-section {
        margin-bottom: 0.8rem;
        padding: 0.75rem;
        background: rgba(255, 140, 56, 0.05);
        border: 1px solid rgba(255, 140, 56, 0.2);
        border-radius: 6px;
        }
        
        .hh-showdown-players {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        }
        
        .hh-showdown-player {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        }
        
        .hh-showdown-player-name {
        font-family: 'Outfit', sans-serif;
        font-size: 0.75rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.7);
        min-width: 60px;
        }
        
        .hh-showdown-cards-input {
        flex: 1;
        padding: 0.4rem 0.5rem;
        background: rgba(0, 0, 0, 0.4);
        border: 1.5px solid rgba(255, 140, 56, 0.3);
        border-radius: 4px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        text-align: center;
        transition: all 0.15s;
        }
        
        .hh-showdown-cards-input:focus {
        outline: none;
        border-color: #ff8c38;
        background: rgba(0, 0, 0, 0.5);
        box-shadow: 0 0 0 2px rgba(255, 140, 56, 0.15);
        }
        
        .hh-showdown-cards-input::placeholder {
        color: rgba(255, 255, 255, 0.65);
        text-transform: none;
        font-size: 0.55rem;
        }
        
        /* ===== OUTCOME (1 player only) ===== */
        .hh-outcome-section {
        margin-bottom: 0.8rem;
        }
        
        .hh-outcome-input {
        width: 100%;
        padding: 0.45rem 0.5rem;
        background: rgba(255, 255, 255, 0.35);
        border: 1.5px solid rgba(255, 140, 56, 0.2);
        border-radius: 4px;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.75rem;
        font-weight: 600;
        text-align: center;
        }
        
        .hh-outcome-input:focus {
        outline: none;
        border-color: #ff8c38;
        background: rgba(255, 255, 255, 0.1);
        }
        
        .hh-outcome-input::placeholder {
        color: rgba(18, 28, 52, 0.85);
        font-weight: 500;
        }
        
        /* ===== NOTES ===== */
        .hh-notes-section { margin-bottom: 0.75rem; }
        .hh-notes-section .hh-label { margin-bottom: 0.3rem; }
        .hh-notes-textarea {
        width: 100%;
        padding: 0.4rem 0.5rem;
        background: rgba(255,255,255,0.35);
        border: 1px solid rgba(255, 140, 56, 0.12);
        border-radius: 6px;
        color: rgba(255, 255, 255, 0.7);
        font-family: 'Outfit', sans-serif;
        font-size: 0.78rem;
        font-weight: 500;
        resize: vertical;
        min-height: 2rem;
        }
        .hh-notes-textarea:focus { outline: none; border-color: #ff8c38; box-shadow: 0 0 0 3px rgba(147,51,234,0.15); }
        .hh-notes-textarea::placeholder { color: rgba(255, 255, 255, 0.65); }
        /* ===== NAV BUTTONS ===== */
        .hh-bottom {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        }
        
        .hh-save-next-btn {
        width: 100%;
        padding: 0.7rem 1rem;
        background: linear-gradient(135deg, #ff8c38 0%, #ff8c38 100%);
        border: none;
        border-radius: 6px;
        color: white;
        font-family: 'Outfit', sans-serif;
        font-size: 0.85rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 3px 8px rgba(255, 140, 56, 0.4);
        text-transform: uppercase;
        letter-spacing: 0.03em;
        }
        
        .hh-save-next-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 140, 56, 0.5);
        background: linear-gradient(135deg, #ffc068 0%, #ff8c38 100%);
        }
        
        .hh-save-next-btn:active {
        transform: translateY(0px);
        box-shadow: 0 2px 4px rgba(255, 140, 56, 0.4);
        }
        
        .hh-nav-group {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        }
        
        .hh-nav-btn {
        width: 48px;
        height: 48px;
        padding: 0;
        border-radius: 6px;
        background: linear-gradient(180deg, rgba(22, 34, 62, 0.8) 0%, rgba(22, 34, 62, 0.7) 40%, rgba(18, 28, 52, 0.85) 100%);
        border: 1px solid rgba(255, 140, 56, 0.18);
        border-bottom: 2px solid rgba(255, 140, 56, 0.15);
        box-shadow:
        0 1px 0 rgba(255,255,255,0.6),
        0 2px 1px rgba(0,0,0,0.12),
        0 3px 2px rgba(0,0,0,0.08),
        inset 0 1px 0 rgba(255,255,255,0.65);
        cursor: pointer;
        transition: all 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255, 255, 255, 0.7);
        }
        .hh-nav-btn svg {
        filter: drop-shadow(0 1px 1px rgba(255,255,255,0.5))
        drop-shadow(0 -1px 1px rgba(0,0,0,0.3));
        opacity: 0.7;
        }
        .hh-nav-btn:hover {
        transform: translateY(-1px);
        background: linear-gradient(180deg, rgba(22, 34, 62, 0.75) 0%, rgba(22, 34, 62, 0.65) 40%, rgba(22, 34, 62, 0.6) 100%);
        box-shadow:
        0 1px 0 rgba(255,255,255,0.6),
        0 3px 2px rgba(0,0,0,0.15),
        0 5px 4px rgba(0,0,0,0.08),
        inset 0 1px 0 rgba(255,255,255,0.7);
        }
        .hh-nav-btn:active {
        transform: translateY(1px);
        background: linear-gradient(180deg, rgba(22, 34, 62, 0.7) 0%, rgba(18, 28, 52, 0.8) 40%, rgba(18, 28, 52, 0.75) 100%);
        border-bottom: 1px solid rgba(255, 140, 56, 0.15);
        box-shadow:
        0 0 0 rgba(0,0,0,0),
        inset 0 1px 3px rgba(0,0,0,0.15),
        inset 0 0 1px rgba(0,0,0,0.1);
        }

        /* Responsive: Hand navigation row */
        @media (max-width: 420px) {
            .hh-nav-row {
                gap: 5px !important;
            }
            .hh-nav-row .hh-new-hand-btn {
                flex: 1 1 0 !important;
                min-width: 0 !important;
                padding: 0.5rem 0.2rem !important;
                overflow: hidden;
            }
            .hh-nav-row .hh-new-hand-btn span {
                font-size: 0.7rem !important;
                white-space: nowrap;
            }
            .hh-nav-row .hh-nav-btn {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                padding: 0.4rem !important;
                flex-shrink: 0;
            }
        }
        @media (max-width: 360px) {
            .hh-nav-row .hh-new-hand-btn span {
                font-size: 0.65rem !important;
            }
            .hh-nav-row .hh-nav-btn {
                width: 32px !important;
                height: 32px !important;
                min-width: 32px !important;
                padding: 0.3rem !important;
            }
        }
        .hh-nav-counter {
        font-family: 'Outfit', sans-serif;
        font-size: 0.72rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.7);
        min-width: 44px;
        user-select: none;
        }
        .hh-nav-counter .hh-nc-num {
        color: #ff8c38;
        }
        /* ===== SAVED ===== */
        /* (saved hands rendered in-card) */

        /* ===== LIVE SESSION STYLES ===== */

        .session-timer-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            margin-bottom: 1.5rem;
            background: 
                linear-gradient(180deg, rgba(22, 34, 62, 0.9), rgba(18, 28, 52, 0.95)) 0px,
                    rgba(18, 28, 52, 0.85) 0.5px,
                    rgba(22, 34, 62, 0.7) 1px,
                    rgba(18, 28, 52, 0.85) 1.5px,
                    rgba(255, 140, 56, 0.2) 2px
                ),
                linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, rgba(18, 28, 52, 0.85) 50%, rgba(255, 255, 255, 0.4) 100%);
            border-radius: 12px;
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .session-timer-display {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .session-timer-clock {
            font-family: 'Outfit', monospace;
            font-size: 2.2rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 2px;
        }

        .session-timer-clock.active {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            -webkit-background-clip: text;
        }

        .session-timer-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .session-timer-controls {
            display: flex;
            gap: 0.75rem;
        }

        .btn-session-start, .btn-session-stop {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -2px 3px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-session-start svg { color: #22c55e; }
        .btn-session-stop svg { color: #ef4444; }

        .btn-session-start:hover, .btn-session-stop:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -2px 3px rgba(0, 0, 0, 0.2);
        }

        .btn-session-start:active, .btn-session-stop:active {
            transform: translateY(0);
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Blind Tracker */
        .blind-tracker {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .blind-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }

        .btn-blind-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            padding: 0.2rem;
            cursor: pointer;
            color: rgba(255, 140, 56, 0.8);
            transition: all 0.15s ease;
            line-height: 1;
            flex-shrink: 0;
        }

        .btn-blind-nav:hover {
            color: #ff8c38;
        }

        .btn-blind-nav:active {
            transform: scale(0.9);
        }

        .blind-level-info {
            text-align: center;
            min-width: 160px;
        }

        .blind-level-number {
            font-family: 'Outfit', sans-serif;
            font-size: 0.65rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 0.35rem;
        }

        .blind-level-values {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: filter 0.2s;
        }

        .blind-level-values:hover {
            filter: drop-shadow(0 0 3px rgba(255, 140, 56, 0.4));
        }

        .blind-level-edit-row {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            justify-content: flex-start;
        }

        .blind-level-edit-row.hidden {
            display: none;
        }

        .blind-edit-input {
            width: 42px;
            padding: 0.25rem 0.3rem;
            background: rgba(22, 34, 62, 0.8);
            border: 1.5px solid rgba(255, 140, 56, 0.3);
            border-radius: 4px;
            color: #ffffff;
            font-family: 'Outfit', sans-serif;
            font-size: 0.78rem;
            font-weight: 600;
            text-align: center;
        }

        .blind-edit-input:focus {
            outline: none;
            border-color: #ff8c38;
            box-shadow: 0 0 0 2px rgba(255, 140, 56, 0.15);
        }

        .blind-edit-slash {
            font-family: 'Outfit', sans-serif;
            font-size: 0.78rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
        }

        .blind-level-ante {
            display: none; /* Now included in blind-level-values */
        }
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.2rem;
        }

        .blind-timer-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .blind-timer-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 
        }

        .blind-interval-group {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: opacity 0.3s ease;
        }

        .blind-interval-input {
            width: 52px;
            padding: 0.35rem 0.5rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 140, 56, 0.3);
            border-radius: 6px;
            color: var(--white);
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            text-align: center;
        }

        .blind-interval-input:focus {
            outline: none;
            border-color: var(--purple-primary);
        }

        .blind-interval-unit {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 
        }

        .blind-countdown {
            font-family: 'Outfit', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            min-width: 50px;
            text-align: center;
        }

        /* ===== HAND TRACKER ADDITIONS ===== */
        .hh-setup-card {
            margin-bottom: 1rem;
        }
        
        .hh-setup-card .form-group.slider-layout {
            margin-bottom: 0.75rem;
        }
        
        @media (max-width: 480px) {
            .hh-setup-card .form-group.slider-layout {
                flex-direction: row;
                align-items: center;
                gap: 0.6rem;
                margin-bottom: 0.5rem;
            }
            .hh-setup-card .form-group.slider-layout > label {
                min-width: 70px;
                padding-top: 0;
                font-size: 0.75rem;
            }
        }
        
        .hh-select {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.875rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 2px rgba(0, 0, 0, 0.15);
            appearance: auto;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
        }
        
        .hh-select option {
            background: white;
            color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem;
        }
        
        .hh-select:focus {
            outline: none;
            border-color: var(--purple-primary);
        }
        
        .hh-pos-chips {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .hh-position-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .hh-toggle-btn {
            padding: 0.75rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03),
                inset 0 -1px 2px rgba(0, 0, 0, 0.15);
        }
        
        .hh-toggle-btn:active,
        .hh-toggle-btn.active {
            background: linear-gradient(135deg, var(--purple-primary) 0%, #ff8c38 100%);
            border-color: #e06a10;
            color: white;
            transform: translateY(0px);
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.2),
                inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .hh-street-card {
            background: rgba(16, 24, 48, 0.3);
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255, 140, 56, 0.2);
        }
        
        .hh-street-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hh-actor-name {
            font-size: 1.1rem;
            font-weight: 800;
            margin-left: 0.5rem;
        }
        
        .hh-actor-name.hero {
            color: #8dc4f0;
        }
        
        .hh-actor-name.villain {
            color: #ffa726;
        }
        
        @keyframes hh-rapid-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }
        
        .hh-actor-name.active {
            animation: hh-rapid-blink 0.15s ease-in-out 3;
        }
        
        .hh-skip-street {
            padding: 0.5rem 1rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            font-size: 1.125rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
        }
        
        .hh-skip-street:active {
            transform: scale(0.95);
        }
        
        .hh-cards-input {
            width: 100%;
            padding: 0.625rem;
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            font-family: 'Outfit', sans-serif;
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.75rem;
        }
        
        .hh-cards-input:focus {
            outline: none;
            border-color: var(--purple-primary);
        }
        
        .hh-cards-input::placeholder {
            color: rgba(255, 255, 255, 0.65);
        }
        
        .hh-action-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            margin-bottom: 0.75rem;
        }
        
        .hh-action-btn {
            padding: 0.5rem 0.4rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 5px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            transition: all 0.1s;
            flex: 1 1 0;
            min-width: 0;
            text-align: center;
            white-space: nowrap;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
        }
        
        .hh-action-btn:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, rgba(22, 34, 62, 0.7) 0%, rgba(18, 28, 52, 0.9) 50%, rgba(255, 140, 56, 0.2) 100%);
        }
        
        .hh-amount-row {
            display: none;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .hh-amount-row.visible {
            display: flex;
        }
        
        .hh-amount-input {
            flex: 2;
            padding: 0.625rem;
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            font-family: 'Outfit', sans-serif;
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
        }
        
        .hh-amount-input:focus {
            outline: none;
            border-color: var(--purple-primary);
        }
        
        .hh-amount-input::placeholder {
            color: rgba(255, 255, 255, 0.65);
        }
        
        .hh-next-btn {
            flex: 0 0 60px;
            padding: 0.625rem;
            background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));
            border: 1px solid rgba(255, 140, 56, 0.12);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 1.125rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
        }
        .hh-amount-row.visible .hh-next-btn {
            background: linear-gradient(135deg, #ffc068 0%, #ffa726 100%);
            border-color: #e06a10;
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(255, 140, 56, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .hh-next-btn:active {
            transform: scale(0.95);
        }
        
        .hh-action-history {
            margin-top: 0.75rem;
        }
        
        .hh-action-item {
            padding: 0.5rem 0;
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .hh-action-item.hero {
            color: var(--purple-primary);
        }
        
        .hh-action-item.villain {
            color: var(--orange-accent);
        }
        
        .hh-hand-summary {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .hh-summary-street {
            margin-bottom: 0.75rem;
        }
        
        .hh-summary-street:last-child {
            margin-bottom: 0;
        }
        
        .hh-summary-street-name {
            font-size: 0.85rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 0.25rem;
        }
        
        .hh-summary-action {
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.125rem 0;
        }
        
        .hh-summary-action.hero {
            color: var(--purple-primary);
        }
        
        .hh-summary-action.villain {
            color: var(--orange-accent);
        }
        }
        /* ======================================
           PWA NATIVE-FEEL ENHANCEMENTS
           ====================================== */

        /* Safe area padding for notch/home indicator */
        body {
            padding-top: max(1rem, env(safe-area-inset-top));
            padding-bottom: max(1rem, env(safe-area-inset-bottom));
            padding-left: max(1rem, env(safe-area-inset-left));
            padding-right: max(1rem, env(safe-area-inset-right));
        }

        /* Prevent text selection on all interactive/UI elements */
        .dashboard-btn,
        .tab,
        .section-title,
        .exit-btn,
        .desc-chip,
        .slider-value-label,
        .toggle-container,
        .notecard-tab,
        button,
        label,
        .brief-section-title,
        .splash-metal-sheet,
        .drum-item,
        nav,
        header {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow selection on actual content areas */
        input, textarea, .brief-section p, #brief-content, #json-display {
            -webkit-user-select: text;
            user-select: text;
        }

        /* Smooth screen transitions */
        .tab-content {
            opacity: 0;
            transform: translateY(12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            pointer-events: none;
            will-change: opacity, transform;
            padding-top: 0.5rem;
        }

        .tab-content.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Splash screen transition */
        #splash-screen {
            transition: opacity 0.35s ease;
        }

        #splash-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #main-container {
            transition: opacity 0.3s ease;
        }

        #main-container.fade-in {
            opacity: 1;
        }

        /* Tap feedback — subtle scale + highlight on all buttons */
        .dashboard-btn,
        .exit-btn,
        .desc-chip,
        .notecard-tab,
        button:not(input) {
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .dashboard-btn:active {
            transform: scale(0.96) !important;
            transition-duration: 0.06s;
        }

        .exit-btn:active {
            transform: translateX(-50%) scale(0.93) !important;
            transition-duration: 0.06s;
        }

        /* Faster touch response on all tappable elements */
        a, button, input, select, textarea, .dashboard-btn, .tab, .desc-chip, .drum-item {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Smooth keyboard appearance */
        .container {
            transition: padding-bottom 0.3s ease;
        }

        /* Input focus ring — native iOS style */
        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 140, 56, 0.25);
            transition: box-shadow 0.15s ease;
        }

        /* Momentum scrolling for all scrollable containers */
        .tab-content,
        .archetype-list,
        .container {
            -webkit-overflow-scrolling: touch;
        }

        /* Smoother slider thumb for touch */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            cursor: grab;
        }

        input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
            transform: scale(1.2);
        }

        /* Stand-alone mode: extra bottom padding for home indicator */
        @media all and (display-mode: standalone) {
            body {
                padding-bottom: max(1.5rem, env(safe-area-inset-bottom));
            }

            .exit-btn {
                bottom: max(2rem, calc(env(safe-area-inset-bottom) + 0.5rem));
            }
        }

        /* ======================================
           BOTTOM NAV BAR
           ====================================== */
        #bottom-nav {
            display: none; /* hidden until logged in */
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: calc(56px + env(safe-area-inset-bottom, 0px));
            padding-bottom: env(safe-area-inset-bottom, 0px);
            background: linear-gradient(180deg, rgba(14, 20, 38, 0.97) 0%, rgba(10, 15, 28, 0.99) 100%);
            border-top: 1px solid rgba(255, 140, 56, 0.18);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            box-shadow: 0 -4px 24px rgba(0,0,0,0.45);
            display: none;
            flex-direction: row;
            align-items: stretch;
            justify-content: space-around;
        }
        #bottom-nav.visible {
            display: flex;
            transform: translateY(0);
            opacity: 1;
        }
        #bottom-nav.nav-hidden {
            transform: translateY(110%);
            opacity: 0;
            pointer-events: none;
        }
        #bottom-nav {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }
        .bnav-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            cursor: pointer;
            border: none;
            background: transparent;
            padding: 0 2px;
            padding-bottom: 0;
            height: 56px;
            color: rgba(255,255,255,0.38);
            transition: color 0.15s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            position: relative;
            font-family: 'Outfit', sans-serif;
        }
        .bnav-btn svg {
            transition: transform 0.15s ease;
        }
        .bnav-btn:active svg {
            transform: scale(0.88);
        }
        .bnav-btn .bnav-label {
            font-size: 9.5px;
            font-weight: 700;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            transition: color 0.15s ease;
            white-space: nowrap;
        }
        .bnav-btn.active {
            color: #ff8c38;
        }
        .bnav-btn.active .bnav-label {
            color: #ff8c38;
        }
        /* active pill indicator */
        .bnav-btn.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20%;
            right: 20%;
            height: 2px;
            background: linear-gradient(90deg, #ff8c38, #ffb870);
            border-radius: 0 0 2px 2px;
        }
        /* Make room for the fixed nav bar */
        .container {
            padding-bottom: calc(56px + env(safe-area-inset-bottom, 0px) + 1rem) !important;
        }

        /* Extra bottom breathing room in all tabs so buttons scroll clear of the nav bar */
        .tab-content .section:last-child {
            padding-bottom: calc(56px + env(safe-area-inset-bottom, 0px) + 2rem) !important;
        }

        /* ======================================
           QO DRUM PICKER (replaces dropdown)
           ====================================== */
        #qo-drum-wrapper {
            margin-bottom: 0.75rem;
        }
        #qo-drum-wrapper .combo-lock-frame {
            margin-bottom: 0;
        }
        #qo-drum-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 0.5rem;
        }
        #arch-add-btn,
        #players-add-player-btn,
        #qo-add-player-btn {
            padding: 0.35rem 0.9rem;
            background: linear-gradient(145deg, rgba(22,34,62,0.85), rgba(18,28,52,0.95));
            border: 1px solid rgba(255,140,56,0.25);
            border-radius: 20px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255,140,56,0.8);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen">
        <div class="splash-metal-sheet">
            <div class="splash-logo">NitWiz</div>
            <div class="splash-subtitle">LIVE MTT TRAINER</div>
            <div class="splash-card-container">
                <div class="splash-card">
                    <div class="card-corner top-left">
                        <div class="card-rank">N</div>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="15" viewBox="0 0 1588 1750">
  <path d="M 1170,188 L 967,188 L 959,194 L 957,200 L 956,420 L 843,420 L 841,418 L 840,222 L 834,200 L 826,182 L 817,168 L 798,147 L 782,135 L 761,124 L 731,116 L 694,116 L 659,126 L 629,145 L 613,161 L 601,178 L 587,211 L 582,250 L 570,245 L 554,242 L 526,242 L 496,249 L 467,265 L 444,289 L 432,314 L 427,342 L 392,334 L 357,335 L 318,347 L 287,368 L 264,396 L 254,417 L 249,434 L 247,470 L 251,490 L 261,513 L 260,516 L 245,516 L 231,519 L 202,533 L 180,554 L 166,579 L 160,603 L 161,636 L 168,662 L 183,690 L 160,699 L 137,718 L 120,746 L 114,775 L 115,793 L 120,813 L 133,836 L 154,856 L 122,876 L 107,891 L 95,908 L 87,926 L 81,950 L 80,984 L 85,1010 L 91,1026 L 104,1048 L 114,1060 L 141,1082 L 162,1092 L 189,1100 L 175,1119 L 165,1147 L 164,1177 L 171,1203 L 185,1226 L 199,1240 L 212,1249 L 241,1260 L 272,1262 L 266,1288 L 268,1315 L 272,1328 L 282,1347 L 299,1366 L 321,1380 L 340,1386 L 364,1388 L 380,1385 L 385,1387 L 383,1416 L 389,1441 L 407,1474 L 423,1491 L 454,1511 L 480,1520 L 498,1523 L 525,1524 L 544,1522 L 562,1518 L 587,1508 L 589,1527 L 595,1550 L 612,1582 L 636,1607 L 669,1626 L 703,1634 L 728,1634 L 756,1628 L 780,1617 L 797,1605 L 813,1589 L 824,1574 L 832,1559 L 840,1535 L 841,1331 L 843,1329 L 972,1329 L 974,1331 L 974,1562 L 1170,1562 L 1170,1534 L 1001,1534 L 1001,1312 L 995,1304 L 990,1302 L 841,1301 L 842,1165 L 1359,1165 L 1359,1137 L 841,1136 L 841,888 L 843,888 L 1170,888 L 1170,861 L 843,861 L 841,861 L 843,612 L 1359,613 L 1359,584 L 842,584 L 841,449 L 843,447 L 974,447 L 979,445 L 984,439 L 984,217 L 986,215 L 1170,216 Z M 707,142 L 733,144 L 747,148 L 762,155 L 779,167 L 802,195 L 810,214 L 814,233 L 813,1102 L 793,1098 L 753,1085 L 725,1072 L 719,1067 L 734,1047 L 747,1021 L 755,995 L 759,967 L 759,938 L 753,899 L 739,855 L 730,840 L 722,838 L 714,841 L 710,846 L 709,855 L 723,892 L 729,918 L 732,947 L 731,973 L 721,1012 L 711,1032 L 698,1050 L 694,1052 L 661,1022 L 644,999 L 626,965 L 622,963 L 611,964 L 604,973 L 604,979 L 614,1002 L 635,1034 L 654,1055 L 679,1076 L 704,1092 L 734,1107 L 773,1121 L 813,1130 L 813,1530 L 801,1559 L 778,1585 L 753,1600 L 723,1607 L 699,1606 L 683,1602 L 662,1592 L 649,1582 L 635,1567 L 622,1544 L 616,1522 L 615,1499 L 623,1465 L 634,1446 L 648,1430 L 660,1420 L 685,1405 L 714,1394 L 752,1385 L 758,1376 L 756,1366 L 748,1360 L 720,1364 L 683,1376 L 652,1392 L 631,1408 L 610,1432 L 598,1454 L 592,1474 L 563,1489 L 533,1496 L 501,1496 L 485,1493 L 456,1481 L 434,1463 L 417,1437 L 411,1419 L 411,1390 L 417,1361 L 428,1339 L 452,1313 L 484,1294 L 486,1290 L 484,1278 L 477,1273 L 468,1273 L 438,1289 L 413,1313 L 402,1329 L 392,1351 L 384,1356 L 370,1360 L 349,1360 L 330,1354 L 319,1347 L 303,1329 L 294,1306 L 294,1284 L 297,1273 L 315,1244 L 315,1237 L 312,1231 L 305,1225 L 295,1225 L 276,1233 L 251,1234 L 225,1225 L 205,1207 L 198,1196 L 192,1179 L 191,1157 L 196,1138 L 205,1123 L 222,1105 L 238,1094 L 268,1086 L 291,1088 L 311,1099 L 324,1113 L 336,1115 L 345,1106 L 346,1101 L 343,1093 L 321,1072 L 291,1060 L 257,1060 L 214,1073 L 192,1072 L 170,1066 L 147,1053 L 125,1030 L 114,1010 L 107,981 L 107,963 L 111,941 L 120,920 L 127,910 L 152,888 L 177,876 L 198,871 L 206,865 L 208,860 L 207,852 L 202,846 L 179,839 L 164,829 L 154,818 L 146,804 L 142,790 L 142,769 L 146,755 L 157,737 L 173,723 L 198,714 L 215,714 L 233,723 L 258,729 L 295,728 L 343,713 L 361,704 L 367,696 L 365,684 L 361,680 L 353,678 L 320,693 L 291,701 L 262,702 L 247,699 L 231,692 L 213,679 L 198,661 L 190,642 L 187,624 L 188,600 L 196,579 L 212,560 L 223,552 L 243,544 L 269,543 L 290,550 L 298,550 L 308,540 L 308,530 L 286,503 L 275,473 L 275,443 L 281,423 L 290,406 L 316,380 L 331,371 L 347,365 L 369,361 L 389,361 L 416,367 L 442,383 L 454,397 L 464,416 L 471,438 L 473,480 L 480,488 L 490,489 L 494,487 L 499,481 L 501,468 L 500,446 L 494,418 L 480,387 L 456,355 L 456,330 L 463,310 L 482,288 L 504,275 L 528,269 L 557,270 L 573,275 L 588,285 L 608,319 L 635,343 L 649,350 L 672,356 L 703,354 L 708,349 L 710,343 L 709,336 L 704,330 L 699,328 L 677,329 L 663,326 L 644,316 L 628,300 L 616,280 L 611,260 L 610,239 L 615,212 L 632,181 L 648,165 L 664,154 L 684,146 Z M 522,1129 L 519,1140 L 526,1150 L 564,1155 L 600,1166 L 626,1180 L 638,1189 L 643,1197 L 631,1220 L 607,1245 L 585,1258 L 554,1267 L 549,1272 L 547,1281 L 552,1290 L 558,1293 L 569,1292 L 594,1284 L 610,1276 L 626,1265 L 643,1249 L 664,1219 L 669,1225 L 681,1251 L 690,1292 L 698,1299 L 709,1298 L 714,1293 L 716,1282 L 713,1264 L 701,1227 L 680,1193 L 655,1168 L 622,1147 L 586,1133 L 536,1124 L 528,1125 Z M 530,949 L 518,948 L 511,954 L 504,989 L 496,1003 L 486,1014 L 465,1027 L 445,1033 L 432,1034 L 425,1039 L 423,1052 L 429,1059 L 441,1061 L 469,1055 L 490,1045 L 513,1026 L 526,1007 L 534,984 L 536,956 Z M 490,857 L 486,850 L 457,837 L 425,829 L 389,827 L 353,833 L 317,847 L 279,872 L 239,913 L 235,920 L 235,929 L 244,938 L 256,936 L 270,918 L 306,885 L 339,866 L 363,859 L 379,887 L 386,918 L 385,949 L 376,978 L 376,986 L 381,993 L 394,995 L 399,992 L 405,980 L 413,946 L 411,899 L 404,876 L 394,856 L 396,854 L 414,855 L 435,859 L 473,874 L 480,874 L 486,871 L 490,865 Z M 623,683 L 620,695 L 628,705 L 661,707 L 692,717 L 711,730 L 724,743 L 744,775 L 756,777 L 764,771 L 766,765 L 765,758 L 752,735 L 734,714 L 715,699 L 701,691 L 671,681 L 636,678 L 629,679 Z M 457,614 L 451,622 L 451,629 L 456,637 L 488,646 L 509,656 L 527,668 L 546,687 L 560,711 L 566,731 L 568,747 L 566,781 L 572,789 L 577,791 L 589,788 L 593,782 L 595,767 L 594,732 L 584,697 L 569,672 L 544,647 L 519,631 L 476,614 L 467,612 Z M 618,468 L 616,477 L 622,487 L 657,492 L 678,498 L 703,510 L 721,523 L 722,527 L 711,546 L 691,566 L 667,579 L 650,583 L 642,589 L 640,598 L 645,607 L 651,610 L 662,609 L 697,595 L 715,582 L 728,569 L 742,549 L 754,571 L 763,609 L 771,615 L 778,615 L 786,610 L 788,595 L 776,552 L 757,521 L 736,500 L 704,480 L 671,468 L 639,462 L 626,462 Z" fill="#FF8C38" fill-rule="evenodd"/>
  <path d="M 1223,292 L 1231,265 L 1231,238 L 1226,240 L 1219,253 L 1213,259 L 1203,264 L 1184,262 L 1170,250 L 1165,239 L 1165,217 L 1169,205 L 1178,190 L 1216,143 L 1236,112 L 1256,143 L 1294,190 L 1303,205 L 1307,217 L 1307,239 L 1302,250 L 1288,262 L 1269,264 L 1259,259 L 1252,253 L 1245,240 L 1240,238 L 1240,265 L 1248,292 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1440,688 L 1439,688 L 1369,604 L 1356,582 L 1351,564 L 1353,538 L 1364,522 L 1374,514 L 1387,508 L 1403,508 L 1414,512 L 1428,524 L 1435,536 L 1440,552 L 1445,536 L 1452,524 L 1466,512 L 1477,508 L 1493,508 L 1506,514 L 1516,522 L 1527,538 L 1529,564 L 1524,582 L 1511,604 L 1441,688 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1420,1061 L 1491,1151 L 1420,1241 L 1351,1151 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1236,1638 L 1244,1616 L 1245,1582 L 1237,1598 L 1227,1608 L 1208,1615 L 1194,1614 L 1183,1609 L 1172,1599 L 1165,1584 L 1166,1563 L 1170,1554 L 1179,1545 L 1189,1539 L 1202,1536 L 1229,1538 L 1218,1526 L 1211,1513 L 1208,1494 L 1210,1485 L 1220,1469 L 1229,1462 L 1240,1458 L 1248,1458 L 1255,1458 L 1266,1462 L 1275,1469 L 1285,1485 L 1287,1494 L 1284,1513 L 1277,1526 L 1266,1538 L 1293,1536 L 1306,1539 L 1316,1545 L 1325,1554 L 1329,1563 L 1330,1584 L 1323,1599 L 1312,1609 L 1301,1614 L 1287,1615 L 1268,1608 L 1258,1598 L 1251,1582 L 1252,1616 L 1259,1638 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>

  <!-- Dollar circle at connector 3 -->
  <circle cx="1255" cy="875" r="90" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  

  <path d="M 1246,853 C 1248,845 1236,840 1226,840 C 1214,840 1206,847 1206,855 C 1206,865 1218,871 1228,875 C 1238,879 1250,885 1250,895 C 1250,903 1242,910 1230,910 C 1220,910 1208,905 1210,897" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1228,823 L 1228,927" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1300,853 C 1302,845 1290,840 1280,840 C 1268,840 1260,847 1260,855 C 1260,865 1272,871 1282,875 C 1292,879 1304,885 1304,895 C 1304,903 1296,910 1284,910 C 1274,910 1262,905 1264,897" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1282,823 L 1282,927" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
</svg>
                    </div>
                    <div class="card-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="65" height="72" viewBox="0 0 1588 1750">
  <path d="M 1170,188 L 967,188 L 959,194 L 957,200 L 956,420 L 843,420 L 841,418 L 840,222 L 834,200 L 826,182 L 817,168 L 798,147 L 782,135 L 761,124 L 731,116 L 694,116 L 659,126 L 629,145 L 613,161 L 601,178 L 587,211 L 582,250 L 570,245 L 554,242 L 526,242 L 496,249 L 467,265 L 444,289 L 432,314 L 427,342 L 392,334 L 357,335 L 318,347 L 287,368 L 264,396 L 254,417 L 249,434 L 247,470 L 251,490 L 261,513 L 260,516 L 245,516 L 231,519 L 202,533 L 180,554 L 166,579 L 160,603 L 161,636 L 168,662 L 183,690 L 160,699 L 137,718 L 120,746 L 114,775 L 115,793 L 120,813 L 133,836 L 154,856 L 122,876 L 107,891 L 95,908 L 87,926 L 81,950 L 80,984 L 85,1010 L 91,1026 L 104,1048 L 114,1060 L 141,1082 L 162,1092 L 189,1100 L 175,1119 L 165,1147 L 164,1177 L 171,1203 L 185,1226 L 199,1240 L 212,1249 L 241,1260 L 272,1262 L 266,1288 L 268,1315 L 272,1328 L 282,1347 L 299,1366 L 321,1380 L 340,1386 L 364,1388 L 380,1385 L 385,1387 L 383,1416 L 389,1441 L 407,1474 L 423,1491 L 454,1511 L 480,1520 L 498,1523 L 525,1524 L 544,1522 L 562,1518 L 587,1508 L 589,1527 L 595,1550 L 612,1582 L 636,1607 L 669,1626 L 703,1634 L 728,1634 L 756,1628 L 780,1617 L 797,1605 L 813,1589 L 824,1574 L 832,1559 L 840,1535 L 841,1331 L 843,1329 L 972,1329 L 974,1331 L 974,1562 L 1170,1562 L 1170,1534 L 1001,1534 L 1001,1312 L 995,1304 L 990,1302 L 841,1301 L 842,1165 L 1359,1165 L 1359,1137 L 841,1136 L 841,888 L 843,888 L 1170,888 L 1170,861 L 843,861 L 841,861 L 843,612 L 1359,613 L 1359,584 L 842,584 L 841,449 L 843,447 L 974,447 L 979,445 L 984,439 L 984,217 L 986,215 L 1170,216 Z M 707,142 L 733,144 L 747,148 L 762,155 L 779,167 L 802,195 L 810,214 L 814,233 L 813,1102 L 793,1098 L 753,1085 L 725,1072 L 719,1067 L 734,1047 L 747,1021 L 755,995 L 759,967 L 759,938 L 753,899 L 739,855 L 730,840 L 722,838 L 714,841 L 710,846 L 709,855 L 723,892 L 729,918 L 732,947 L 731,973 L 721,1012 L 711,1032 L 698,1050 L 694,1052 L 661,1022 L 644,999 L 626,965 L 622,963 L 611,964 L 604,973 L 604,979 L 614,1002 L 635,1034 L 654,1055 L 679,1076 L 704,1092 L 734,1107 L 773,1121 L 813,1130 L 813,1530 L 801,1559 L 778,1585 L 753,1600 L 723,1607 L 699,1606 L 683,1602 L 662,1592 L 649,1582 L 635,1567 L 622,1544 L 616,1522 L 615,1499 L 623,1465 L 634,1446 L 648,1430 L 660,1420 L 685,1405 L 714,1394 L 752,1385 L 758,1376 L 756,1366 L 748,1360 L 720,1364 L 683,1376 L 652,1392 L 631,1408 L 610,1432 L 598,1454 L 592,1474 L 563,1489 L 533,1496 L 501,1496 L 485,1493 L 456,1481 L 434,1463 L 417,1437 L 411,1419 L 411,1390 L 417,1361 L 428,1339 L 452,1313 L 484,1294 L 486,1290 L 484,1278 L 477,1273 L 468,1273 L 438,1289 L 413,1313 L 402,1329 L 392,1351 L 384,1356 L 370,1360 L 349,1360 L 330,1354 L 319,1347 L 303,1329 L 294,1306 L 294,1284 L 297,1273 L 315,1244 L 315,1237 L 312,1231 L 305,1225 L 295,1225 L 276,1233 L 251,1234 L 225,1225 L 205,1207 L 198,1196 L 192,1179 L 191,1157 L 196,1138 L 205,1123 L 222,1105 L 238,1094 L 268,1086 L 291,1088 L 311,1099 L 324,1113 L 336,1115 L 345,1106 L 346,1101 L 343,1093 L 321,1072 L 291,1060 L 257,1060 L 214,1073 L 192,1072 L 170,1066 L 147,1053 L 125,1030 L 114,1010 L 107,981 L 107,963 L 111,941 L 120,920 L 127,910 L 152,888 L 177,876 L 198,871 L 206,865 L 208,860 L 207,852 L 202,846 L 179,839 L 164,829 L 154,818 L 146,804 L 142,790 L 142,769 L 146,755 L 157,737 L 173,723 L 198,714 L 215,714 L 233,723 L 258,729 L 295,728 L 343,713 L 361,704 L 367,696 L 365,684 L 361,680 L 353,678 L 320,693 L 291,701 L 262,702 L 247,699 L 231,692 L 213,679 L 198,661 L 190,642 L 187,624 L 188,600 L 196,579 L 212,560 L 223,552 L 243,544 L 269,543 L 290,550 L 298,550 L 308,540 L 308,530 L 286,503 L 275,473 L 275,443 L 281,423 L 290,406 L 316,380 L 331,371 L 347,365 L 369,361 L 389,361 L 416,367 L 442,383 L 454,397 L 464,416 L 471,438 L 473,480 L 480,488 L 490,489 L 494,487 L 499,481 L 501,468 L 500,446 L 494,418 L 480,387 L 456,355 L 456,330 L 463,310 L 482,288 L 504,275 L 528,269 L 557,270 L 573,275 L 588,285 L 608,319 L 635,343 L 649,350 L 672,356 L 703,354 L 708,349 L 710,343 L 709,336 L 704,330 L 699,328 L 677,329 L 663,326 L 644,316 L 628,300 L 616,280 L 611,260 L 610,239 L 615,212 L 632,181 L 648,165 L 664,154 L 684,146 Z M 522,1129 L 519,1140 L 526,1150 L 564,1155 L 600,1166 L 626,1180 L 638,1189 L 643,1197 L 631,1220 L 607,1245 L 585,1258 L 554,1267 L 549,1272 L 547,1281 L 552,1290 L 558,1293 L 569,1292 L 594,1284 L 610,1276 L 626,1265 L 643,1249 L 664,1219 L 669,1225 L 681,1251 L 690,1292 L 698,1299 L 709,1298 L 714,1293 L 716,1282 L 713,1264 L 701,1227 L 680,1193 L 655,1168 L 622,1147 L 586,1133 L 536,1124 L 528,1125 Z M 530,949 L 518,948 L 511,954 L 504,989 L 496,1003 L 486,1014 L 465,1027 L 445,1033 L 432,1034 L 425,1039 L 423,1052 L 429,1059 L 441,1061 L 469,1055 L 490,1045 L 513,1026 L 526,1007 L 534,984 L 536,956 Z M 490,857 L 486,850 L 457,837 L 425,829 L 389,827 L 353,833 L 317,847 L 279,872 L 239,913 L 235,920 L 235,929 L 244,938 L 256,936 L 270,918 L 306,885 L 339,866 L 363,859 L 379,887 L 386,918 L 385,949 L 376,978 L 376,986 L 381,993 L 394,995 L 399,992 L 405,980 L 413,946 L 411,899 L 404,876 L 394,856 L 396,854 L 414,855 L 435,859 L 473,874 L 480,874 L 486,871 L 490,865 Z M 623,683 L 620,695 L 628,705 L 661,707 L 692,717 L 711,730 L 724,743 L 744,775 L 756,777 L 764,771 L 766,765 L 765,758 L 752,735 L 734,714 L 715,699 L 701,691 L 671,681 L 636,678 L 629,679 Z M 457,614 L 451,622 L 451,629 L 456,637 L 488,646 L 509,656 L 527,668 L 546,687 L 560,711 L 566,731 L 568,747 L 566,781 L 572,789 L 577,791 L 589,788 L 593,782 L 595,767 L 594,732 L 584,697 L 569,672 L 544,647 L 519,631 L 476,614 L 467,612 Z M 618,468 L 616,477 L 622,487 L 657,492 L 678,498 L 703,510 L 721,523 L 722,527 L 711,546 L 691,566 L 667,579 L 650,583 L 642,589 L 640,598 L 645,607 L 651,610 L 662,609 L 697,595 L 715,582 L 728,569 L 742,549 L 754,571 L 763,609 L 771,615 L 778,615 L 786,610 L 788,595 L 776,552 L 757,521 L 736,500 L 704,480 L 671,468 L 639,462 L 626,462 Z" fill="#6ea8dc" fill-rule="evenodd"/>
  <path d="M 1223,292 L 1231,265 L 1231,238 L 1226,240 L 1219,253 L 1213,259 L 1203,264 L 1184,262 L 1170,250 L 1165,239 L 1165,217 L 1169,205 L 1178,190 L 1216,143 L 1236,112 L 1256,143 L 1294,190 L 1303,205 L 1307,217 L 1307,239 L 1302,250 L 1288,262 L 1269,264 L 1259,259 L 1252,253 L 1245,240 L 1240,238 L 1240,265 L 1248,292 Z" fill="none" stroke="#6ea8dc" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1440,688 L 1439,688 L 1369,604 L 1356,582 L 1351,564 L 1353,538 L 1364,522 L 1374,514 L 1387,508 L 1403,508 L 1414,512 L 1428,524 L 1435,536 L 1440,552 L 1445,536 L 1452,524 L 1466,512 L 1477,508 L 1493,508 L 1506,514 L 1516,522 L 1527,538 L 1529,564 L 1524,582 L 1511,604 L 1441,688 Z" fill="none" stroke="#6ea8dc" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1420,1061 L 1491,1151 L 1420,1241 L 1351,1151 Z" fill="none" stroke="#6ea8dc" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1236,1638 L 1244,1616 L 1245,1582 L 1237,1598 L 1227,1608 L 1208,1615 L 1194,1614 L 1183,1609 L 1172,1599 L 1165,1584 L 1166,1563 L 1170,1554 L 1179,1545 L 1189,1539 L 1202,1536 L 1229,1538 L 1218,1526 L 1211,1513 L 1208,1494 L 1210,1485 L 1220,1469 L 1229,1462 L 1240,1458 L 1248,1458 L 1255,1458 L 1266,1462 L 1275,1469 L 1285,1485 L 1287,1494 L 1284,1513 L 1277,1526 L 1266,1538 L 1293,1536 L 1306,1539 L 1316,1545 L 1325,1554 L 1329,1563 L 1330,1584 L 1323,1599 L 1312,1609 L 1301,1614 L 1287,1615 L 1268,1608 L 1258,1598 L 1251,1582 L 1252,1616 L 1259,1638 Z" fill="none" stroke="#6ea8dc" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>

  <!-- Dollar circle at connector 3 -->
  <circle cx="1255" cy="875" r="90" fill="none" stroke="#6ea8dc" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  

  <path d="M 1246,853 C 1248,845 1236,840 1226,840 C 1214,840 1206,847 1206,855 C 1206,865 1218,871 1228,875 C 1238,879 1250,885 1250,895 C 1250,903 1242,910 1230,910 C 1220,910 1208,905 1210,897" fill="none" stroke="#6ea8dc" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1228,823 L 1228,927" fill="none" stroke="#6ea8dc" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1300,853 C 1302,845 1290,840 1280,840 C 1268,840 1260,847 1260,855 C 1260,865 1272,871 1282,875 C 1292,879 1304,885 1304,895 C 1304,903 1296,910 1284,910 C 1274,910 1262,905 1264,897" fill="none" stroke="#6ea8dc" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1282,823 L 1282,927" fill="none" stroke="#6ea8dc" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
</svg>
                    </div>
                    <div class="card-corner bottom-right">
                        <div class="card-rank">N</div>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="15" viewBox="0 0 1588 1750">
  <path d="M 1170,188 L 967,188 L 959,194 L 957,200 L 956,420 L 843,420 L 841,418 L 840,222 L 834,200 L 826,182 L 817,168 L 798,147 L 782,135 L 761,124 L 731,116 L 694,116 L 659,126 L 629,145 L 613,161 L 601,178 L 587,211 L 582,250 L 570,245 L 554,242 L 526,242 L 496,249 L 467,265 L 444,289 L 432,314 L 427,342 L 392,334 L 357,335 L 318,347 L 287,368 L 264,396 L 254,417 L 249,434 L 247,470 L 251,490 L 261,513 L 260,516 L 245,516 L 231,519 L 202,533 L 180,554 L 166,579 L 160,603 L 161,636 L 168,662 L 183,690 L 160,699 L 137,718 L 120,746 L 114,775 L 115,793 L 120,813 L 133,836 L 154,856 L 122,876 L 107,891 L 95,908 L 87,926 L 81,950 L 80,984 L 85,1010 L 91,1026 L 104,1048 L 114,1060 L 141,1082 L 162,1092 L 189,1100 L 175,1119 L 165,1147 L 164,1177 L 171,1203 L 185,1226 L 199,1240 L 212,1249 L 241,1260 L 272,1262 L 266,1288 L 268,1315 L 272,1328 L 282,1347 L 299,1366 L 321,1380 L 340,1386 L 364,1388 L 380,1385 L 385,1387 L 383,1416 L 389,1441 L 407,1474 L 423,1491 L 454,1511 L 480,1520 L 498,1523 L 525,1524 L 544,1522 L 562,1518 L 587,1508 L 589,1527 L 595,1550 L 612,1582 L 636,1607 L 669,1626 L 703,1634 L 728,1634 L 756,1628 L 780,1617 L 797,1605 L 813,1589 L 824,1574 L 832,1559 L 840,1535 L 841,1331 L 843,1329 L 972,1329 L 974,1331 L 974,1562 L 1170,1562 L 1170,1534 L 1001,1534 L 1001,1312 L 995,1304 L 990,1302 L 841,1301 L 842,1165 L 1359,1165 L 1359,1137 L 841,1136 L 841,888 L 843,888 L 1170,888 L 1170,861 L 843,861 L 841,861 L 843,612 L 1359,613 L 1359,584 L 842,584 L 841,449 L 843,447 L 974,447 L 979,445 L 984,439 L 984,217 L 986,215 L 1170,216 Z M 707,142 L 733,144 L 747,148 L 762,155 L 779,167 L 802,195 L 810,214 L 814,233 L 813,1102 L 793,1098 L 753,1085 L 725,1072 L 719,1067 L 734,1047 L 747,1021 L 755,995 L 759,967 L 759,938 L 753,899 L 739,855 L 730,840 L 722,838 L 714,841 L 710,846 L 709,855 L 723,892 L 729,918 L 732,947 L 731,973 L 721,1012 L 711,1032 L 698,1050 L 694,1052 L 661,1022 L 644,999 L 626,965 L 622,963 L 611,964 L 604,973 L 604,979 L 614,1002 L 635,1034 L 654,1055 L 679,1076 L 704,1092 L 734,1107 L 773,1121 L 813,1130 L 813,1530 L 801,1559 L 778,1585 L 753,1600 L 723,1607 L 699,1606 L 683,1602 L 662,1592 L 649,1582 L 635,1567 L 622,1544 L 616,1522 L 615,1499 L 623,1465 L 634,1446 L 648,1430 L 660,1420 L 685,1405 L 714,1394 L 752,1385 L 758,1376 L 756,1366 L 748,1360 L 720,1364 L 683,1376 L 652,1392 L 631,1408 L 610,1432 L 598,1454 L 592,1474 L 563,1489 L 533,1496 L 501,1496 L 485,1493 L 456,1481 L 434,1463 L 417,1437 L 411,1419 L 411,1390 L 417,1361 L 428,1339 L 452,1313 L 484,1294 L 486,1290 L 484,1278 L 477,1273 L 468,1273 L 438,1289 L 413,1313 L 402,1329 L 392,1351 L 384,1356 L 370,1360 L 349,1360 L 330,1354 L 319,1347 L 303,1329 L 294,1306 L 294,1284 L 297,1273 L 315,1244 L 315,1237 L 312,1231 L 305,1225 L 295,1225 L 276,1233 L 251,1234 L 225,1225 L 205,1207 L 198,1196 L 192,1179 L 191,1157 L 196,1138 L 205,1123 L 222,1105 L 238,1094 L 268,1086 L 291,1088 L 311,1099 L 324,1113 L 336,1115 L 345,1106 L 346,1101 L 343,1093 L 321,1072 L 291,1060 L 257,1060 L 214,1073 L 192,1072 L 170,1066 L 147,1053 L 125,1030 L 114,1010 L 107,981 L 107,963 L 111,941 L 120,920 L 127,910 L 152,888 L 177,876 L 198,871 L 206,865 L 208,860 L 207,852 L 202,846 L 179,839 L 164,829 L 154,818 L 146,804 L 142,790 L 142,769 L 146,755 L 157,737 L 173,723 L 198,714 L 215,714 L 233,723 L 258,729 L 295,728 L 343,713 L 361,704 L 367,696 L 365,684 L 361,680 L 353,678 L 320,693 L 291,701 L 262,702 L 247,699 L 231,692 L 213,679 L 198,661 L 190,642 L 187,624 L 188,600 L 196,579 L 212,560 L 223,552 L 243,544 L 269,543 L 290,550 L 298,550 L 308,540 L 308,530 L 286,503 L 275,473 L 275,443 L 281,423 L 290,406 L 316,380 L 331,371 L 347,365 L 369,361 L 389,361 L 416,367 L 442,383 L 454,397 L 464,416 L 471,438 L 473,480 L 480,488 L 490,489 L 494,487 L 499,481 L 501,468 L 500,446 L 494,418 L 480,387 L 456,355 L 456,330 L 463,310 L 482,288 L 504,275 L 528,269 L 557,270 L 573,275 L 588,285 L 608,319 L 635,343 L 649,350 L 672,356 L 703,354 L 708,349 L 710,343 L 709,336 L 704,330 L 699,328 L 677,329 L 663,326 L 644,316 L 628,300 L 616,280 L 611,260 L 610,239 L 615,212 L 632,181 L 648,165 L 664,154 L 684,146 Z M 522,1129 L 519,1140 L 526,1150 L 564,1155 L 600,1166 L 626,1180 L 638,1189 L 643,1197 L 631,1220 L 607,1245 L 585,1258 L 554,1267 L 549,1272 L 547,1281 L 552,1290 L 558,1293 L 569,1292 L 594,1284 L 610,1276 L 626,1265 L 643,1249 L 664,1219 L 669,1225 L 681,1251 L 690,1292 L 698,1299 L 709,1298 L 714,1293 L 716,1282 L 713,1264 L 701,1227 L 680,1193 L 655,1168 L 622,1147 L 586,1133 L 536,1124 L 528,1125 Z M 530,949 L 518,948 L 511,954 L 504,989 L 496,1003 L 486,1014 L 465,1027 L 445,1033 L 432,1034 L 425,1039 L 423,1052 L 429,1059 L 441,1061 L 469,1055 L 490,1045 L 513,1026 L 526,1007 L 534,984 L 536,956 Z M 490,857 L 486,850 L 457,837 L 425,829 L 389,827 L 353,833 L 317,847 L 279,872 L 239,913 L 235,920 L 235,929 L 244,938 L 256,936 L 270,918 L 306,885 L 339,866 L 363,859 L 379,887 L 386,918 L 385,949 L 376,978 L 376,986 L 381,993 L 394,995 L 399,992 L 405,980 L 413,946 L 411,899 L 404,876 L 394,856 L 396,854 L 414,855 L 435,859 L 473,874 L 480,874 L 486,871 L 490,865 Z M 623,683 L 620,695 L 628,705 L 661,707 L 692,717 L 711,730 L 724,743 L 744,775 L 756,777 L 764,771 L 766,765 L 765,758 L 752,735 L 734,714 L 715,699 L 701,691 L 671,681 L 636,678 L 629,679 Z M 457,614 L 451,622 L 451,629 L 456,637 L 488,646 L 509,656 L 527,668 L 546,687 L 560,711 L 566,731 L 568,747 L 566,781 L 572,789 L 577,791 L 589,788 L 593,782 L 595,767 L 594,732 L 584,697 L 569,672 L 544,647 L 519,631 L 476,614 L 467,612 Z M 618,468 L 616,477 L 622,487 L 657,492 L 678,498 L 703,510 L 721,523 L 722,527 L 711,546 L 691,566 L 667,579 L 650,583 L 642,589 L 640,598 L 645,607 L 651,610 L 662,609 L 697,595 L 715,582 L 728,569 L 742,549 L 754,571 L 763,609 L 771,615 L 778,615 L 786,610 L 788,595 L 776,552 L 757,521 L 736,500 L 704,480 L 671,468 L 639,462 L 626,462 Z" fill="#FF8C38" fill-rule="evenodd"/>
  <path d="M 1223,292 L 1231,265 L 1231,238 L 1226,240 L 1219,253 L 1213,259 L 1203,264 L 1184,262 L 1170,250 L 1165,239 L 1165,217 L 1169,205 L 1178,190 L 1216,143 L 1236,112 L 1256,143 L 1294,190 L 1303,205 L 1307,217 L 1307,239 L 1302,250 L 1288,262 L 1269,264 L 1259,259 L 1252,253 L 1245,240 L 1240,238 L 1240,265 L 1248,292 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1440,688 L 1439,688 L 1369,604 L 1356,582 L 1351,564 L 1353,538 L 1364,522 L 1374,514 L 1387,508 L 1403,508 L 1414,512 L 1428,524 L 1435,536 L 1440,552 L 1445,536 L 1452,524 L 1466,512 L 1477,508 L 1493,508 L 1506,514 L 1516,522 L 1527,538 L 1529,564 L 1524,582 L 1511,604 L 1441,688 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1420,1061 L 1491,1151 L 1420,1241 L 1351,1151 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1236,1638 L 1244,1616 L 1245,1582 L 1237,1598 L 1227,1608 L 1208,1615 L 1194,1614 L 1183,1609 L 1172,1599 L 1165,1584 L 1166,1563 L 1170,1554 L 1179,1545 L 1189,1539 L 1202,1536 L 1229,1538 L 1218,1526 L 1211,1513 L 1208,1494 L 1210,1485 L 1220,1469 L 1229,1462 L 1240,1458 L 1248,1458 L 1255,1458 L 1266,1462 L 1275,1469 L 1285,1485 L 1287,1494 L 1284,1513 L 1277,1526 L 1266,1538 L 1293,1536 L 1306,1539 L 1316,1545 L 1325,1554 L 1329,1563 L 1330,1584 L 1323,1599 L 1312,1609 L 1301,1614 L 1287,1615 L 1268,1608 L 1258,1598 L 1251,1582 L 1252,1616 L 1259,1638 Z" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>

  <!-- Dollar circle at connector 3 -->
  <circle cx="1255" cy="875" r="90" fill="none" stroke="#FF8C38" stroke-width="27" stroke-linejoin="round" stroke-linecap="round"/>
  

  <path d="M 1246,853 C 1248,845 1236,840 1226,840 C 1214,840 1206,847 1206,855 C 1206,865 1218,871 1228,875 C 1238,879 1250,885 1250,895 C 1250,903 1242,910 1230,910 C 1220,910 1208,905 1210,897" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1228,823 L 1228,927" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1300,853 C 1302,845 1290,840 1280,840 C 1268,840 1260,847 1260,855 C 1260,865 1272,871 1282,875 C 1292,879 1304,885 1304,895 C 1304,903 1296,910 1284,910 C 1274,910 1262,905 1264,897" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M 1282,823 L 1282,927" fill="none" stroke="#FF8C38" stroke-width="16" stroke-linejoin="round" stroke-linecap="round"/>
</svg>
                    </div>
                </div>
            </div>
            <div class="splash-suits-metal">♠ ♥ ♦ ♣</div>
            <div class="splash-copyright">© 2026 NitWiz. All rights reserved.</div>
            <div id="splash-version" style="font-family: 'Outfit', sans-serif; font-size: 0.65rem; color: rgba(200,200,200,0.35); letter-spacing: 0.5px; margin-top: 0.3rem;"></div>
            <div style="font-family:'Outfit',sans-serif;font-size:0.7rem;font-weight:600;color:rgba(255,255,255,0.25);letter-spacing:3px;margin-top:1.5rem;text-transform:uppercase;">Tap anywhere to continue</div>
        </div>
    </div>

    <!-- Auth Screen -->
    <div id="auth-screen" style="display: none;">
        <div class="auth-container">
            <div class="auth-logo">NitWiz</div>
            <div class="auth-subtitle">Poker Intelligence</div>

            <!-- Login Panel -->
            <div id="auth-login" class="auth-panel" style="display: block;">
                <div class="auth-card">
                    <h2>Sign In</h2>
                    <input type="email" id="login-email" class="auth-input" placeholder="Email" autocomplete="email">
                    <div class="auth-pw-wrapper">
                        <input type="password" id="login-password" class="auth-input" placeholder="Password" autocomplete="current-password">
                        <button type="button" class="auth-pw-toggle" onclick="toggleLoginPassword(this)" title="Show/hide password">
                            <svg id="login-pw-eye" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <div class="auth-forgot"><span onclick="handleForgotPassword()">Forgot password?</span></div>
                    <button id="login-btn" class="auth-btn" onclick="handleLogin()">Sign In</button>
                    <div id="login-error" class="auth-error"></div>
                </div>
                <div class="auth-footer">
                    <span class="auth-link" onclick="showAuthPanel('signup')">Create account</span>
                    <div class="auth-divider"><span>or</span></div>
                    <span class="auth-link" onclick="showAuthPanel('request')">Request access</span>
                </div>
            </div>

            <!-- Sign Up Panel -->
            <div id="auth-signup" class="auth-panel">
                <div class="auth-card">
                    <h2>Create Account</h2>
                    <p style="font-size:0.8rem;color:rgba(255,255,255,0.5);margin-bottom:1rem;">Your email must be approved before you can create an account.</p>
                    <input type="email" id="signup-email" class="auth-input" placeholder="Approved email" autocomplete="email">
                    <input type="password" id="signup-password" class="auth-input" placeholder="Create password (6+ chars)" autocomplete="new-password">
                    <input type="password" id="signup-confirm" class="auth-input" placeholder="Confirm password" autocomplete="new-password">
                    <button id="signup-btn" class="auth-btn" onclick="handleSignUp()">Create Account</button>
                    <div id="signup-error" class="auth-error"></div>
                </div>
                <div class="auth-footer">
                    <span class="auth-link" onclick="showAuthPanel('login')">← Back to sign in</span>
                </div>
            </div>

            <!-- Request Access Panel -->
            <div id="auth-request" class="auth-panel">
                <div class="auth-card">
                    <h2>Request Access</h2>
                    <p style="font-size:0.8rem;color:rgba(255,255,255,0.5);margin-bottom:1rem;">Submit your email and the admin will review your request.</p>
                    <input type="text" id="request-name" class="auth-input" placeholder="Your name (optional)">
                    <input type="email" id="request-email" class="auth-input" placeholder="Email address">
                    <button id="request-btn" class="auth-btn" onclick="handleRequestAccess()">Request Access</button>
                    <div id="request-error" class="auth-error"></div>
                    <div id="request-success" class="auth-success"></div>
                </div>
                <div class="auth-footer">
                    <span class="auth-link" onclick="showAuthPanel('login')">← Back to sign in</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation Bar -->
    <nav id="bottom-nav">
        <button class="bnav-btn active" id="bnav-dashboard" onclick="switchTab('dashboard')" title="Dashboard">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>
            </svg>
            <span class="bnav-label">Home</span>
        </button>
        <button class="bnav-btn" id="bnav-players" onclick="switchTab('players')" title="Players">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
            <span class="bnav-label">Players</span>
        </button>
        <button class="bnav-btn" id="bnav-quick-obs" onclick="switchTab('quick-obs')" title="Quick Obs">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
            <span class="bnav-label">Quick Obs</span>
        </button>
        <button class="bnav-btn" id="bnav-live-session" onclick="switchTab('live-session')" title="Live Session">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            <span class="bnav-label">Session</span>
        </button>
        <button class="bnav-btn" id="bnav-archetypes" onclick="switchTab('archetypes')" title="Archetypes">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
            <span class="bnav-label">Types</span>
        </button>
    </nav>

    <div class="container" id="main-container" style="display: none;">
    <div id="nitwiz-watermark" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:80vmin;height:80vmin;background-image:url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNTg4IiBoZWlnaHQ9IjE3NTAiIHZpZXdCb3g9IjAgMCAxNTg4IDE3NTAiPgogIDxwYXRoIGQ9Ik0gMTE3MCwxODggTCA5NjcsMTg4IEwgOTU5LDE5NCBMIDk1NywyMDAgTCA5NTYsNDIwIEwgODQzLDQyMCBMIDg0MSw0MTggTCA4NDAsMjIyIEwgODM0LDIwMCBMIDgyNiwxODIgTCA4MTcsMTY4IEwgNzk4LDE0NyBMIDc4MiwxMzUgTCA3NjEsMTI0IEwgNzMxLDExNiBMIDY5NCwxMTYgTCA2NTksMTI2IEwgNjI5LDE0NSBMIDYxMywxNjEgTCA2MDEsMTc4IEwgNTg3LDIxMSBMIDU4MiwyNTAgTCA1NzAsMjQ1IEwgNTU0LDI0MiBMIDUyNiwyNDIgTCA0OTYsMjQ5IEwgNDY3LDI2NSBMIDQ0NCwyODkgTCA0MzIsMzE0IEwgNDI3LDM0MiBMIDM5MiwzMzQgTCAzNTcsMzM1IEwgMzE4LDM0NyBMIDI4NywzNjggTCAyNjQsMzk2IEwgMjU0LDQxNyBMIDI0OSw0MzQgTCAyNDcsNDcwIEwgMjUxLDQ5MCBMIDI2MSw1MTMgTCAyNjAsNTE2IEwgMjQ1LDUxNiBMIDIzMSw1MTkgTCAyMDIsNTMzIEwgMTgwLDU1NCBMIDE2Niw1NzkgTCAxNjAsNjAzIEwgMTYxLDYzNiBMIDE2OCw2NjIgTCAxODMsNjkwIEwgMTYwLDY5OSBMIDEzNyw3MTggTCAxMjAsNzQ2IEwgMTE0LDc3NSBMIDExNSw3OTMgTCAxMjAsODEzIEwgMTMzLDgzNiBMIDE1NCw4NTYgTCAxMjIsODc2IEwgMTA3LDg5MSBMIDk1LDkwOCBMIDg3LDkyNiBMIDgxLDk1MCBMIDgwLDk4NCBMIDg1LDEwMTAgTCA5MSwxMDI2IEwgMTA0LDEwNDggTCAxMTQsMTA2MCBMIDE0MSwxMDgyIEwgMTYyLDEwOTIgTCAxODksMTEwMCBMIDE3NSwxMTE5IEwgMTY1LDExNDcgTCAxNjQsMTE3NyBMIDE3MSwxMjAzIEwgMTg1LDEyMjYgTCAxOTksMTI0MCBMIDIxMiwxMjQ5IEwgMjQxLDEyNjAgTCAyNzIsMTI2MiBMIDI2NiwxMjg4IEwgMjY4LDEzMTUgTCAyNzIsMTMyOCBMIDI4MiwxMzQ3IEwgMjk5LDEzNjYgTCAzMjEsMTM4MCBMIDM0MCwxMzg2IEwgMzY0LDEzODggTCAzODAsMTM4NSBMIDM4NSwxMzg3IEwgMzgzLDE0MTYgTCAzODksMTQ0MSBMIDQwNywxNDc0IEwgNDIzLDE0OTEgTCA0NTQsMTUxMSBMIDQ4MCwxNTIwIEwgNDk4LDE1MjMgTCA1MjUsMTUyNCBMIDU0NCwxNTIyIEwgNTYyLDE1MTggTCA1ODcsMTUwOCBMIDU4OSwxNTI3IEwgNTk1LDE1NTAgTCA2MTIsMTU4MiBMIDYzNiwxNjA3IEwgNjY5LDE2MjYgTCA3MDMsMTYzNCBMIDcyOCwxNjM0IEwgNzU2LDE2MjggTCA3ODAsMTYxNyBMIDc5NywxNjA1IEwgODEzLDE1ODkgTCA4MjQsMTU3NCBMIDgzMiwxNTU5IEwgODQwLDE1MzUgTCA4NDEsMTMzMSBMIDg0MywxMzI5IEwgOTcyLDEzMjkgTCA5NzQsMTMzMSBMIDk3NCwxNTYyIEwgMTE3MCwxNTYyIEwgMTE3MCwxNTM0IEwgMTAwMSwxNTM0IEwgMTAwMSwxMzEyIEwgOTk1LDEzMDQgTCA5OTAsMTMwMiBMIDg0MSwxMzAxIEwgODQyLDExNjUgTCAxMzU5LDExNjUgTCAxMzU5LDExMzcgTCA4NDEsMTEzNiBMIDg0MSw4ODggTCA4NDMsODg4IEwgMTE3MCw4ODggTCAxMTcwLDg2MSBMIDg0Myw4NjEgTCA4NDEsODYxIEwgODQzLDYxMiBMIDEzNTksNjEzIEwgMTM1OSw1ODQgTCA4NDIsNTg0IEwgODQxLDQ0OSBMIDg0Myw0NDcgTCA5NzQsNDQ3IEwgOTc5LDQ0NSBMIDk4NCw0MzkgTCA5ODQsMjE3IEwgOTg2LDIxNSBMIDExNzAsMjE2IFogTSA3MDcsMTQyIEwgNzMzLDE0NCBMIDc0NywxNDggTCA3NjIsMTU1IEwgNzc5LDE2NyBMIDgwMiwxOTUgTCA4MTAsMjE0IEwgODE0LDIzMyBMIDgxMywxMTAyIEwgNzkzLDEwOTggTCA3NTMsMTA4NSBMIDcyNSwxMDcyIEwgNzE5LDEwNjcgTCA3MzQsMTA0NyBMIDc0NywxMDIxIEwgNzU1LDk5NSBMIDc1OSw5NjcgTCA3NTksOTM4IEwgNzUzLDg5OSBMIDczOSw4NTUgTCA3MzAsODQwIEwgNzIyLDgzOCBMIDcxNCw4NDEgTCA3MTAsODQ2IEwgNzA5LDg1NSBMIDcyMyw4OTIgTCA3MjksOTE4IEwgNzMyLDk0NyBMIDczMSw5NzMgTCA3MjEsMTAxMiBMIDcxMSwxMDMyIEwgNjk4LDEwNTAgTCA2OTQsMTA1MiBMIDY2MSwxMDIyIEwgNjQ0LDk5OSBMIDYyNiw5NjUgTCA2MjIsOTYzIEwgNjExLDk2NCBMIDYwNCw5NzMgTCA2MDQsOTc5IEwgNjE0LDEwMDIgTCA2MzUsMTAzNCBMIDY1NCwxMDU1IEwgNjc5LDEwNzYgTCA3MDQsMTA5MiBMIDczNCwxMTA3IEwgNzczLDExMjEgTCA4MTMsMTEzMCBMIDgxMywxNTMwIEwgODAxLDE1NTkgTCA3NzgsMTU4NSBMIDc1MywxNjAwIEwgNzIzLDE2MDcgTCA2OTksMTYwNiBMIDY4MywxNjAyIEwgNjYyLDE1OTIgTCA2NDksMTU4MiBMIDYzNSwxNTY3IEwgNjIyLDE1NDQgTCA2MTYsMTUyMiBMIDYxNSwxNDk5IEwgNjIzLDE0NjUgTCA2MzQsMTQ0NiBMIDY0OCwxNDMwIEwgNjYwLDE0MjAgTCA2ODUsMTQwNSBMIDcxNCwxMzk0IEwgNzUyLDEzODUgTCA3NTgsMTM3NiBMIDc1NiwxMzY2IEwgNzQ4LDEzNjAgTCA3MjAsMTM2NCBMIDY4MywxMzc2IEwgNjUyLDEzOTIgTCA2MzEsMTQwOCBMIDYxMCwxNDMyIEwgNTk4LDE0NTQgTCA1OTIsMTQ3NCBMIDU2MywxNDg5IEwgNTMzLDE0OTYgTCA1MDEsMTQ5NiBMIDQ4NSwxNDkzIEwgNDU2LDE0ODEgTCA0MzQsMTQ2MyBMIDQxNywxNDM3IEwgNDExLDE0MTkgTCA0MTEsMTM5MCBMIDQxNywxMzYxIEwgNDI4LDEzMzkgTCA0NTIsMTMxMyBMIDQ4NCwxMjk0IEwgNDg2LDEyOTAgTCA0ODQsMTI3OCBMIDQ3NywxMjczIEwgNDY4LDEyNzMgTCA0MzgsMTI4OSBMIDQxMywxMzEzIEwgNDAyLDEzMjkgTCAzOTIsMTM1MSBMIDM4NCwxMzU2IEwgMzcwLDEzNjAgTCAzNDksMTM2MCBMIDMzMCwxMzU0IEwgMzE5LDEzNDcgTCAzMDMsMTMyOSBMIDI5NCwxMzA2IEwgMjk0LDEyODQgTCAyOTcsMTI3MyBMIDMxNSwxMjQ0IEwgMzE1LDEyMzcgTCAzMTIsMTIzMSBMIDMwNSwxMjI1IEwgMjk1LDEyMjUgTCAyNzYsMTIzMyBMIDI1MSwxMjM0IEwgMjI1LDEyMjUgTCAyMDUsMTIwNyBMIDE5OCwxMTk2IEwgMTkyLDExNzkgTCAxOTEsMTE1NyBMIDE5NiwxMTM4IEwgMjA1LDExMjMgTCAyMjIsMTEwNSBMIDIzOCwxMDk0IEwgMjY4LDEwODYgTCAyOTEsMTA4OCBMIDMxMSwxMDk5IEwgMzI0LDExMTMgTCAzMzYsMTExNSBMIDM0NSwxMTA2IEwgMzQ2LDExMDEgTCAzNDMsMTA5MyBMIDMyMSwxMDcyIEwgMjkxLDEwNjAgTCAyNTcsMTA2MCBMIDIxNCwxMDczIEwgMTkyLDEwNzIgTCAxNzAsMTA2NiBMIDE0NywxMDUzIEwgMTI1LDEwMzAgTCAxMTQsMTAxMCBMIDEwNyw5ODEgTCAxMDcsOTYzIEwgMTExLDk0MSBMIDEyMCw5MjAgTCAxMjcsOTEwIEwgMTUyLDg4OCBMIDE3Nyw4NzYgTCAxOTgsODcxIEwgMjA2LDg2NSBMIDIwOCw4NjAgTCAyMDcsODUyIEwgMjAyLDg0NiBMIDE3OSw4MzkgTCAxNjQsODI5IEwgMTU0LDgxOCBMIDE0Niw4MDQgTCAxNDIsNzkwIEwgMTQyLDc2OSBMIDE0Niw3NTUgTCAxNTcsNzM3IEwgMTczLDcyMyBMIDE5OCw3MTQgTCAyMTUsNzE0IEwgMjMzLDcyMyBMIDI1OCw3MjkgTCAyOTUsNzI4IEwgMzQzLDcxMyBMIDM2MSw3MDQgTCAzNjcsNjk2IEwgMzY1LDY4NCBMIDM2MSw2ODAgTCAzNTMsNjc4IEwgMzIwLDY5MyBMIDI5MSw3MDEgTCAyNjIsNzAyIEwgMjQ3LDY5OSBMIDIzMSw2OTIgTCAyMTMsNjc5IEwgMTk4LDY2MSBMIDE5MCw2NDIgTCAxODcsNjI0IEwgMTg4LDYwMCBMIDE5Niw1NzkgTCAyMTIsNTYwIEwgMjIzLDU1MiBMIDI0Myw1NDQgTCAyNjksNTQzIEwgMjkwLDU1MCBMIDI5OCw1NTAgTCAzMDgsNTQwIEwgMzA4LDUzMCBMIDI4Niw1MDMgTCAyNzUsNDczIEwgMjc1LDQ0MyBMIDI4MSw0MjMgTCAyOTAsNDA2IEwgMzE2LDM4MCBMIDMzMSwzNzEgTCAzNDcsMzY1IEwgMzY5LDM2MSBMIDM4OSwzNjEgTCA0MTYsMzY3IEwgNDQyLDM4MyBMIDQ1NCwzOTcgTCA0NjQsNDE2IEwgNDcxLDQzOCBMIDQ3Myw0ODAgTCA0ODAsNDg4IEwgNDkwLDQ4OSBMIDQ5NCw0ODcgTCA0OTksNDgxIEwgNTAxLDQ2OCBMIDUwMCw0NDYgTCA0OTQsNDE4IEwgNDgwLDM4NyBMIDQ1NiwzNTUgTCA0NTYsMzMwIEwgNDYzLDMxMCBMIDQ4MiwyODggTCA1MDQsMjc1IEwgNTI4LDI2OSBMIDU1NywyNzAgTCA1NzMsMjc1IEwgNTg4LDI4NSBMIDYwOCwzMTkgTCA2MzUsMzQzIEwgNjQ5LDM1MCBMIDY3MiwzNTYgTCA3MDMsMzU0IEwgNzA4LDM0OSBMIDcxMCwzNDMgTCA3MDksMzM2IEwgNzA0LDMzMCBMIDY5OSwzMjggTCA2NzcsMzI5IEwgNjYzLDMyNiBMIDY0NCwzMTYgTCA2MjgsMzAwIEwgNjE2LDI4MCBMIDYxMSwyNjAgTCA2MTAsMjM5IEwgNjE1LDIxMiBMIDYzMiwxODEgTCA2NDgsMTY1IEwgNjY0LDE1NCBMIDY4NCwxNDYgWiBNIDUyMiwxMTI5IEwgNTE5LDExNDAgTCA1MjYsMTE1MCBMIDU2NCwxMTU1IEwgNjAwLDExNjYgTCA2MjYsMTE4MCBMIDYzOCwxMTg5IEwgNjQzLDExOTcgTCA2MzEsMTIyMCBMIDYwNywxMjQ1IEwgNTg1LDEyNTggTCA1NTQsMTI2NyBMIDU0OSwxMjcyIEwgNTQ3LDEyODEgTCA1NTIsMTI5MCBMIDU1OCwxMjkzIEwgNTY5LDEyOTIgTCA1OTQsMTI4NCBMIDYxMCwxMjc2IEwgNjI2LDEyNjUgTCA2NDMsMTI0OSBMIDY2NCwxMjE5IEwgNjY5LDEyMjUgTCA2ODEsMTI1MSBMIDY5MCwxMjkyIEwgNjk4LDEyOTkgTCA3MDksMTI5OCBMIDcxNCwxMjkzIEwgNzE2LDEyODIgTCA3MTMsMTI2NCBMIDcwMSwxMjI3IEwgNjgwLDExOTMgTCA2NTUsMTE2OCBMIDYyMiwxMTQ3IEwgNTg2LDExMzMgTCA1MzYsMTEyNCBMIDUyOCwxMTI1IFogTSA1MzAsOTQ5IEwgNTE4LDk0OCBMIDUxMSw5NTQgTCA1MDQsOTg5IEwgNDk2LDEwMDMgTCA0ODYsMTAxNCBMIDQ2NSwxMDI3IEwgNDQ1LDEwMzMgTCA0MzIsMTAzNCBMIDQyNSwxMDM5IEwgNDIzLDEwNTIgTCA0MjksMTA1OSBMIDQ0MSwxMDYxIEwgNDY5LDEwNTUgTCA0OTAsMTA0NSBMIDUxMywxMDI2IEwgNTI2LDEwMDcgTCA1MzQsOTg0IEwgNTM2LDk1NiBaIE0gNDkwLDg1NyBMIDQ4Niw4NTAgTCA0NTcsODM3IEwgNDI1LDgyOSBMIDM4OSw4MjcgTCAzNTMsODMzIEwgMzE3LDg0NyBMIDI3OSw4NzIgTCAyMzksOTEzIEwgMjM1LDkyMCBMIDIzNSw5MjkgTCAyNDQsOTM4IEwgMjU2LDkzNiBMIDI3MCw5MTggTCAzMDYsODg1IEwgMzM5LDg2NiBMIDM2Myw4NTkgTCAzNzksODg3IEwgMzg2LDkxOCBMIDM4NSw5NDkgTCAzNzYsOTc4IEwgMzc2LDk4NiBMIDM4MSw5OTMgTCAzOTQsOTk1IEwgMzk5LDk5MiBMIDQwNSw5ODAgTCA0MTMsOTQ2IEwgNDExLDg5OSBMIDQwNCw4NzYgTCAzOTQsODU2IEwgMzk2LDg1NCBMIDQxNCw4NTUgTCA0MzUsODU5IEwgNDczLDg3NCBMIDQ4MCw4NzQgTCA0ODYsODcxIEwgNDkwLDg2NSBaIE0gNjIzLDY4MyBMIDYyMCw2OTUgTCA2MjgsNzA1IEwgNjYxLDcwNyBMIDY5Miw3MTcgTCA3MTEsNzMwIEwgNzI0LDc0MyBMIDc0NCw3NzUgTCA3NTYsNzc3IEwgNzY0LDc3MSBMIDc2Niw3NjUgTCA3NjUsNzU4IEwgNzUyLDczNSBMIDczNCw3MTQgTCA3MTUsNjk5IEwgNzAxLDY5MSBMIDY3MSw2ODEgTCA2MzYsNjc4IEwgNjI5LDY3OSBaIE0gNDU3LDYxNCBMIDQ1MSw2MjIgTCA0NTEsNjI5IEwgNDU2LDYzNyBMIDQ4OCw2NDYgTCA1MDksNjU2IEwgNTI3LDY2OCBMIDU0Niw2ODcgTCA1NjAsNzExIEwgNTY2LDczMSBMIDU2OCw3NDcgTCA1NjYsNzgxIEwgNTcyLDc4OSBMIDU3Nyw3OTEgTCA1ODksNzg4IEwgNTkzLDc4MiBMIDU5NSw3NjcgTCA1OTQsNzMyIEwgNTg0LDY5NyBMIDU2OSw2NzIgTCA1NDQsNjQ3IEwgNTE5LDYzMSBMIDQ3Niw2MTQgTCA0NjcsNjEyIFogTSA2MTgsNDY4IEwgNjE2LDQ3NyBMIDYyMiw0ODcgTCA2NTcsNDkyIEwgNjc4LDQ5OCBMIDcwMyw1MTAgTCA3MjEsNTIzIEwgNzIyLDUyNyBMIDcxMSw1NDYgTCA2OTEsNTY2IEwgNjY3LDU3OSBMIDY1MCw1ODMgTCA2NDIsNTg5IEwgNjQwLDU5OCBMIDY0NSw2MDcgTCA2NTEsNjEwIEwgNjYyLDYwOSBMIDY5Nyw1OTUgTCA3MTUsNTgyIEwgNzI4LDU2OSBMIDc0Miw1NDkgTCA3NTQsNTcxIEwgNzYzLDYwOSBMIDc3MSw2MTUgTCA3NzgsNjE1IEwgNzg2LDYxMCBMIDc4OCw1OTUgTCA3NzYsNTUyIEwgNzU3LDUyMSBMIDczNiw1MDAgTCA3MDQsNDgwIEwgNjcxLDQ2OCBMIDYzOSw0NjIgTCA2MjYsNDYyIFoiIGZpbGw9IiNmZjhjMzgiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPgogIDxwYXRoIGQ9Ik0gMTIyMywyOTIgTCAxMjMxLDI2NSBMIDEyMzEsMjM4IEwgMTIyNiwyNDAgTCAxMjE5LDI1MyBMIDEyMTMsMjU5IEwgMTIwMywyNjQgTCAxMTg0LDI2MiBMIDExNzAsMjUwIEwgMTE2NSwyMzkgTCAxMTY1LDIxNyBMIDExNjksMjA1IEwgMTE3OCwxOTAgTCAxMjE2LDE0MyBMIDEyMzYsMTEyIEwgMTI1NiwxNDMgTCAxMjk0LDE5MCBMIDEzMDMsMjA1IEwgMTMwNywyMTcgTCAxMzA3LDIzOSBMIDEzMDIsMjUwIEwgMTI4OCwyNjIgTCAxMjY5LDI2NCBMIDEyNTksMjU5IEwgMTI1MiwyNTMgTCAxMjQ1LDI0MCBMIDEyNDAsMjM4IEwgMTI0MCwyNjUgTCAxMjQ4LDI5MiBaIiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjhjMzgiIHN0cm9rZS13aWR0aD0iMjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0gMTQ0MCw2ODggTCAxNDM5LDY4OCBMIDEzNjksNjA0IEwgMTM1Niw1ODIgTCAxMzUxLDU2NCBMIDEzNTMsNTM4IEwgMTM2NCw1MjIgTCAxMzc0LDUxNCBMIDEzODcsNTA4IEwgMTQwMyw1MDggTCAxNDE0LDUxMiBMIDE0MjgsNTI0IEwgMTQzNSw1MzYgTCAxNDQwLDU1MiBMIDE0NDUsNTM2IEwgMTQ1Miw1MjQgTCAxNDY2LDUxMiBMIDE0NzcsNTA4IEwgMTQ5Myw1MDggTCAxNTA2LDUxNCBMIDE1MTYsNTIyIEwgMTUyNyw1MzggTCAxNTI5LDU2NCBMIDE1MjQsNTgyIEwgMTUxMSw2MDQgTCAxNDQxLDY4OCBaIiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjhjMzgiIHN0cm9rZS13aWR0aD0iMjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0gMTQyMCwxMDYxIEwgMTQ5MSwxMTUxIEwgMTQyMCwxMjQxIEwgMTM1MSwxMTUxIFoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmOGMzOCIgc3Ryb2tlLXdpZHRoPSIyNyIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+CiAgPHBhdGggZD0iTSAxMjM2LDE2MzggTCAxMjQ0LDE2MTYgTCAxMjQ1LDE1ODIgTCAxMjM3LDE1OTggTCAxMjI3LDE2MDggTCAxMjA4LDE2MTUgTCAxMTk0LDE2MTQgTCAxMTgzLDE2MDkgTCAxMTcyLDE1OTkgTCAxMTY1LDE1ODQgTCAxMTY2LDE1NjMgTCAxMTcwLDE1NTQgTCAxMTc5LDE1NDUgTCAxMTg5LDE1MzkgTCAxMjAyLDE1MzYgTCAxMjI5LDE1MzggTCAxMjE4LDE1MjYgTCAxMjExLDE1MTMgTCAxMjA4LDE0OTQgTCAxMjEwLDE0ODUgTCAxMjIwLDE0NjkgTCAxMjI5LDE0NjIgTCAxMjQwLDE0NTggTCAxMjQ4LDE0NTggTCAxMjU1LDE0NTggTCAxMjY2LDE0NjIgTCAxMjc1LDE0NjkgTCAxMjg1LDE0ODUgTCAxMjg3LDE0OTQgTCAxMjg0LDE1MTMgTCAxMjc3LDE1MjYgTCAxMjY2LDE1MzggTCAxMjkzLDE1MzYgTCAxMzA2LDE1MzkgTCAxMzE2LDE1NDUgTCAxMzI1LDE1NTQgTCAxMzI5LDE1NjMgTCAxMzMwLDE1ODQgTCAxMzIzLDE1OTkgTCAxMzEyLDE2MDkgTCAxMzAxLDE2MTQgTCAxMjg3LDE2MTUgTCAxMjY4LDE2MDggTCAxMjU4LDE1OTggTCAxMjUxLDE1ODIgTCAxMjUyLDE2MTYgTCAxMjU5LDE2MzggWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmY4YzM4IiBzdHJva2Utd2lkdGg9IjI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz4KCiAgPCEtLSBEb2xsYXIgY2lyY2xlIGF0IGNvbm5lY3RvciAzIC0tPgogIDxjaXJjbGUgY3g9IjEyNTUiIGN5PSI4NzUiIHI9IjkwIiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjhjMzgiIHN0cm9rZS13aWR0aD0iMjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIAoKICA8cGF0aCBkPSJNIDEyNDYsODUzIEMgMTI0OCw4NDUgMTIzNiw4NDAgMTIyNiw4NDAgQyAxMjE0LDg0MCAxMjA2LDg0NyAxMjA2LDg1NSBDIDEyMDYsODY1IDEyMTgsODcxIDEyMjgsODc1IEMgMTIzOCw4NzkgMTI1MCw4ODUgMTI1MCw4OTUgQyAxMjUwLDkwMyAxMjQyLDkxMCAxMjMwLDkxMCBDIDEyMjAsOTEwIDEyMDgsOTA1IDEyMTAsODk3IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjhjMzgiIHN0cm9rZS13aWR0aD0iMTYiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0gMTIyOCw4MjMgTCAxMjI4LDkyNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmY4YzM4IiBzdHJva2Utd2lkdGg9IjE2IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz4KICA8cGF0aCBkPSJNIDEzMDAsODUzIEMgMTMwMiw4NDUgMTI5MCw4NDAgMTI4MCw4NDAgQyAxMjY4LDg0MCAxMjYwLDg0NyAxMjYwLDg1NSBDIDEyNjAsODY1IDEyNzIsODcxIDEyODIsODc1IEMgMTI5Miw4NzkgMTMwNCw4ODUgMTMwNCw4OTUgQyAxMzA0LDkwMyAxMjk2LDkxMCAxMjg0LDkxMCBDIDEyNzQsOTEwIDEyNjIsOTA1IDEyNjQsODk3IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjhjMzgiIHN0cm9rZS13aWR0aD0iMTYiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0gMTI4Miw4MjMgTCAxMjgyLDkyNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmY4YzM4IiBzdHJva2Utd2lkdGg9IjE2IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz4KPC9zdmc+');background-repeat:no-repeat;background-position:center;background-size:contain;pointer-events:none;z-index:0;opacity:0.06;"></div>
        <!-- Firebase Cloud Sync Button -->
        <button id="firebase-sync-btn" onclick="handleSyncButton()"
                style="display:none; position:fixed; top:max(0.5rem, calc(env(safe-area-inset-top) + 0.3rem)); right:max(0.5rem, env(safe-area-inset-right)); z-index:999;
                       font-family:'Outfit',sans-serif; font-size:0.7rem; font-weight:700;
                       padding:0.4rem 0.8rem; border-radius:8px; border:none; cursor:pointer;
                       background:#ef4444; color:#fff;">
            ⚠ Sync Error
        </button>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <!-- Dashboard Stats Strip -->
            <div class="dashboard-stats-strip" id="dashboard-stats-strip">
                <div class="dash-stat-card">
                    <div class="dash-stat-number" id="dash-stat-players">0</div>
                    <div class="dash-stat-label">Players</div>
                </div>
                <div class="dash-stat-card">
                    <div class="dash-stat-number" id="dash-stat-qo-hands">0</div>
                    <div class="dash-stat-label">QO Hands</div>
                    <div class="dash-stat-sub" id="dash-stat-qo-players"></div>
                </div>
                <div class="dash-stat-card">
                    <div class="dash-stat-number" id="dash-stat-hh-hands">0</div>
                    <div class="dash-stat-label">Session Hands</div>
                    <div class="dash-stat-sub" id="dash-stat-hh-venue"></div>
                </div>
            </div>

            <!-- Global Search -->
            <div class="global-search-bar" id="global-search-bar">
                <svg class="global-search-icon" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                <input type="text" id="global-search-input" placeholder="Search players, observations, archetypes..." autocomplete="off" autocorrect="off" spellcheck="false">
                <button class="global-search-clear" id="global-search-clear" onclick="clearGlobalSearch()">✕</button>
                <div class="global-search-results" id="global-search-results"></div>
            </div>

            <div class="dashboard-grid">
                <button class="dashboard-btn" onclick="switchTab('players')">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                        <circle cx="12" cy="7" r="4"></circle>
                    </svg>
                    <span>Players</span>
                </button>
                
                <button class="dashboard-btn" onclick="switchTab('quick-obs')">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                    <span>Quick Obs</span>
                </button>
                
                <button class="dashboard-btn" onclick="switchTab('live-session')">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                    <span>Live Session</span>
                </button>
                
                <button class="dashboard-btn" onclick="switchTab('archetypes')">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                    <span>Archetypes</span>
                </button>
                
                <button class="dashboard-btn" onclick="switchTab('under-construction')">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M2 20h20"></path>
                        <path d="M5 20V8l7-5 7 5v12"></path>
                        <path d="M10 20v-4h4v4"></path>
                        <line x1="3" y1="3" x2="21" y2="21"></line>
                    </svg>
                    <span>Under Construction</span>
                </button>
            </div>
            
            <!-- Exit Button -->
            <div style="display: flex; justify-content: center; margin-top: 1.5rem; gap: 1rem; flex-wrap: wrap;">
                <!-- Admin Panel Button (only visible to admin) -->
                <button id="admin-dashboard-btn" class="dashboard-btn" onclick="switchTab('admin'); loadAccessRequests();" style="display:none; max-width:120px;">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                    </svg>
                    <span>Admin</span>
                </button>
            </div>

            <div style="display: flex; justify-content: center; margin-top: 1.5rem;">
                <button type="button" class="btn-metallic btn-exit" onclick="handleLogout()" title="Sign Out">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16 17 21 12 16 7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                </button>
            </div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; margin-top: 0.75rem;">
                <button onclick="manualSyncWithFeedback()" id="manual-sync-btn" style="display: inline-flex; align-items: center; gap: 6px; padding: 0.35rem 1rem; background: transparent; border: 1px solid rgba(141,196,240,0.3); border-radius: 20px; font-family: 'Outfit', sans-serif; font-size: 0.72rem; font-weight: 700; color: rgba(141,196,240,0.6); cursor: pointer; letter-spacing: 0.04em;">
                    <svg id="manual-sync-icon" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                    <span id="manual-sync-label">Sync Now</span>
                </button>
                <span id="last-sync-label" style="font-family: 'Outfit', sans-serif; font-size: 0.68rem; color: rgba(255,255,255,0.22); letter-spacing: 0.03em;">Not yet synced</span>
            </div>
            </div>
        </div>

        <!-- Archetypes Tab -->
        <div id="archetypes" class="tab-content">
            <div class="section">
                <div class="section-title">Archetypes</div>
                <div class="list-container" id="archetype-list"></div>
                <div style="display: flex; justify-content: center; margin-top: 0.75rem;">
                    <button id="arch-add-btn" onclick="showArchetypeForm()">+ New Archetype</button>
                </div>
            </div>

            <div class="section" id="archetype-form-section" style="display: none;">
                <div class="section-title" id="archetype-form-title">New Archetype</div>
                <form id="archetype-form">
                    <!-- Basic Info -->
                    <div class="form-group">
                        <label>Archetype Name *</label>
                        <input type="text" id="arch-name" placeholder="e.g., Scared Money, Calling Station" required>
                    </div>
                    
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="arch-description" placeholder="Brief description of this player type..."></textarea>
                    </div>

                    <!-- Persona Attributes -->
                    <div class="persona-section-divider collapsible" onclick="togglePersonaSection(this)">Persona Attributes</div>
                    <div class="persona-section-body">
                        <div id="arch-chip-dimensions">
                            <!-- Rendered by JS: renderArchFormDimensions() -->
                        </div>
                    </div>

                    <!-- Exploits -->
                    <div class="persona-section-divider collapsible" onclick="togglePersonaSection(this)">Exploitation Strategy</div>
                    <div class="persona-section-body">
                        <div class="form-group">
                            <label>Pre-flop Exploits (one per line)</label>
                            <textarea id="arch-exploits-preflop" placeholder="Steal blinds relentlessly - they fold 90%+
3-bet their rare raises for fold equity
Never cold call their raises without premium hands"></textarea>
                        </div>

                        <div class="form-group">
                            <label>Post-flop Exploits (one per line)</label>
                            <textarea id="arch-exploits-postflop" placeholder="C-bet 100% on all boards - they fold without connection
Double barrel if they call flop
Don't bluff river - if they called flop/turn they have something"></textarea>
                        </div>

                        <div class="form-group">
                            <label>Bubble Exploits (one per line)</label>
                            <textarea id="arch-exploits-bubble" placeholder="Apply maximum ICM pressure - they're paralyzed
Shove any two cards in late position vs their blinds
They'll fold medium pairs to avoid elimination"></textarea>
                        </div>

                        <div class="form-group">
                            <label>Warnings / Red Flags (one per line)</label>
                            <textarea id="arch-warnings" placeholder="If they limp then call a raise - trap with premium hand
If they lead out betting - strong hand, not bluffing
If they check-raise - nuts or very strong"></textarea>
                        </div>

                        <div class="form-group">
                            <label>Additional Notes</label>
                            <textarea id="arch-notes" placeholder="Any other observations about this archetype..."></textarea>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary" title="Save Archetype"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
                    <button type="button" class="btn btn-secondary" onclick="hideArchetypeForm()">Cancel</button>
                    <button type="button" class="btn btn-danger" onclick="deleteArchetype()" id="delete-archetype-btn" style="display: none;">Delete</button>
                </form>
            </div>

        </div>

        <!-- Players Tab -->
        <div id="players" class="tab-content">
            <!-- Combination Lock Player Picker -->
            <div class="combo-lock-frame">
                <div class="apple-picker-container" id="drum-container">
                    <div class="apple-picker-selection-bar"></div>
                    <div class="apple-picker-scroll">
                        <div class="drum-cylinder" id="player-picker">
                            <!-- Players will be populated here -->
                        </div>
                    </div>
                    <!-- Drum side ridges (grip texture) -->
                    <div class="drum-ridge drum-ridge-left"></div>
                    <div class="drum-ridge drum-ridge-right"></div>
                    <!-- Touch capture overlay — sits on top, captures all touches -->
                    <div class="drum-touch-overlay" id="drum-touch-overlay"></div>
                </div>
            </div>

            <div id="players-add-player-actions" style="display: flex; justify-content: center; margin-top: 0.6rem; margin-bottom: 0.5rem;">
                <button id="players-add-player-btn" onclick="showPlayerForm()">+ New Player</button>
            </div>

            <div class="section" id="player-form-section" style="display: none; margin-top: 1rem;">
                <div class="section-title" id="player-form-title">New Player</div>
                <form id="player-form">
                    <!-- Hidden field to store player name -->
                    <input type="hidden" id="player-name" required>

                    <div id="player-chip-dimensions">
                        <!-- Rendered by JS: renderPlayerDimensions() -->
                    </div>

                    <!-- Key Weaknesses -->
                    <div class="form-subsection notecard-section">
                        <h4 class="form-subsection-header">Key Weaknesses</h4>
                        <div class="notecard-layout">
                            <div class="notecard-display" id="player-weakness-display">
                                <div class="notecard-entries" id="player-weakness-list"></div>
                                <div class="notecard-actions">
                                    <button type="button" class="notecard-add-btn" id="weakness-add-btn" title="Add new">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <button type="button" class="notecard-edit-btn" id="weakness-edit-btn" title="Edit">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Observations -->
                    <div class="form-subsection notecard-section">
                        <h4 class="form-subsection-header">Observations</h4>
                        <div class="notecard-layout">
                            <div class="notecard-display" id="player-observation-display">
                                <div class="notecard-entries" id="player-observation-list"></div>
                                <div class="notecard-actions">
                                    <button type="button" class="notecard-add-btn" id="observation-add-btn" title="Add new">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <button type="button" class="notecard-edit-btn" id="observation-edit-btn" title="Edit">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <input type="hidden" id="player-observations" />
                    </div>

                    <!-- Hand History -->
                    <div class="form-subsection notecard-section" id="player-hand-history-section">
                        <h4 class="form-subsection-header">Hand History</h4>
                        <div class="notecard-layout">
                            <div class="notecard-display">
                                <div class="notecard-entries" id="player-hand-history-list">
                                    <div class="notecard-empty">No hands recorded for this player</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; justify-content: center; align-items: center; margin-top: 1.5rem; max-width: 400px; margin-left: auto; margin-right: auto;">
                        <button type="button" class="btn-metallic btn-delete" onclick="deletePlayer()" id="delete-player-btn" title="Delete Player" style="display: none;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Quick Player Observations Tab -->
        <div id="quick-obs" class="tab-content">
            <div class="section">
                <div class="section-title"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>Quick Player Observations</div>
                
                <!-- Player Selection — Drum Roller -->
                <div id="qo-drum-wrapper">
                    <div class="combo-lock-frame">
                        <div class="apple-picker-container" id="qo-drum-container">
                            <div class="apple-picker-selection-bar"></div>
                            <div class="apple-picker-scroll">
                                <div class="drum-cylinder" id="qo-player-drum"></div>
                            </div>
                            <div class="drum-ridge drum-ridge-left"></div>
                            <div class="drum-ridge drum-ridge-right"></div>
                            <div class="drum-touch-overlay" id="qo-drum-touch-overlay"></div>
                        </div>
                    </div>
                    <div id="qo-drum-actions">
                        <button id="qo-add-player-btn" onclick="qoAddNewPlayer()">+ New Player</button>
                    </div>
                </div>
                
                <!-- Collapsed player name (shown after selection) -->
                <div id="qo-player-collapsed" style="display: none; text-align: center; margin-bottom: 0.5rem;">
                    <span id="qo-player-collapsed-name" onclick="qoExpandDrum()" style="font-family: 'Outfit', sans-serif; font-size: 1.5rem; font-weight: 900; color: #ff8c38; cursor: pointer; display: inline-flex; align-items: center; gap: 8px;">
                        <span id="qo-player-collapsed-text"></span>
                        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="color: rgba(255,255,255,0.3);"><polyline points="6 9 12 15 18 9"></polyline></svg>
                    </span>
                </div>
                <!-- Hidden select kept for JS compat -->
                <select id="qo-player-select" style="display:none;" onchange="qoOnPlayerSelect()">
                    <option value="">Choose player...</option>
                </select>
                
                <!-- Running Stats Bar -->
                <div id="qo-stats-bar" style="display: none; text-align: center; font-family: 'Outfit', sans-serif; font-size: 0.8rem; font-weight: 700; padding: 0.5rem 0.75rem; margin-bottom: 0.75rem; background: rgba(22, 34, 62, 0.5); border: 1px solid rgba(255, 140, 56, 0.1); border-radius: 6px;"></div>
                
                <!-- Hand Tracker (hidden until player selected) -->
                <div id="qo-tracker" style="display: none;">
                
                    <!-- Hand Counter - prominent -->
                    <div style="text-align: center; margin-bottom: 1rem; padding: 0.6rem 0; border-bottom: 1px solid rgba(255,140,56,0.15);">
                        <span id="qo-hand-number" style="font-family: 'Outfit', sans-serif; font-size: 1.5rem; font-weight: 900; color: #ff8c38; cursor: pointer; text-decoration: underline; text-decoration-color: rgba(255,140,56,0.3); text-underline-offset: 4px; letter-spacing: 0.5px;" onclick="qoShowHandJumpMenu()">Hand #1</span>
                    </div>
                
                    <!-- Seat Selection -->
                    <div class="form-group slider-layout" style="align-items: flex-start; margin-bottom: 0.75rem;">
                        <label style="padding-top: 0.5rem; color: #ff8c38; font-weight: 800;">Seat</label>
                        <div style="flex: 1; display: flex; flex-wrap: wrap; gap: 6px;">
                            <div class="qo-seat-chip" data-position="SB" onclick="qoSelectPosition('SB', this)">SB</div>
                            <div class="qo-seat-chip" data-position="BB" onclick="qoSelectPosition('BB', this)">BB</div>
                            <div class="qo-seat-chip" data-position="UTG" onclick="qoSelectPosition('UTG', this)">UTG</div>
                            <div class="qo-seat-chip" data-position="MP" onclick="qoSelectPosition('MP', this)">MP</div>
                            <div class="qo-seat-chip" data-position="LP" onclick="qoSelectPosition('LP', this)">LP</div>
                            <div class="qo-seat-chip" data-position="D" onclick="qoSelectPosition('D', this)">D</div>
                        </div>
                    </div>
                    
                    <!-- Position (IP/OOP) -->
                    <div class="form-group slider-layout" style="align-items: flex-start; margin-bottom: 1rem;">
                        <label style="padding-top: 0.5rem; color: #ff8c38; font-weight: 800;">Position</label>
                        <div style="flex: 1; display: flex; flex-wrap: wrap; gap: 6px;">
                            <div class="qo-seat-chip" id="qo-ip-chip" data-ipoop="IP" onclick="qoOverrideIpOop('IP', this)">IP</div>
                            <div class="qo-seat-chip" id="qo-oop-chip" data-ipoop="OOP" onclick="qoOverrideIpOop('OOP', this)">OOP</div>
                        </div>
                    </div>
                    
                    <!-- Street Action Area -->
                    <div class="form-subsection" id="qo-streets-area">
                        <h4 class="form-subsection-header" style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="qo-street-label">Preflop</span>
                        </h4>
                        
                        <!-- Action Buttons -->
                        <div id="qo-action-buttons" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 0.75rem;"></div>
                    </div>
                    
                    <!-- Action Summary -->
                    <div class="form-subsection" id="qo-summary-area">
                        <h4 class="form-subsection-header">Action Summary</h4>
                        <div id="qo-action-log" style="min-height: 1.5rem; padding: 0.25rem 0;"></div>
                    </div>
                    
                    <!-- Notes -->
                    <div class="form-subsection">
                        <h4 class="form-subsection-header">Notes</h4>
                        <textarea id="qo-hand-notes" placeholder="Quick notes about this hand..." rows="2" style="width: 100%; padding: 8px; background: rgba(22, 34, 62, 0.6); border: 1px solid rgba(255, 140, 56, 0.12); border-radius: 6px; color: rgba(255, 255, 255, 0.85); font-family: 'Outfit', sans-serif; font-size: 0.85rem; resize: vertical; box-sizing: border-box;"></textarea>
                    </div>
                    
                    <!-- Navigation -->
                    <div style="display: flex; flex-direction: column; gap: 6px; align-items: center;">
                        <button id="qo-next-hand-btn" onclick="qoNextHand()" style="padding: 0.65rem 1.6rem; display: inline-flex; align-items: center; gap: 7px; background: linear-gradient(135deg, #8dc4f0 0%, #5a9fd4 100%); border: 2px solid #4a8abf; border-radius: 6px; font-family: 'Outfit', sans-serif; font-size: 0.9rem; font-weight: 700; color: #ffffff; cursor: pointer; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);">New <svg width="17" height="18" viewBox="0 0 20 22" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="12" x2="4" y2="4"/><line x1="9" y1="12" x2="9" y2="1"/><line x1="14" y1="12" x2="14" y2="1"/><line x1="19" y1="12" x2="19" y2="4"/><path d="M4 12 Q2 20 10 21 Q18 21 19 12"/></svg></button>
                        <div id="qo-last-hand-link" style="text-align: center; display: none;">
                            <span onclick="qoPreviousHand()" style="font-family: 'Outfit', sans-serif; font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.4); cursor: pointer; display:inline-flex; align-items:center; gap:3px;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>Last Hand</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Under Construction Tab -->
        <div id="under-construction" class="tab-content">
            <div class="section" style="text-align: center; padding: 2rem 1rem;">
                <div class="section-title" style="justify-content: center;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:6px;">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    Under Construction
                </div>
                <p style="opacity: 0.6; margin-bottom: 2rem; font-size: 0.85rem;">These modules are still being built. Tap to preview.</p>
                <div class="dashboard-grid">
                    <button class="dashboard-btn" onclick="switchTab('brief')">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                        <span>Pre-Game Brief</span>
                    </button>
                    <button class="dashboard-btn" onclick="switchTab('data')">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                            <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        </svg>
                        <span>Data</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Brief Tab -->
        <div id="brief" class="tab-content">
            <div class="section">
                <div class="section-title">Pre-Game Brief Generator</div>
                <div class="form-group">
                    <label>Select Players at Your Table</label>
                    <div id="brief-player-selection"></div>
                </div>
                <button class="btn btn-primary" onclick="generateBrief()">Generate Brief</button>
            </div>

            <div class="section" id="brief-output" style="display: none;">
                <div class="section-title"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>Your Pre-Game Brief</div>
                <div id="brief-content"></div>
            </div>
        </div>

        <!-- Data Tab -->
        <div id="data" class="tab-content">
            <div class="section">
                <div class="section-title">Import / Export Data</div>
                <div class="form-group">
                    <label>Export Database (JSON)</label>
                    <button class="btn btn-primary" onclick="exportData()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:3px;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>Download JSON</button>
                </div>
                <div class="form-group">
                    <label>Import Database (JSON)</label>
                    <input type="file" id="import-file" accept=".json">
                    <button class="btn btn-secondary" onclick="importData()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:3px;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>Upload JSON</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Current Database (JSON)</div>
                <pre id="json-display" style="background: rgba(0,0,0,0.3); padding: 1rem; border-radius: 8px; overflow-x: auto; max-height: 500px;"></pre>
            </div>
        </div>

        <!-- Live Session Tab -->
        <div id="live-session" class="tab-content">
            <div class="section">
                <div class="section-title"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>Live Session Notes</div>
                
                <!-- Tournament Info (Collapsible) -->
                <div class="form-subsection" id="tourney-info-subsection">
                    <h4 class="form-subsection-header" onclick="toggleTourneyInfo()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <span>Tournament Info</span>
                        <span id="tourney-toggle-icon" style="font-size: 0.8rem; color: rgba(255,255,255,0.5); transition: transform 0.2s;">▼</span>
                    </h4>
                    
                    <!-- Collapsed Summary -->
                    <div id="tourney-summary" style="display: none; padding: 0.4rem 0; cursor: pointer;" onclick="toggleTourneyInfo()">
                        <div id="tourney-summary-text" style="font-family: 'Outfit', sans-serif; font-size: 0.85rem; font-weight: 600; color: rgba(255,255,255,0.7); line-height: 1.6;"></div>
                    </div>
                    
                    <!-- Expanded Fields -->
                    <div id="tourney-fields">
                    <div class="form-group slider-layout">
                        <label>Buy-in</label>
                        <div style="flex: 1;">
                            <input type="text" id="session-buyin" class="session-info-input" placeholder="Enter buy-in amount" inputmode="numeric">
                            <span class="session-info-display hidden" id="session-buyin-display" onclick="editSessionField('buyin')"></span>
                        </div>
                    </div>

                    <div class="form-group slider-layout session-format-row">
                        <label>Format</label>
                        <div style="flex: 1;">
                            <div class="desc-selector" data-field="session-format" id="session-format-selector">
                                <button type="button" class="desc-chip active" data-value="0">1 Day</button>
                                <button type="button" class="desc-chip" data-value="1">Multi Day</button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group slider-layout">
                        <label>Blind Levels</label>
                        <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem;">
                            <input type="text" id="session-blind-minutes" class="session-info-input" placeholder="Minutes per level" inputmode="numeric">
                            <span class="session-info-display hidden" id="session-blindmin-display" onclick="editSessionField('blindmin')"></span>
                        </div>
                    </div>

                    <div class="form-group slider-layout">
                        <label>Starting Stack</label>
                        <div style="flex: 1;">
                            <input type="text" id="session-stack" class="session-info-input" placeholder="Starting chip count" inputmode="numeric">
                            <span class="session-info-display hidden" id="session-stack-display" onclick="editSessionField('stack')"></span>
                        </div>
                    </div>

                    <div class="form-group slider-layout">
                        <label>Venue</label>
                        <div style="flex: 1;">
                            <input type="text" id="session-venue" class="session-info-input" placeholder="Casino or venue name">
                            <span class="session-info-display hidden" id="session-venue-display" onclick="editSessionField('venue')"></span>
                        </div>
                    </div>

                    <div class="form-group slider-layout">
                        <label>Notes</label>
                        <div style="flex: 1;">
                            <input type="text" id="session-tournotes" class="session-info-input" placeholder="Tournament notes">
                            <span class="session-info-display hidden" id="session-tournotes-display" onclick="editSessionField('tournotes')"></span>
                        </div>
                    </div>
                    </div>
                </div>


                <!-- Hand History -->
                <div class="form-subsection">
                    <h4 class="form-subsection-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Hand History</span>
                        <span id="hh-hand-number" onclick="hhShowHandJumpMenu()" style="font-size: 1rem; color: #ff8c38; font-weight: 800; cursor: pointer; text-decoration: underline; text-decoration-color: rgba(255,140,56,0.3); text-underline-offset: 3px;">#1</span>
                    </h4>

                    <!-- Blind Level (inline layout) -->
                    <div class="form-group slider-layout" style="margin-bottom: 1rem; align-items: center;">
                        <label style="padding-top: 0;">Blind Level</label>
                        <div style="flex: 1; display: flex; flex-wrap: wrap; align-items: center; gap: 0.4rem; position: relative;">
                            <button class="btn-blind-nav" onclick="prevBlindLevel()" title="Previous Level"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                            <span id="blind-level-num" style="font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 700; color: #ff8c38; white-space: nowrap;">Level 1</span>
                            <span style="width: 1rem;"></span>
                            <span id="blind-level-values-display" onclick="editBlindLevel()" style="font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 600; color: rgba(255,255,255,0.9); cursor: pointer; white-space: nowrap; text-decoration: underline; text-decoration-color: rgba(255,140,56,0.3); text-underline-offset: 3px;">25 / 50 / 0</span>
                            <button class="btn-blind-nav" onclick="nextBlindLevel()" title="Next Level"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
                            <div class="blind-level-edit-row hidden" id="blind-level-edit-row" style="width: 100%; margin-top: 0.3rem;">
                                <input type="text" id="blind-sb-input" class="blind-edit-input" placeholder="SB" inputmode="numeric">
                                <span class="blind-edit-slash">/</span>
                                <input type="text" id="blind-bb-input" class="blind-edit-input" placeholder="BB" inputmode="numeric">
                                <span class="blind-edit-slash">/</span>
                                <input type="text" id="blind-ante-input" class="blind-edit-input" placeholder="Ante" inputmode="numeric">
                            </div>
                        </div>
                    </div>

                    <div class="hh-card-inner" id="hh-card-inner">
                        
                        <!-- Setup Card - all rows visible, matching tournament info layout -->
                        <div class="hh-setup-card" id="hh-setup-card">
                            <!-- Hero Group -->
                            <div style="border-left: 2px solid rgba(141,196,240,0.3); padding-left: 0.6rem; margin-bottom: 0.5rem;">
                            <!-- Hero -->
                            <div class="form-group slider-layout" id="hh-hero-select-row" style="align-items: center;">
                                <label style="color: #8dc4f0; padding-top: 0;">Hero</label>
                                <div style="flex: 1;">
                                    <select class="hh-select" id="hh-hero-select" onchange="hhOnHeroSelect()" style="width: 100%;">
                                        <option value="">Choose player...</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Hero Position -->
                            <div class="form-group slider-layout" id="hh-hero-position-row" style="align-items: center;">
                                <label style="color: #8dc4f0; padding-top: 0;">Position</label>
                                <div class="hh-pos-chips" id="hh-hero-pos-chips" style="display: flex; flex-wrap: wrap; gap: 4px;">
                                    <div class="hh-pos-chip" data-position="SB" onclick="hhSelectHeroPos('SB')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">SB</div>
                                    <div class="hh-pos-chip" data-position="BB" onclick="hhSelectHeroPos('BB')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">BB</div>
                                    <div class="hh-pos-chip" data-position="UTG" onclick="hhSelectHeroPos('UTG')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">UTG</div>
                                    <div class="hh-pos-chip" data-position="MP" onclick="hhSelectHeroPos('MP')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">MP</div>
                                    <div class="hh-pos-chip" data-position="HJ" onclick="hhSelectHeroPos('HJ')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">HJ</div>
                                    <div class="hh-pos-chip" data-position="CO" onclick="hhSelectHeroPos('CO')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">CO</div>
                                    <div class="hh-pos-chip" data-position="BTN" onclick="hhSelectHeroPos('BTN')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">D</div>
                                </div>
                            </div>
                            </div>

                            <!-- Villain Group -->
                            <div style="border-left: 2px solid rgba(255,167,38,0.3); padding-left: 0.6rem; margin-bottom: 0.5rem;">
                            <!-- Villain -->
                            <div class="form-group slider-layout" id="hh-villain-select-row" style="align-items: center;">
                                <label style="color: #ffa726; padding-top: 0;">Villain</label>
                                <div style="flex: 1;">
                                    <select class="hh-select" id="hh-villain-select" onchange="hhOnVillainSelect()" style="width: 100%;">
                                        <option value="">-- Generic --</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Villain Position -->
                            <div class="form-group slider-layout" id="hh-villain-position-row" style="align-items: center;">
                                <label style="color: #ffa726; padding-top: 0;">Position</label>
                                <div class="hh-pos-chips" id="hh-villain-pos-chips" style="display: flex; flex-wrap: wrap; gap: 4px;">
                                    <div class="hh-pos-chip" data-position="SB" onclick="hhSelectVillainPos('SB')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">SB</div>
                                    <div class="hh-pos-chip" data-position="BB" onclick="hhSelectVillainPos('BB')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">BB</div>
                                    <div class="hh-pos-chip" data-position="UTG" onclick="hhSelectVillainPos('UTG')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">UTG</div>
                                    <div class="hh-pos-chip" data-position="MP" onclick="hhSelectVillainPos('MP')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">MP</div>
                                    <div class="hh-pos-chip" data-position="HJ" onclick="hhSelectVillainPos('HJ')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">HJ</div>
                                    <div class="hh-pos-chip" data-position="CO" onclick="hhSelectVillainPos('CO')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">CO</div>
                                    <div class="hh-pos-chip" data-position="BTN" onclick="hhSelectVillainPos('BTN')" style="min-width: 30px; padding: 5px 8px; font-size: 12px;">D</div>
                                </div>
                            </div>
                            </div>

                            <!-- Hidden legacy elements for JS compatibility -->
                            <div id="hh-position-row" style="display: none;"></div>
                            <div id="hh-position-instruction" style="display: none;"></div>
                            <div id="hh-shared-pos-chips" style="display: none;"></div>
                            <div id="hh-setup-readonly" style="display: none;">
                                <span id="hh-readonly-hero"></span>
                                <span id="hh-readonly-position"></span>
                                <span id="hh-readonly-villain"></span>
                            </div>
                        </div>
                        
                        <!-- Community Board — all 5 cards -->
                        <div id="hh-community-board" style="display: none;">
                            <div class="cc-board-labels" id="cc-board-labels"></div>
                            <div class="cc-roller-panel" id="cc-roller-panel"></div>
                        </div>
                        
                        <!-- Street Actions Card -->
                        <div class="hh-street-card" id="hh-street-card" style="display: none;">
                            <div class="hh-street-header">
                                <div>
                                    <span id="hh-street-name" style="font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 800; font-variant: small-caps; color: rgba(255, 255, 255, 0.7);  letter-spacing: 0.05em;">PreFlop</span>
                                    <span class="hh-actor-name" id="hh-actor-display"></span>
                                </div>
                            </div>
                            
                            <div class="hh-action-grid" id="hh-action-buttons"></div>
                            
                            <div class="hh-amount-row" id="hh-amount-row">
                                <input type="text" class="hh-amount-input" id="hh-amount-input" placeholder="Amount" autocapitalize="off">
                                <button class="hh-next-btn" onclick="hhCommitCurrentAction()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
                            </div>
                            
                            <button class="hh-skip-street" onclick="hhSkipStreet()" style="margin-top: 12px; width: 100%; padding: 0.75rem; font-size: 0.875rem; display:inline-flex; align-items:center; justify-content:center; gap:6px;">Next Street <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
                            
                            <div class="hh-action-history" id="hh-action-history"></div>
                        </div>
                        
                        <!-- Showdown/Results Card -->
                        <div class="hh-street-card" id="hh-results-card" style="display: none;">
                            <div class="hh-street-header">
                                <div id="hh-results-title">Hand Complete</div>
                            </div>
                            
                            <div id="hh-hand-summary"></div>
                            
                            <div style="margin-top: 1rem;">
                                <label style="display: block; font-size: 13px; font-weight: 700; color: rgba(255, 255, 255, 0.85); margin-bottom: 8px;">Cards (if shown)</label>
                                <!-- Hidden inputs for compatibility with save/load -->
                                <input type="hidden" id="hh-hero-cards">
                                <input type="hidden" id="hh-villain-cards">
                                <div style="display: flex; gap: 12px; margin-bottom: 1rem; flex-wrap: wrap; justify-content: center;">
                                    <!-- Hero cards -->
                                    <div style="display: flex; flex-direction: column; align-items: center;">
                                        <span id="hh-hero-cards-label" class="cc-board-label-text" style="margin-bottom: 4px; color: #8dc4f0; background: none; -webkit-background-clip: unset; text-shadow: none; filter: none;">Hero</span>
                                        <div class="cc-roller-panel" id="hh-hero-roller-panel" style="margin: 0; padding: 8px 10px;"></div>
                                    </div>
                                    <!-- Villain cards -->
                                    <div style="display: flex; flex-direction: column; align-items: center;">
                                        <span id="hh-villain-cards-label" class="cc-board-label-text" style="margin-bottom: 4px; color: #ffa726; background: none; -webkit-background-clip: unset; text-shadow: none; filter: none;">Villain</span>
                                        <div class="cc-roller-panel" id="hh-villain-roller-panel" style="margin: 0; padding: 8px 10px;"></div>
                                    </div>
                                </div>
                                
                                <div class="form-group slider-layout" style="align-items: center; margin-bottom: 0;">
                                    <label style="padding-top: 0;">Winner</label>
                                    <div class="hh-position-toggle" style="margin-bottom: 0; flex: 1;">
                                        <div class="hh-toggle-btn" id="hh-winner-btn-hero" onclick="hhSetWinner('hero')">Hero</div>
                                        <div class="hh-toggle-btn" id="hh-winner-btn-villain" onclick="hhSetWinner('villain')">Villain</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Hand Notes (outside results card) -->
                        <div id="hh-notes-section" style="display: none; margin-top: 1rem;">
                            <label style="display: block; font-size: 13px; font-weight: 700; color: rgba(255, 255, 255, 0.85); margin-bottom: 6px;">Notes:</label>
                            <textarea id="hh-hand-notes" placeholder="Notes about this hand..." rows="2" style="width: 100%; padding: 8px; background: #2a2d35; border: 1px solid #3a3d45; border-radius: 4px; color: rgba(255, 255, 255, 0.85); font-family: 'Outfit', sans-serif; font-size: 0.875rem; resize: vertical;"></textarea>
                        </div>
                        
                        <!-- Hand Navigation (outside results card) -->
                        <div id="hh-navigation-section" style="display: none; margin-top: 1rem;">
                            <div class="hh-nav-row" style="display: flex; gap: 8px; align-items: stretch; margin-bottom: 0.5rem;">
                                <button class="hh-nav-btn" onclick="hhPreviousHand()" style="padding: 0.75rem 1rem; background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95)); border: 1px solid rgba(255, 140, 56, 0.12); border-radius: 6px; font-weight: 700; color: rgba(255, 255, 255, 0.85); cursor: pointer; font-size: 1.25rem; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.03);">‹</button>
                                <button onclick="hhNextHand()" style="flex: 1; padding: 0.75rem; background: linear-gradient(135deg, #8dc4f0 0%, #5a9fd4 100%); border: 2px solid #4a8abf; border-radius: 6px; font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 700; color: #ffffff; cursor: pointer; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);">+ New</button>
                                <button class="hh-nav-btn" onclick="hhNextStoredHand()" style="padding: 0.75rem 1rem; background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95)); border: 1px solid rgba(255, 140, 56, 0.12); border-radius: 6px; font-weight: 700; color: rgba(255, 255, 255, 0.85); cursor: pointer; font-size: 1.25rem; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.03);">›</button>
                            </div>
                            <div style="text-align: center; display: flex; justify-content: center; gap: 1.5rem;">
                                <a href="#" onclick="hhNextHandDifferentPlayers(); return false;" style="font-family: 'Outfit', sans-serif; font-size: 0.8rem; font-weight: 600; color: rgba(255, 255, 255, 0.5); text-decoration: underline; text-underline-offset: 3px;">Reset Players</a>
                                <a href="#" id="hh-edit-hand-link" onclick="hhEditViewedHand(); return false;" style="display: none; font-family: 'Outfit', sans-serif; font-size: 0.8rem; font-weight: 600; color: rgba(141,196,240,0.7); text-decoration: underline; text-underline-offset: 3px;">Edit Hand</a>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Admin Panel Tab (only accessible by admin) -->
        <div id="admin" class="tab-content">
            <div class="section">
                <div class="section-title"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>Admin Panel</div>

                <div class="admin-stats" id="admin-stats">
                    <!-- Filled by JS -->
                </div>

                <div class="form-subsection">
                    <h4 class="form-subsection-header">Access Requests</h4>
                    <div id="admin-requests-list">
                        <div style="text-align:center;color:#888;padding:1rem;">Loading...</div>
                    </div>
                </div>

                <div style="margin-top:1.5rem;">
                    <button class="btn-metallic" onclick="loadAccessRequests()" style="width:100%;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:3px;"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>Refresh</button>
                </div>

                <!-- User Data Browser -->
                <div class="form-subsection" style="margin-top:1.5rem;">
                    <h4 class="form-subsection-header">User Data Browser</h4>
                    <div id="admin-user-list">
                        <div style="text-align:center;color:#888;padding:1rem;">
                            <button class="btn-metallic" onclick="loadAllUserVaults()" style="width:100%;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:3px;"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>Load User Data</button>
                        </div>
                    </div>
                </div>

                <!-- User Data Viewer (hidden until a user is selected) -->
                <div id="admin-user-viewer" style="display:none;">
                    <div class="form-subsection" style="margin-top:1rem;">
                        <h4 class="form-subsection-header">
                            <span id="admin-viewer-title">Player Data</span>
                            <button class="btn-deny" onclick="closeUserViewer()" style="float:right;font-size:0.7rem;padding:0.3rem 0.6rem;">✕ Close</button>
                        </h4>
                        <div id="admin-viewer-stats" class="admin-stats" style="margin-bottom:0.75rem;"></div>
                        <div id="admin-user-players-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Database structure
        let database = {
            archetypes: [],
            realPlayers: []
        };

        // Load from localStorage or use default
        const PLAYER_DIM_KEYS = [
            'vpip','limpBehavior','coldcall','openEP','openLP',
            'pfrAggression','threeBetProfile','fold3bet',
            'flopStrategy','foldcbet','postflopAggression','turnBehavior','riverBehavior',
            'shortStack','midStack','deepStack',
            'tableTalk','attention','cunning','thinking',
            'tiltProfile','afterLoss','tanking','physicalConfidence',
            'stackProtection','bubbleBehavior','finalTableAdj','payJumpAwareness','skillLevel',
            'gender','age','ethnicity','education','profession'
        ];

        function loadDatabase() {
            const saved = localStorage.getItem('pokerDatabase');
            if (saved) {
                database = JSON.parse(saved);
                // Ensure required arrays always exist even if JSON was partial
                if (!database.realPlayers) database.realPlayers = [];
                if (!database.archetypes) database.archetypes = [];
                // One-time migration: set all dimension fields to null if not yet migrated
                if (!database._dimNullMigrated) {
                    database.realPlayers.forEach(function(p) {
                        PLAYER_DIM_KEYS.forEach(function(k) { p[k] = null; });
                    });
                    database._dimNullMigrated = true;
                    localStorage.setItem('pokerDatabase', JSON.stringify(database));
                }
            } else {
                // Initialize with player list - all attributes default to 0
                const playerNames = [
                    "Aditya Pailla", "Allen Chapman", "Arlo Strozewski", "Ash Gandhi", "Becky Anderson",
                    "Bee Yang", "Bob Tumlinson", "Bob Van Sykle", "Brian Granger", "Carson Mair",
                    "Chandra Kontham", "Charles Lewis", "Charles Wiggins", "Chogyal Tenzin", "Cody Torke",
                    "Curtis Koenig", "Curtis Vierstrate", "Dad Daughter", "Dallas Schmidt", "Dan Kennedy",
                    "Daniel Hutchinson", "Darshan Pathak", "Dhruva Kota", "E", "Erik Elkema",
                    "Gene Boyer", "Hank Blissenblak", "Jason Alexander", "Jason Sell", "Jeff Petronak",
                    "Jeremy Calvelry", "Jerric Jiang", "John Reading", "Jon Kim", "Jos Osterbaur Jr.",
                    "Jos Osterbaur Sr.", "Joseph Casey Pothead", "Kanat Ozturk", "Kevin Kelly", "Kou Vang",
                    "Leo Fussy", "Leo Pinomonti", "Libby", "Louie Hillman", "Lucas Martin",
                    "Luke Struck", "Mason Redberg-Berg", "Matt Alexander", "Matt Fox", "Mike Wang",
                    "Mike Wilklow", "Moon", "Nghia Lee", "Paul Cross", "Paul Eiden",
                    "Phil Nesburg", "Rich Alsup", "Rob Wazwaz", "Rodney Colson", "Ross \"RF\"",
                    "Sam B", "Santoshima Narayan", "Sean Hinton", "Shafat Zaman", "Sitaram",
                    "Steve Belland", "Steve Wazwaz", "Steven Shanks", "Tanner Pray", "Thai Van Dinh",
                    "Tim Votva", "Tyreese Robinson", "Umut Ozturk", "Vic Peppe", "Vijay Yadav",
                    "Wes Cannon"
                ];

                // Create player objects with all dimension attributes null (unassessed)
                const players = playerNames.map(name => {
                    const p = { name: name, observationsList: [], weaknesses: [] };
                    PLAYER_DIM_KEYS.forEach(function(k) { p[k] = null; });
                    return p;
                });

                // Load default database with players
                database = {
                    archetypes: [],
                    realPlayers: players
                };
                
                // Save to localStorage
                saveDatabase();
            }
            seedPersonas();
            updateAllViews();
        }

        function saveDatabase() {
            // Sort players alphabetically by name before saving
            database.realPlayers.sort((a, b) => a.name.localeCompare(b.name));
            localStorage.setItem('pokerDatabase', JSON.stringify(database));
            updateAllViews();
            saveToFirebase();
        }

        // Toggle switch status updates
        document.querySelectorAll('.toggle-switch input[type="checkbox"]').forEach(toggle => {
            toggle.addEventListener('change', function() {
                const status = this.closest('.toggle-container').querySelector('.toggle-status');
                if (status) {
                    status.textContent = this.checked ? 'Yes' : 'No';
                }
            });
            
            // Set initial state
            const status = toggle.closest('.toggle-container').querySelector('.toggle-status');
            if (status) {
                status.textContent = toggle.checked ? 'Yes' : 'No';
            }
        });

        // ========== CUSTOM MODAL SYSTEM ==========
        function nwModal(opts) {
            // opts: { message, type:'alert'|'confirm'|'prompt', placeholder, defaultValue, danger }
            return new Promise(function(resolve) {
                var overlay = document.createElement('div');
                overlay.className = 'nw-modal-overlay';
                var modal = document.createElement('div');
                modal.className = 'nw-modal';

                var msg = document.createElement('div');
                msg.className = 'nw-modal-message';
                msg.textContent = opts.message || '';
                modal.appendChild(msg);

                var input = null;
                if (opts.type === 'prompt') {
                    input = document.createElement('input');
                    input.className = 'nw-modal-input';
                    input.type = 'text';
                    input.placeholder = opts.placeholder || '';
                    input.value = opts.defaultValue || '';
                    input.setAttribute('autocomplete', 'off');
                    input.setAttribute('autocorrect', 'off');
                    input.setAttribute('spellcheck', 'false');
                    modal.appendChild(input);
                }

                var btnRow = document.createElement('div');
                btnRow.className = 'nw-modal-buttons';

                function close(val) {
                    overlay.classList.remove('visible');
                    setTimeout(function() { overlay.remove(); }, 160);
                    resolve(val);
                }

                if (opts.type === 'alert') {
                    var ok = document.createElement('button');
                    ok.className = 'nw-modal-btn confirm';
                    ok.textContent = 'OK';
                    ok.onclick = function() { close(true); };
                    btnRow.appendChild(ok);
                } else {
                    var cancel = document.createElement('button');
                    cancel.className = 'nw-modal-btn cancel';
                    cancel.textContent = 'Cancel';
                    cancel.onclick = function() { close(opts.type === 'prompt' ? null : false); };
                    btnRow.appendChild(cancel);

                    var yes = document.createElement('button');
                    yes.className = 'nw-modal-btn ' + (opts.danger ? 'danger' : 'confirm');
                    yes.textContent = opts.confirmLabel || (opts.type === 'prompt' ? 'OK' : 'Confirm');
                    yes.onclick = function() {
                        close(opts.type === 'prompt' ? (input.value || '') : true);
                    };
                    btnRow.appendChild(yes);
                }

                modal.appendChild(btnRow);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Animate in
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        overlay.classList.add('visible');
                    });
                });

                // Focus input or confirm button
                setTimeout(function() {
                    if (input) { input.focus(); input.select(); }
                    else if (btnRow.lastChild) btnRow.lastChild.focus();
                }, 180);

                // Enter key support
                if (input) {
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') { e.preventDefault(); close(input.value || ''); }
                        if (e.key === 'Escape') { e.preventDefault(); close(null); }
                    });
                }

                // Tap overlay to cancel (for confirms/prompts) or dismiss (for alerts)
                overlay.addEventListener('click', function(e) {
                    if (e.target === overlay) {
                        close(opts.type === 'alert' ? true : (opts.type === 'prompt' ? null : false));
                    }
                });
            });
        }

        function nwAlert(message) { return nwModal({ message: message, type: 'alert' }); }
        function nwConfirm(message, danger) { return nwModal({ message: message, type: 'confirm', danger: !!danger }); }
        function nwPrompt(message, placeholder, defaultValue) { return nwModal({ message: message, type: 'prompt', placeholder: placeholder || '', defaultValue: defaultValue || '' }); }

        // Tab switching
        function switchTab(tabName) {
            // Save session state before switching
            if (!_isRestoring && _userInitiated) saveHandHistory();
            
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabName).classList.add('active');
            
            // Update bottom nav active state
            const navMap = {
                'dashboard': 'bnav-dashboard',
                'players': 'bnav-players',
                'quick-obs': 'bnav-quick-obs',
                'live-session': 'bnav-live-session',
                'archetypes': 'bnav-archetypes'
            };
            document.querySelectorAll('.bnav-btn').forEach(b => b.classList.remove('active'));
            const activeNavId = navMap[tabName];
            if (activeNavId) {
                const activeBtn = document.getElementById(activeNavId);
                if (activeBtn) activeBtn.classList.add('active');
            }
            
            // Scroll to top on tab switch (native behavior)
            window.scrollTo({ top: 0, behavior: 'instant' });
            
            // Populate quick-obs player drum when entering that tab
            if (tabName === 'quick-obs') qoPopulateDropdown();
            
            // Auto-collapse tourney info when entering live-session if fields have data
            if (tabName === 'live-session') {
                setTimeout(function() {
                    try {
                        var hasData = false;
                        ['session-buyin','session-stack','session-blind-minutes','session-venue','session-tournotes'].forEach(function(id) {
                            var el = document.getElementById(id);
                            if (el && el.dataset.rawValue) hasData = true;
                        });
                        if (hasData && !tourneyInfoCollapsed) toggleTourneyInfo();
                    } catch(e) {}
                }, 50);
            }
            
            updateAllViews();
        }

        // Update all views
        function updateAllViews() {
            updateDashboard();
            updateArchetypeList();
            updatePlayerList();
            updatePlayerArchetypeDropdown();
            updateBriefPlayerSelection();
            updateJsonDisplay();
            if (typeof qoDrumPopulate === 'function') qoDrumPopulate();
            if (typeof hhPopulatePlayerDropdown === 'function') hhPopulatePlayerDropdown();
        }

        // Dashboard — Stats Strip (#1)
        function updateDashboard() {
            // Player count
            var playerCount = database.realPlayers ? database.realPlayers.length : 0;
            var el = document.getElementById('dash-stat-players');
            if (el) el.textContent = playerCount;

            // QO hands: total across all players, and how many players have QO data
            var totalQoHands = 0;
            var qoPlayerCount = 0;
            if (database.realPlayers) {
                database.realPlayers.forEach(function(p) {
                    if (p.quickObs && p.quickObs.length > 0) {
                        totalQoHands += p.quickObs.length;
                        qoPlayerCount++;
                    }
                });
            }
            var qoEl = document.getElementById('dash-stat-qo-hands');
            if (qoEl) qoEl.textContent = totalQoHands;
            var qoSubEl = document.getElementById('dash-stat-qo-players');
            if (qoSubEl) qoSubEl.textContent = qoPlayerCount > 0 ? qoPlayerCount + ' player' + (qoPlayerCount > 1 ? 's' : '') : '';

            // Session hands from live session hand history
            var hhCount = (typeof hhStoredHands !== 'undefined' && hhStoredHands) ? hhStoredHands.length : 0;
            var hhEl = document.getElementById('dash-stat-hh-hands');
            if (hhEl) hhEl.textContent = hhCount;
            var hhSubEl = document.getElementById('dash-stat-hh-venue');
            if (hhSubEl) {
                var venueEl = document.getElementById('session-venue');
                var venueVal = '';
                if (venueEl) venueVal = venueEl.dataset.rawValue || venueEl.value || '';
                hhSubEl.textContent = venueVal ? venueVal : '';
            }
        }

        // ========== GLOBAL SEARCH (#2) ==========
        (function initGlobalSearch() {
            // Wait for DOM
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', _wireSearch);
            } else {
                _wireSearch();
            }
            function _wireSearch() {
                var input = document.getElementById('global-search-input');
                var results = document.getElementById('global-search-results');
                var clearBtn = document.getElementById('global-search-clear');
                if (!input || !results) return;

                var debounceTimer = null;
                input.addEventListener('input', function() {
                    clearTimeout(debounceTimer);
                    var q = input.value.trim();
                    if (clearBtn) clearBtn.style.display = q.length > 0 ? 'block' : 'none';
                    if (q.length < 2) {
                        results.classList.remove('visible');
                        results.innerHTML = '';
                        return;
                    }
                    debounceTimer = setTimeout(function() { runGlobalSearch(q); }, 150);
                });

                // Close results on outside click
                document.addEventListener('click', function(e) {
                    var bar = document.getElementById('global-search-bar');
                    if (bar && !bar.contains(e.target)) {
                        results.classList.remove('visible');
                    }
                });

                // Re-show results on focus if there's a query
                input.addEventListener('focus', function() {
                    if (input.value.trim().length >= 2 && results.innerHTML) {
                        results.classList.add('visible');
                    }
                });
            }
        })();

        function clearGlobalSearch() {
            var input = document.getElementById('global-search-input');
            var results = document.getElementById('global-search-results');
            var clearBtn = document.getElementById('global-search-clear');
            if (input) { input.value = ''; input.focus(); }
            if (results) { results.innerHTML = ''; results.classList.remove('visible'); }
            if (clearBtn) clearBtn.style.display = 'none';
        }

        function runGlobalSearch(query) {
            var results = document.getElementById('global-search-results');
            if (!results) return;
            var q = query.toLowerCase();
            var items = [];

            // Search players
            if (database.realPlayers) {
                database.realPlayers.forEach(function(p) {
                    var score = 0;
                    var meta = [];
                    if (p.name && typeof p.name === 'string' && p.name.toLowerCase().indexOf(q) >= 0) score += 10;
                    if (p.observations && typeof p.observations === 'string' && p.observations.toLowerCase().indexOf(q) >= 0) {
                        score += 5;
                        meta.push('observations match');
                    }
                    if (p.weaknesses && typeof p.weaknesses === 'string' && p.weaknesses.toLowerCase().indexOf(q) >= 0) {
                        score += 5;
                        meta.push('weaknesses match');
                    }
                    // Search QO notes
                    if (p.quickObs) {
                        var qoMatch = false;
                        p.quickObs.forEach(function(h) {
                            if (h.notes && h.notes.toLowerCase().indexOf(q) >= 0) qoMatch = true;
                        });
                        if (qoMatch) { score += 3; meta.push('QO notes match'); }
                    }
                    // Search archetype name
                    if (p.archetypeId) {
                        var arch = database.archetypes ? database.archetypes.find(function(a) { return a.id === p.archetypeId; }) : null;
                        if (arch && arch.name && arch.name.toLowerCase().indexOf(q) >= 0) {
                            score += 4;
                            meta.push(arch.name);
                        }
                    }
                    if (score > 0) {
                        var qoCount = (p.quickObs && p.quickObs.length) || 0;
                        var metaStr = qoCount > 0 ? qoCount + ' QO hands' : 'No QO data';
                        if (meta.length > 0) metaStr += ' · ' + meta[0];
                        items.push({ type: 'player', name: p.name, meta: metaStr, score: score });
                    }
                });
            }

            // Search archetypes (non-persona user archetypes)
            if (database.archetypes) {
                database.archetypes.forEach(function(a) {
                    if (a.isPersona) return; // skip built-in personas
                    var score = 0;
                    if (a.name && a.name.toLowerCase().indexOf(q) >= 0) score += 8;
                    if (a.description && a.description.toLowerCase().indexOf(q) >= 0) score += 4;
                    if (score > 0) {
                        items.push({ type: 'archetype', name: a.name, meta: a.description || '', score: score });
                    }
                });
            }

            // Also search built-in personas by name
            if (typeof BUILTIN_PERSONAS !== 'undefined') {
                BUILTIN_PERSONAS.forEach(function(p) {
                    if (p.name && p.name.toLowerCase().indexOf(q) >= 0) {
                        items.push({ type: 'archetype', name: p.name, meta: p.description || 'Built-in persona', score: 6, isPersona: true, personaId: p.id });
                    }
                });
            }

            // Sort by score descending
            items.sort(function(a, b) { return b.score - a.score; });

            // Limit to 10 results
            items = items.slice(0, 10);

            if (items.length === 0) {
                results.innerHTML = '<div class="search-no-results">No results for "' + _escHtml(query) + '"</div>';
                results.classList.add('visible');
                return;
            }

            var html = '';
            items.forEach(function(item) {
                var iconSvg = item.type === 'player'
                    ? '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>'
                    : '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>';
                var highlighted = _highlightMatch(item.name, query);
                html += '<div class="search-result-item" onclick="searchResultTap(\'' + _escAttr(item.type) + '\', \'' + _escAttr(item.name) + '\')">';
                html += '<div class="search-result-icon"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">' + iconSvg + '</svg></div>';
                html += '<div class="search-result-text">';
                html += '<div class="search-result-name">' + highlighted + '</div>';
                if (item.meta) html += '<div class="search-result-meta">' + _escHtml(item.meta) + '</div>';
                html += '</div>';
                html += '<span class="search-result-badge ' + item.type + '">' + item.type + '</span>';
                html += '</div>';
            });
            results.innerHTML = html;
            results.classList.add('visible');
        }

        function searchResultTap(type, name) {
            var results = document.getElementById('global-search-results');
            var input = document.getElementById('global-search-input');
            if (results) results.classList.remove('visible');
            if (input) input.blur();

            if (type === 'player') {
                // Switch to players tab and select the player
                switchTab('players');
                // Find and select in drum picker
                setTimeout(function() {
                    if (typeof DRUM !== 'undefined' && DRUM.items) {
                        var idx = DRUM.items.indexOf(name);
                        if (idx >= 0) {
                            DRUM.selectedIndex = idx;
                            DRUM.targetY = -idx * DRUM.ITEM_H;
                            DRUM.currentY = DRUM.targetY;
                            DRUM._render();
                            DRUM._onSelect(idx);
                        }
                    }
                }, 200);
            } else if (type === 'archetype') {
                switchTab('archetypes');
            }
        }

        function _escHtml(str) {
            var div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function _escAttr(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        function _highlightMatch(text, query) {
            var lc = text.toLowerCase();
            var qlc = query.toLowerCase();
            var idx = lc.indexOf(qlc);
            if (idx < 0) return _escHtml(text);
            var before = text.substring(0, idx);
            var match = text.substring(idx, idx + query.length);
            var after = text.substring(idx + query.length);
            return _escHtml(before) + '<mark>' + _escHtml(match) + '</mark>' + _escHtml(after);
        }

        // Archetypes
        let currentArchetypeId = null;

        // === BUILT-IN PERSONAS (from NitWiz Field Guide) ===
        const BUILTIN_PERSONAS = [
            {
                id: 'persona-momentum-mayor',
                name: 'The Momentum Mayor',
                isPersona: true,
                description: 'Passive OOP • Limp-Heavy • Price-Sensitive River Regular',
                persona: {
                    subtitle: '$100-$250 daily regular. VPIP ~70-80%. Builds early stacks via volume + variance. Rarely converts consistently.',
                    coreProfile: 'Limp-heavy all positions. Raises only big Ax / pocket pairs. Check-calls OOP (rarely stabs). Over-calls turn. River = price sensitive.',
                    // Dimension values matching Player section selectors
                    dimensions: {
                        preflop: { vpip: 2, limpBehavior: 1, coldcall: 2, openEP: 2, openLP: 2, pfrAggression: 0, threeBetProfile: 0, fold3bet: 0 },
                        postflop: { flopStrategy: 3, foldcbet: 0, postflopAggression: 0, turnBehavior: 3, riverBehavior: 0 },
                        stackpressure: { shortStack: 2, midStack: 3, deepStack: 2 },
                        dynamics: { tableTalk: 1, attention: 1, cunning: 2, thinking: 0, tiltProfile: 2, afterLoss: 1, tanking: 0, physicalConfidence: 0 },
                        awareness: { stackProtection: 0, bubbleBehavior: 2, finalTableAdj: 2, payJumpAwareness: 2, skillLevel: 0 },
                        styleToggles: { tglChasesDraws: 1, tglLimpAny: 1, tglFaceCards: 1, tglRiverCheap: 1, tglLimpCall: 1, tglNoStackDepth: 1 },
                        psychToggles: { tglResultOriented: 1 }
                    },
                    streets: {
                        preflop: {
                            dos: ['Iso large (4-6x)', 'Value 3-bet linear', 'Attack his blinds relentlessly', 'Play hands that dominate limp range'],
                            donts: ['Overlimp behind weak holdings', 'Slowplay premiums', 'Flat too much OOP', 'Assume his raise range is balanced'],
                            note: 'His raise range is strong and narrow.'
                        },
                        flop: {
                            dos: ['C-bet frequently', 'Value bet thin', 'Barrel strong draws', 'Bet normal sizing (he calls anyway)'],
                            donts: ['Over-check back marginal value', 'Expect folds from small stabs', 'Bluff multi-way without equity'],
                            note: 'Key Leak: Over-Calling. He is elastic here.'
                        },
                        turn: {
                            dos: ['Barrel aggressively', 'Semi-bluff confidently', 'Increase pressure on scare cards', 'Start polarizing ranges'],
                            donts: ['Shut down too early', 'Assume his call means strength', 'Play pot-control too much'],
                            note: 'HIGHEST EV NODE. His turn call is often automatic, not strong.'
                        },
                        river: {
                            dos: ['Use two distinct sizings', 'Polarize large bets', 'Extract thin value small'],
                            donts: ['Use medium "confused" sizing', 'Try fancy thin bluff-catching', 'Overestimate his river aggression'],
                            note: 'He folds to big bets. He calls small bets with pairs. He raises 2P+.'
                        }
                    },
                    stackMatrix: [
                        { stack: '60-100bb', adjust: 'Barrel turns heavily' },
                        { stack: '30-50bb', adjust: 'Increase isolation frequency' },
                        { stack: '15-25bb', adjust: 'Rejam wider vs opens' },
                        { stack: '<15bb', adjust: 'Jam linear vs limps; call tight' }
                    ],
                    riverSizing: [
                        { holding: 'Marginal value', strategy: 'Bet small (30-40%)' },
                        { holding: 'Air', strategy: 'Bet large (70%+)' },
                        { holding: 'Strong value', strategy: 'Medium-large' },
                        { holding: 'Bluff catcher', strategy: 'Usually fold vs big bet' }
                    ],
                    postCooler: 'Minor change — same exploit applies.',
                    ftDanger: 'Low — structural leaks persist.',
                    quote: 'Build pots early, apply pressure on turns, polarize rivers, and never pay off strength.',
                    leakType: 'Structural',
                    shortcut: 'Over-calls early streets, folds big rivers → Momentum Mayor'
                },
                playStyle: { preflop: { vpip: 'High (>50%)', pfr: 'Low (<25%)' } },
                exploits: {
                    preflop: ['Iso large (4-6x)', 'Value 3-bet linear', 'Attack blinds relentlessly'],
                    warnings: ['His raise range is strong and narrow', 'He raises 2P+ on river — respect it', 'Don\'t slowplay premiums against him']
                }
            },
            {
                id: 'persona-campaigner',
                name: 'The Campaigner',
                isPersona: true,
                description: 'Volatility-Tolerant Accumulator • Selective Discipline • Aggression-First',
                persona: {
                    subtitle: 'Finance background. Fires 5-7 bullets per Day 1. Frequently top 20%. Often makes Day 2.',
                    coreProfile: 'Limp/call wide — including iso raises. Escalates with strength. Folds misses on flop. Polar turn bets. Ego-triggered volatility. AK/AQ stack-off at any depth.',
                    dimensions: {
                        preflop: { vpip: 2, limpBehavior: 0, coldcall: 2, openEP: 1, openLP: 2, pfrAggression: 1, threeBetProfile: 1, fold3bet: 3 },
                        postflop: { flopStrategy: 1, foldcbet: 2, postflopAggression: 1, turnBehavior: 1, riverBehavior: 0 },
                        stackpressure: { shortStack: 0, midStack: 2, deepStack: 0 },
                        dynamics: { tableTalk: 2, attention: 1, cunning: 1, thinking: 1, tiltProfile: 1, afterLoss: 1, tanking: 1, physicalConfidence: 0 },
                        awareness: { stackProtection: 1, bubbleBehavior: 1, finalTableAdj: 1, payJumpAwareness: 1, skillLevel: 1 },
                        styleToggles: { tglChasesDraws: 1 },
                        psychToggles: { tglEgoDriven: 1, tglRecklessPressure: 1 }
                    },
                    streets: {
                        preflop: {
                            dos: ['Raise larger over limps (expect calls)', 'C-bet very high frequency', 'Print one-and-done pots', 'Fold marginal hands to huge turn bets'],
                            donts: ['Play ego pots', '4-bet bluff light', 'Assume limp = weak', 'Triple barrel air (he folds flop, not river)'],
                            note: 'He is preflop curious, not postflop sticky.'
                        },
                        flop: {
                            dos: ['C-bet high frequency', 'Print one-and-done pots', 'Value bet when checked to'],
                            donts: ['Run multi-street bluffs', 'Expect sticky calls on misses', 'Bluff into his strength'],
                            note: 'Folds when he whiffs. Not a sticky floater.'
                        },
                        turn: {
                            dos: ['Fold marginal to massive overbets', 'Recognize huge upsize = 2P+', 'Value bet confidently'],
                            donts: ['Hero-call huge turn sizing', 'Assume polar turn bet is balanced', 'Ignore his sizing tells'],
                            note: 'His turn sizing is transparent. Huge upsize = 2P+.'
                        },
                        river: {
                            dos: ['Value bet confidently (he hero-calls)', 'Let him escalate ego pots when you\'re strong'],
                            donts: ['Big pure bluffs (he hero-calls large)', 'Triple barrel air', 'Engage in pride wars'],
                            note: 'Hero-calls large bets. Capable of selective bluffs. Pride spots matter.'
                        }
                    },
                    modes: [
                        { name: 'Accumulation (Default)', desc: 'Limp/call wide, escalates with strength, folds misses, ego-triggered volatility' },
                        { name: 'Capital Protection (Big Stack)', desc: 'Fewer marginal calls, less ego escalation, more pot control, selective aggression' },
                        { name: 'Stabilized (Rare / FT)', desc: 'Reduces ego involvement, controls pot size, respects ICM. Observe first 2 orbits.' }
                    ],
                    stackMatrix: [
                        { stack: 'Early', adjust: 'Very exploitable via flop c-bets' },
                        { stack: 'Mid', adjust: 'Polar turn bets still reliable strength indicator' },
                        { stack: 'FT (Volatile)', adjust: 'Self-eliminating — low danger' },
                        { stack: 'FT (Stabilized)', adjust: 'Medium-High danger — treat closer to Accountant' }
                    ],
                    postCooler: 'Aggression spike — let him overextend. Short-term tilt, can torch stack.',
                    ftDanger: 'Medium — ego can disrupt. If stabilized, Medium-High.',
                    quote: 'A volatility-tolerant accumulator who defaults to aggression but can temporarily stabilize under high-leverage conditions.',
                    leakType: 'Emotional (Ego)',
                    shortcut: 'Folds flop misses, polarizes turn, hero-calls rivers → The Campaigner'
                },
                playStyle: { preflop: { vpip: 'High (>50%)', pfr: 'Med (25-50%)' } },
                exploits: {
                    preflop: ['C-bet very high frequency', 'Print one-and-done pots', 'Fold to huge turn overbets'],
                    warnings: ['AK/AQ = no fear stacking at any depth', 'Huge turn sizing = 2P+ (transparent)', 'Hero-calls large river bets — don\'t bluff big']
                }
            },
            {
                id: 'persona-banker',
                name: 'The Banker',
                isPersona: true,
                description: 'Technically Competent • Ego-Triggered Aggressor • Capital Allocator',
                persona: {
                    subtitle: 'Former investment banker. Financially secure. Plays poker like capital markets. Allocates risk. Escalates when challenged.',
                    coreProfile: 'Opens suited connectors IP. Raises premiums standard. 4-bet bluffs selectively. Open jams rationally short. Takes marginal flips when +EV. Not splashy — structured.',
                    dimensions: {
                        preflop: { vpip: 1, limpBehavior: 0, coldcall: 1, openEP: 0, openLP: 1, pfrAggression: 1, threeBetProfile: 0, fold3bet: 2 },
                        postflop: { flopStrategy: 0, foldcbet: 0, postflopAggression: 2, turnBehavior: 1, riverBehavior: 0 },
                        stackpressure: { shortStack: 0, midStack: 0, deepStack: 0 },
                        dynamics: { tableTalk: 1, attention: 2, cunning: 1, thinking: 2, tiltProfile: 0, afterLoss: 3, tanking: 0, physicalConfidence: 0 },
                        awareness: { stackProtection: 2, bubbleBehavior: 1, finalTableAdj: 1, payJumpAwareness: 1, skillLevel: 2 },
                        styleToggles: {},
                        psychToggles: {}
                    },
                    streets: {
                        preflop: {
                            dos: ['Tighten dominated Ax', 'Let him escalate without matching', 'Value 3-bet premiums', '3-bet wider IP (he under-defends)'],
                            donts: ['Light 4-bet bluff', 'Enter ego battles', 'Stack off Ax dominated'],
                            note: 'Structured preflop. Not splashy.'
                        },
                        flop: {
                            dos: ['Recognize trap frequency', 'Check back marginal hands', 'Bet for value on dry boards'],
                            donts: ['Bluff mindlessly into his range', 'Ignore check-raise potential', 'Over-cbet wet boards'],
                            note: 'Can trap. Can under-represent. Range-aware.'
                        },
                        turn: {
                            dos: ['Charge draws on turn', 'Polarize credible lines', 'Apply pressure after coolers'],
                            donts: ['Thin triple barrels without blockers', 'Large pure bluffs', 'Ignore his draw stickiness'],
                            note: 'Sticky with strong draws. Semi-bluffs selectively. Capable of pressure.'
                        },
                        river: {
                            dos: ['Value bet confidently (hero-call bias)', 'Fold when polarization credible', 'Selective big bluffs with blockers'],
                            donts: ['Large pure bluffs on river', 'Hero-call his big bets without reads', 'Over-level'],
                            note: 'Strongest river player of the personas. Hero-calls light. Thinks in polarization.'
                        }
                    },
                    challengeTrigger: 'Will call off full stack when: feels disrespected, targeted repeatedly, perceives someone testing him. Ego activation layered onto competence.',
                    stackMatrix: [
                        { stack: 'Early', adjust: 'Aggressive probing' },
                        { stack: 'After Rebuy', adjust: 'Accelerates' },
                        { stack: 'Big Stack', adjust: 'Steady, controlled' },
                        { stack: 'Short Stack', adjust: 'Rational jams + marginal flips' }
                    ],
                    postCooler: 'RECOVERY FAILURE — biggest exploit window. VPIP increases, aggression spikes, marginal spots taken. Apply max pressure 10-20 min after big loss.',
                    postCoolerProtocol: [
                        'Phase 1: Immediate Freeze — no voluntary VPIP for one orbit',
                        'Phase 2: Stack Recalibration — "I now have X BB"',
                        'Phase 3: Flip Filter — decline marginal flips 30 min',
                        'Phase 4: Tempo Control — slow breathing, no table talk 10 min',
                        'Phase 5: Population Re-Anchor — live pools under-bluff large spots'
                    ],
                    ftDanger: 'Highest — #1 danger ranking if stable. Highest technical ceiling.',
                    quote: 'A capital allocator who plays technically sound poker but will deploy his entire stack to defend perceived status.',
                    leakType: 'Recovery (Post-Cooler)',
                    shortcut: 'Thinks deeply + ego spikes → Banker',
                    strengths: ['Situational awareness', 'Technical competence', 'Stack leverage understanding', 'Late-stage conversion ability'],
                    leaks: ['Ego-triggered stack-offs', 'Hero-call bias', 'Post-bad-beat aggression spike', 'Slight draw stickiness']
                },
                playStyle: { preflop: { vpip: 'Med (25-50%)', pfr: 'Med (25-50%)' } },
                exploits: {
                    preflop: ['3-bet wider IP — he under-defends', 'Value bet thinner (hero-call bias)', 'Apply pressure after coolers'],
                    warnings: ['When silent → very strong', 'Ego trigger: will call off stack if feels disrespected', 'Strongest river player — don\'t pure bluff big']
                }
            },
            {
                id: 'persona-accountant',
                name: 'The Accountant',
                isPersona: true,
                description: 'Variance-Controlled Tournament Optimizer • Late-Reg Specialist • Push/Fold Precision',
                persona: {
                    subtitle: '30s. Rarely multi-bullets. Often late-registers at 20-30bb. Low VPIP. Push/fold competent. Cash rate: 20-30%.',
                    coreProfile: 'Bypasses deep-stack play entirely. Open jams 88+, any Ax, KTo-type hands. Minimizes postflop complexity. Avoids thin spots. He doesn\'t gamble — he allocates.',
                    dimensions: {
                        preflop: { vpip: 0, limpBehavior: 0, coldcall: 0, openEP: 0, openLP: 1, pfrAggression: 1, threeBetProfile: 0, fold3bet: 0 },
                        postflop: { flopStrategy: 2, foldcbet: 2, postflopAggression: 0, turnBehavior: 0, riverBehavior: 3 },
                        stackpressure: { shortStack: 0, midStack: 0, deepStack: 1 },
                        dynamics: { tableTalk: 0, attention: 2, cunning: 2, thinking: 2, tiltProfile: 0, afterLoss: 0, tanking: 0, physicalConfidence: 1 },
                        awareness: { stackProtection: 2, bubbleBehavior: 0, finalTableAdj: 0, payJumpAwareness: 0, skillLevel: 1 },
                        styleToggles: { tglSetMines: 1, tglAfraidBust: 1, tglNoLight3bet: 1, tglOverfolds: 1, tglNeverBluffRiver: 1 },
                        psychToggles: { tglScaredMoney: 1 }
                    },
                    streets: {
                        preflop: {
                            dos: ['Attack late-reg stack before double', 'Widen reshove range vs his jams (KTo reveals width)', 'Isolate aggressively', 'Apply immediate pressure'],
                            donts: ['Fold to all his jams', 'Assume tight = only premiums', 'Let him double cheaply'],
                            note: 'Late-reg at 20-30bb. "Double early or bust cheaply."'
                        },
                        flop: {
                            dos: ['Barrel coordinated boards', 'Thin value bet more often', 'Bluff rivers selectively', 'Exploit his fold frequency'],
                            donts: ['Check back too often', 'Assume he\'s trapping', 'Over-respect his tight image'],
                            note: 'Avoids coordinated board fights. Rare hero calls.'
                        },
                        turn: {
                            dos: ['Increase aggression on scare cards', 'Pressure with draws', 'Size up on blank turns'],
                            donts: ['Give free cards', 'Expect thin value bets from him', 'Slow down unnecessarily'],
                            note: 'Over-folds vs pressure. Avoids marginal edges.'
                        },
                        river: {
                            dos: ['Polarize selectively', 'Bluff rivers more than usual', 'Value bet thin'],
                            donts: ['Expect him to hero-call', 'Use tiny sizing (rare thin value from him)', 'Over-respect tightness'],
                            note: 'Over-folds. Low river bluffing. Low thin value.'
                        }
                    },
                    phases: [
                        { name: 'Late-Reg (20-30bb)', desc: 'Open jams 88+, Ax, KTo. Minimizes postflop. "Double early or bust cheaply."' },
                        { name: 'Stabilization (40-60bb)', desc: 'VPIP increases slightly. Still disciplined. Rarely thin value bets.' },
                        { name: 'Bubble', desc: 'Tightens noticeably. Protects min-cash equity. Does not apply max ICM pressure.' },
                        { name: 'Final Table', desc: 'Most dangerous phase. Push/fold heavy. Strong payout awareness. Thrives in compressed structures.' }
                    ],
                    stackMatrix: [
                        { stack: 'vs Late-Reg Stack', adjust: 'Attack before he doubles' },
                        { stack: 'Postflop', adjust: 'Barrel coordinated boards, exploit fold frequency' },
                        { stack: 'Bubble', adjust: 'Apply ICM pressure, steal blinds relentlessly' },
                        { stack: 'Final Table', adjust: 'Push off marginal reshoves. Respect high-leverage shove windows.' }
                    ],
                    postCooler: 'No change — no adjustment needed. Emotionally stable.',
                    ftDanger: '2nd — structure dependent. Thrives in compressed stacks.',
                    quote: 'A disciplined, late-registering, variance-minimizing tactician who converts structured tournaments through push-fold precision and payout discipline.',
                    leakType: 'Variance Cap',
                    shortcut: 'Late-reg push/fold + ladder discipline → Accountant',
                    strengths: ['Emotional Stability (Very High)', 'Variance Discipline (Very High)', 'Push/Fold (Strong)', 'ICM (Moderate-Strong)'],
                    leaks: ['Avoids thin value bets', 'Over-tightens on bubble', 'Late-reg caps overall edge', 'Rare multi-bullet reduces ceiling']
                },
                playStyle: { preflop: { vpip: 'Low (<25%)', pfr: 'Low (<25%)' } },
                exploits: {
                    preflop: ['Attack late-reg stack early', 'Widen reshove vs Ax/KTo jams', 'Steal heavily on bubble'],
                    warnings: ['KTo in his jam range — not only premiums', 'Final table is his strongest phase', 'Don\'t get into flip wars with him']
                }
            }
        ];

        function seedPersonas() {
            let changed = false;
            // Remove legacy 'scared-money' archetype if present
            var smIdx = database.archetypes.findIndex(a => a.id === 'scared-money');
            if (smIdx !== -1) { database.archetypes.splice(smIdx, 1); changed = true; }
            BUILTIN_PERSONAS.forEach(p => {
                var existing = database.archetypes.find(a => a.id === p.id);
                if (!existing) {
                    database.archetypes.push(JSON.parse(JSON.stringify(p)));
                    changed = true;
                } else {
                    // Only sync if persona data actually differs
                    const existingJson = JSON.stringify(existing.persona) + existing.description;
                    const builtinJson = JSON.stringify(p.persona) + p.description;
                    if (existingJson !== builtinJson) {
                        existing.persona = JSON.parse(JSON.stringify(p.persona));
                        existing.description = p.description;
                        changed = true;
                    }
                }
            });
            if (changed) saveDatabase();
        }

        function renderPersonaDimensions(dims) {
            if (!dims) return '';
            var html = '';
            
            // Label maps matching the Player form exactly (excluding Player Description)
            var sliderDefs = {
                preflop: [
                    { key: 'vpip', label: 'VPIP', labels: ['Low','Med','High'] },
                    { key: 'limpBehavior', label: 'Limp Behavior', labels: ['Never','Weak Limper','Trap Limper','Limp-Call Station'] },
                    { key: 'coldcall', label: 'Cold Call Freq', labels: ['Low','Med','High'] },
                    { key: 'openEP', label: 'Open Discipline (EP)', labels: ['Tight','Reasonable','Too Loose'] },
                    { key: 'openLP', label: 'Open Discipline (LP)', labels: ['Passive','Competent','Wide-Steal'] },
                    { key: 'pfrAggression', label: 'Pre-flop Aggression', labels: ['Low','Med','High'] },
                    { key: 'threeBetProfile', label: '3-Bet Profile', labels: ['Value-Heavy','Can Light 3-Bet','Over-Bluffs'] },
                    { key: 'fold3bet', label: 'Defense vs 3-Bet', labels: ['Overfolds','Set-Mines Only','Defends Correctly','Sticky'] }
                ],
                postflop: [
                    { key: 'flopStrategy', label: 'Flop Strategy', labels: ['Honest','Auto C-Bets','Fit-or-Fold','Sticky'] },
                    { key: 'foldcbet', label: 'Folds to C-bet', labels: ['Never','Sometimes','Often'] },
                    { key: 'postflopAggression', label: 'Post-flop Aggression', labels: ['Low','Med','High'] },
                    { key: 'turnBehavior', label: 'Turn Behavior <span style="color:#ff8c38">★</span>', labels: ['Shuts Down','Barrel Capable','Over-Folds','Calls Too Much'] },
                    { key: 'riverBehavior', label: 'River Behavior', labels: ['Under-Bluffs','Hero Calls','Can\'t Fold Big Pairs','Scared Money'] }
                ],
                stackpressure: [
                    { key: 'shortStack', label: 'Short Stack (≤20bb)', labels: ['Shoves Correctly','Over-Folds','Calls Off Light','Min-Raises Too Much'] },
                    { key: 'midStack', label: 'Mid Stack (20–40bb)', labels: ['Avoids Marginal','Plays Scared','Understands Resteals','Calls Opens Wide'] },
                    { key: 'deepStack', label: 'Deep Stack (60bb+)', labels: ['Comfortable','Avoids Big Pots','Overplays Top Pair','Overvalues Draws'] }
                ],
                dynamics: [
                    { key: 'tableTalk', label: 'Table Presence', labels: ['Quiet','Engaged','Talkative'] },
                    { key: 'attention', label: 'Focus Level', labels: ['Low','Med','High'] },
                    { key: 'cunning', label: 'Cunning', labels: ['Cute','High','WYSIWYG'] },
                    { key: 'thinking', label: 'Thinking', labels: ['Automaton','Average','Thinking'] },
                    { key: 'tiltProfile', label: 'Tilt Profile', labels: ['Stable','Slow Burn','Snap-Tilt','Ego Tilt'] },
                    { key: 'afterLoss', label: 'After Losing Big Pot', labels: ['Tightens','Spews','Leaves Table','Re-Centers'] },
                    { key: 'tanking', label: 'Tanking Behavior', labels: ['Genuine','Fake','When Weak','When Strong'] },
                    { key: 'physicalConfidence', label: 'Physical Confidence', labels: ['Comfortable','Hesitant','Watches Reactions','Avoids Eye Contact'] }
                ],
                awareness: [
                    { key: 'stackProtection', label: 'Stack Protection', labels: ['Low','Med','High'] },
                    { key: 'bubbleBehavior', label: 'Bubble Behavior', labels: ['Freezes Up','Attacks','Oblivious'] },
                    { key: 'finalTableAdj', label: 'Final Table Adjustment', labels: ['Ladder-Focused','Win-Focused','Clueless'] },
                    { key: 'payJumpAwareness', label: 'Pay Jump Awareness', labels: ['Over-Folds','Balanced','Clueless'] },
                    { key: 'skillLevel', label: 'Skill Level', labels: ['Beginner','Intermediate','Advanced'] }
                ]
            };

            // Toggle definitions matching PLAYER_DIM_DEFS.toggleSections
            var toggleDefs = {
                styleToggles: { title: 'Overall Style', toggles: [
                    { key: 'tglChasesDraws', label: 'Chases draws' },
                    { key: 'tglLimpAny', label: 'Limps/cold calls any two' },
                    { key: 'tglFaceCards', label: 'Loves face cards / any ace' },
                    { key: 'tglRiverCheap', label: 'Wants to get to river cheap' },
                    { key: 'tglLimpJam', label: 'Limp/jams AK, AQ, 88+' },
                    { key: 'tglCantRiver', label: 'Unable to play out to river' },
                    { key: 'tglOverfolds', label: 'Over-folds to pressure' },
                    { key: 'tglNeverBluffRiver', label: 'Never bluffs river' },
                    { key: 'tglLimpCall', label: 'Limp/call heavy' },
                    { key: 'tglSetMines', label: 'Set-mines only' },
                    { key: 'tglAfraidBust', label: 'Afraid of busting' },
                    { key: 'tglNoLight3bet', label: "Doesn't 3-bet light" },
                    { key: 'tglNoStackDepth', label: "Doesn't understand stack depth" }
                ]},
                psychToggles: { title: 'Psychological', toggles: [
                    { key: 'tglTiltProne', label: 'Tilt prone' },
                    { key: 'tglScaredMoney', label: 'Scared money' },
                    { key: 'tglEgoDriven', label: 'Ego-driven' },
                    { key: 'tglResultOriented', label: 'Result-oriented' },
                    { key: 'tglRecklessPressure', label: 'Reckless under pressure' }
                ]}
            };
            
            var sectionNames = {
                preflop: 'Pre-flop',
                postflop: 'Post-flop',
                stackpressure: 'Stack & Pressure <span style="color:#ff8c38">★</span>',
                dynamics: 'Player Dynamics',
                awareness: 'Game Awareness'
            };
            
            // Render chip sections
            ['preflop','postflop','stackpressure','dynamics','awareness'].forEach(function(section) {
                if (!dims[section]) return;
                html += '<div class="persona-dim-section">';
                html += '<div class="persona-dim-section-title">' + sectionNames[section] + '</div>';
                sliderDefs[section].forEach(function(def) {
                    var val = dims[section][def.key];
                    if (val === null || val === undefined) return;
                    html += '<div class="persona-dim-row">';
                    html += '<span class="persona-dim-label">' + def.label + '</span>';
                    html += '<span class="persona-dim-chips">';
                    html += '<span class="persona-dim-chip active">' + def.labels[val] + '</span>';
                    html += '</span></div>';
                });
                html += '</div>';
            });

            // Render toggle sections
            ['styleToggles','psychToggles'].forEach(function(sectionKey) {
                if (!dims[sectionKey]) return;
                var section = toggleDefs[sectionKey];
                var hasActive = section.toggles.some(function(t) { return dims[sectionKey][t.key]; });
                if (!hasActive) return;
                html += '<div class="persona-dim-section">';
                html += '<div class="persona-dim-section-title">' + section.title + '</div>';
                html += '<div class="persona-toggle-row">';
                section.toggles.forEach(function(t) {
                    var isOn = dims[sectionKey][t.key] ? true : false;
                    if (isOn) {
                        html += '<span class="persona-dim-chip active">' + t.label + '</span>';
                    }
                });
                html += '</div></div>';
            });
            
            return html;
        }

        function renderPersonaDetail(arch) {
            const p = arch.persona;
            if (!p) return '';
            
            let html = '<div class="persona-detail" id="pd-' + arch.id + '" onclick="event.stopPropagation()">';
            
            // Core profile — always open by default
            html += '<div class="persona-section-divider collapsible" onclick="togglePersonaSection(this)">Core Profile</div>';
            html += '<div class="persona-section-body">';
            html += '<div class="persona-detail-text" style="margin-bottom:0.5rem;">' + p.coreProfile + '</div>';
            html += '</div>';

            // Dimensions (slider/chip displays)
            if (p.dimensions) {
                html += '<div class="persona-section-divider collapsible" onclick="togglePersonaSection(this)">Profile Dimensions</div>';
                html += '<div class="persona-section-body">';
                html += renderPersonaDimensions(p.dimensions);
                html += '</div>';
            }
            
            // Modes (Campaigner) or Phases (Accountant)
            if (p.modes) {
                html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Play Modes</div>';
                html += '<div class="persona-section-body collapsed">';
                p.modes.forEach(m => {
                    html += '<div style="margin-bottom:0.4rem;"><span class="persona-meta-label">' + m.name + '</span><br><span class="persona-detail-text" style="font-size:0.75rem;">' + m.desc + '</span></div>';
                });
                html += '</div>';
            }
            if (p.phases) {
                html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Tournament Phases</div>';
                html += '<div class="persona-section-body collapsed">';
                p.phases.forEach(m => {
                    html += '<div style="margin-bottom:0.4rem;"><span class="persona-meta-label">' + m.name + '</span><br><span class="persona-detail-text" style="font-size:0.75rem;">' + m.desc + '</span></div>';
                });
                html += '</div>';
            }
            
            // Challenge Trigger (Banker)
            if (p.challengeTrigger) {
                html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">⚠ Challenge Trigger</div>';
                html += '<div class="persona-section-body collapsed">';
                html += '<div class="persona-detail-text">' + p.challengeTrigger + '</div>';
                html += '</div>';
            }
            
            // Street-by-street exploits
            html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Street-by-Street Exploit</div>';
            html += '<div class="persona-section-body collapsed">';
            var streetNames = { preflop: 'Preflop', flop: 'Flop', turn: 'Turn', river: 'River' };
            Object.keys(p.streets).forEach(street => {
                var s = p.streets[street];
                html += '<div class="persona-street">';
                html += '<div class="persona-street-title" onclick="togglePersonaStreet(this)">' + streetNames[street];
                if (street === 'turn') html += ' <span style="font-size:0.6rem;letter-spacing:1px;margin-left:6px;">★ HIGH EV</span>';
                html += '</div>';
                html += '<div class="persona-street-body">';
                if (s.note) html += '<div class="persona-detail-text" style="font-size:0.73rem;font-style:italic;margin-bottom:0.5rem;">' + s.note + '</div>';
                html += '<div class="persona-do-dont">';
                html += '<div class="persona-do"><div class="persona-do-label">Do</div><ul>' + s.dos.map(d => '<li>' + d + '</li>').join('') + '</ul></div>';
                html += '<div class="persona-dont"><div class="persona-dont-label">Don\'t</div><ul>' + s.donts.map(d => '<li>' + d + '</li>').join('') + '</ul></div>';
                html += '</div></div></div>';
            });
            html += '</div>'; // close street-by-street body
            
            // River sizing table (Mayor)
            if (p.riverSizing) {
                html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">River Sizing Map</div>';
                html += '<div class="persona-section-body collapsed">';
                html += '<table class="persona-table"><tr><th>You Hold</th><th>Strategy</th></tr>';
                p.riverSizing.forEach(r => {
                    html += '<tr><td>' + r.holding + '</td><td>' + r.strategy + '</td></tr>';
                });
                html += '</table>';
                html += '</div>';
            }
            
            // Stack matrix
            html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Stack / Phase Adjustments</div>';
            html += '<div class="persona-section-body collapsed">';
            html += '<table class="persona-table"><tr><th>Phase</th><th>Adjustment</th></tr>';
            p.stackMatrix.forEach(r => {
                html += '<tr><td>' + r.stack + '</td><td>' + r.adjust + '</td></tr>';
            });
            html += '</table>';
            html += '</div>';
            
            // Post-cooler
            html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Post-Cooler Window</div>';
            html += '<div class="persona-section-body collapsed">';
            html += '<div class="persona-detail-text">' + p.postCooler + '</div>';
            if (p.postCoolerProtocol) {
                html += '<div class="persona-detail-text" style="font-size:0.7rem;margin-top:0.4rem;">';
                p.postCoolerProtocol.forEach(step => { html += '• ' + step + '<br>'; });
                html += '</div>';
            }
            html += '</div>';
            
            // Strengths & Leaks
            if (p.strengths) {
                html += '<div class="persona-section-divider collapsible collapsed" onclick="togglePersonaSection(this)">Strengths & Leaks</div>';
                html += '<div class="persona-section-body collapsed">';
                html += '<div class="persona-strengths-leaks">';
                html += '<div><span class="persona-strengths-label">Strengths</span><br>' + p.strengths.join('<br>') + '</div>';
                html += '<div><span class="persona-leaks-label">Leaks</span><br>' + p.leaks.join('<br>') + '</div>';
                html += '</div>';
                html += '</div>';
            }
            
            // FT danger + leak type + Quick ID (always visible)
            html += '<div style="display:flex;gap:1rem;margin-top:1rem;flex-wrap:wrap;">';
            html += '<div class="persona-detail-text" style="font-size:0.7rem;"><span class="persona-meta-label">FT Danger:</span> ' + p.ftDanger + '</div>';
            html += '<div class="persona-detail-text" style="font-size:0.7rem;"><span class="persona-meta-label">Leak Type:</span> ' + p.leakType + '</div>';
            html += '</div>';
            
            // Quick ID shortcut
            html += '<div class="persona-quick-id"><span class="persona-detail-text"><span class="persona-meta-label">Quick ID:</span> ' + p.shortcut + '</span></div>';
            
            // Quote
            html += '<div class="persona-quote">"' + p.quote + '"</div>';
            
            html += '</div>';
            return html;
        }

        function togglePersonaDetail(id) {
            var el = document.getElementById('pd-' + id);
            if (el) el.classList.toggle('open');
        }

        function togglePersonaSection(titleEl) {
            event.stopPropagation();
            titleEl.classList.toggle('collapsed');
            var body = titleEl.nextElementSibling;
            if (body) body.classList.toggle('collapsed');
        }

        function togglePersonaStreet(titleEl) {
            event.stopPropagation();
            titleEl.classList.toggle('open');
            var body = titleEl.nextElementSibling;
            if (body) body.classList.toggle('open');
        }

        function updateArchetypeList() {
            const list = document.getElementById('archetype-list');
            if (!database || !database.archetypes) return;
            
            // Separate personas from user archetypes
            const personas = database.archetypes.filter(a => a.isPersona);
            const userArchs = database.archetypes.filter(a => !a.isPersona);
            
            let html = '';
            
            // Render personas first
            if (personas.length > 0) {
                personas.forEach(arch => {
                    html += '<div class="list-item persona-item" onclick="togglePersonaDetail(\'' + arch.id + '\')">';
                    html += '<div class="list-item-header">';
                    html += '<div class="list-item-title">' + arch.name + '</div>';
                    html += '</div>';
                    html += '<div class="persona-subtitle">' + arch.description + '</div>';
                    html += renderPersonaDetail(arch);
                    html += '</div>';
                });
            }
            
            // Render user archetypes
            if (userArchs.length > 0) {
                userArchs.forEach(arch => {
                    html += '<div class="list-item" onclick="editArchetype(\'' + arch.id + '\')">';
                    html += '<div class="list-item-header">';
                    html += '<div class="list-item-title">' + arch.name + '</div>';
                    var vpipLabel = arch.playStyle ? arch.playStyle.preflop.vpip : (arch.dimensions ? ['Low','Med','High'][arch.dimensions.preflop.vpip] || 'Low' : 'N/A');
                    var pfrLabel = arch.playStyle ? arch.playStyle.preflop.pfr : (arch.dimensions ? ['Low','Med','High'][arch.dimensions.preflop.pfrAggression] || 'Low' : 'N/A');
                    html += '<div class="list-item-meta">VPIP: ' + vpipLabel + ' | PFR: ' + pfrLabel + '</div>';
                    html += '</div>';
                    html += '<div class="list-item-meta">' + (arch.description || '') + '</div>';
                    html += '</div>';
                });
            }
            
            list.innerHTML = html || '<p style="opacity: 0.5;">No archetypes yet</p>';
        }

        function filterArchetypes() {
            const search = document.getElementById('archetype-search').value.toLowerCase();
            const items = document.querySelectorAll('#archetype-list .list-item');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(search) ? '' : 'none';
            });
        }

        function showArchetypeForm() {
            currentArchetypeId = null;
            document.getElementById('archetype-form-section').style.display = 'block';
            document.getElementById('archetype-form-title').textContent = 'New Archetype';
            document.getElementById('archetype-form').reset();
            document.getElementById('delete-archetype-btn').style.display = 'none';
            resetArchFormDimensions();
        }

        function hideArchetypeForm() {
            document.getElementById('archetype-form-section').style.display = 'none';
            currentArchetypeId = null;
        }

        function editArchetype(id) {
            const arch = database.archetypes.find(a => a.id === id);
            if (!arch) return;
            
            currentArchetypeId = id;
            document.getElementById('archetype-form-section').style.display = 'block';
            document.getElementById('archetype-form-title').textContent = 'Edit Archetype';
            document.getElementById('delete-archetype-btn').style.display = 'inline-block';
            
            document.getElementById('arch-name').value = arch.name;
            document.getElementById('arch-description').value = arch.description || '';
            
            // Load dimensions
            if (arch.dimensions) {
                setArchFormDimensions(arch.dimensions);
            } else {
                resetArchFormDimensions();
            }
            
            // Load exploits
            document.getElementById('arch-exploits-preflop').value = (arch.exploits && arch.exploits.preflop ? arch.exploits.preflop.join('\n') : '');
            document.getElementById('arch-exploits-postflop').value = (arch.exploits && arch.exploits.postflop ? arch.exploits.postflop.join('\n') : '');
            document.getElementById('arch-exploits-bubble').value = (arch.exploits && arch.exploits.bubble ? arch.exploits.bubble.join('\n') : '');
            document.getElementById('arch-warnings').value = (arch.exploits && arch.exploits.warnings ? arch.exploits.warnings.join('\n') : '');
            document.getElementById('arch-notes').value = arch.notes || '';
        }

        async function deleteArchetype() {
            if (!await nwConfirm('Delete this archetype?', true)) return;
            database.archetypes = database.archetypes.filter(a => a.id !== currentArchetypeId);
            saveDatabase();
            hideArchetypeForm();
        }

        document.getElementById('archetype-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('arch-name').value;
            const id = currentArchetypeId || name.toLowerCase().replace(/\s+/g, '-');
            const dims = getArchFormDimensions();
            
            const archetype = {
                id: id,
                name: name,
                description: document.getElementById('arch-description').value,
                dimensions: dims,
                playStyle: {
                    preflop: {
                        vpip: ['Low','Med','High'][dims.preflop ? dims.preflop.vpip : 0] || 'Low',
                        pfr: ['Low','Med','High'][dims.preflop ? dims.preflop.pfrAggression : 0] || 'Low'
                    }
                },
                exploits: {
                    preflop: document.getElementById('arch-exploits-preflop').value.split('\n').filter(x => x.trim()),
                    postflop: document.getElementById('arch-exploits-postflop').value.split('\n').filter(x => x.trim()),
                    bubble: document.getElementById('arch-exploits-bubble').value.split('\n').filter(x => x.trim()),
                    warnings: document.getElementById('arch-warnings').value.split('\n').filter(x => x.trim())
                },
                notes: document.getElementById('arch-notes').value || null
            };
            
            if (currentArchetypeId) {
                const index = database.archetypes.findIndex(a => a.id === currentArchetypeId);
                database.archetypes[index] = archetype;
            } else {
                database.archetypes.push(archetype);
            }
            
            saveDatabase();
            hideArchetypeForm();
        });

        // Players
        let currentPlayerName = null;

        // === DRUM PICKER ENGINE ===
        const DRUM = {
            ITEM_H: 44,          // must match CSS .apple-picker-item height
            offset: 0,           // current scroll offset in px
            velocity: 0,
            friction: 0.92,
            isDragging: false,
            dragStarted: false,
            lastY: 0,
            lastTime: 0,
            animFrame: null,
            items: [],
            selectedIndex: 0,
            container: null,
            cylinder: null,
            containerH: 260,
        };

        function updatePlayerList() {
            if (!database || !database.realPlayers) return;
            DRUM.cylinder = document.getElementById('player-picker');
            DRUM.container = document.getElementById('drum-container');
            const sorted = [...database.realPlayers].sort((a, b) => a.name.localeCompare(b.name));
            DRUM.items = sorted;

            // Measure container
            DRUM.containerH = DRUM.container.offsetHeight || 260;

            // Restore last position: saved offset > localStorage player > 0
            if (DRUM._savedOffset !== undefined) {
                DRUM.offset = DRUM._savedOffset;
            } else {
                const lastPlayer = localStorage.getItem('nitwiz_lastPlayer');
                if (lastPlayer && DRUM.items.length > 0) {
                    const idx = DRUM.items.findIndex(p => p.name === lastPlayer);
                    if (idx >= 0) {
                        DRUM.offset = -idx * DRUM.ITEM_H;
                    } else {
                        DRUM.offset = 0;
                    }
                } else {
                    DRUM.offset = 0;
                }
            }

            renderDrumItems();
            bindDrumEvents();

            // Auto-load the currently selected player's profile
            if (DRUM.items.length > 0 && !DRUM._addingNew) {
                const n = DRUM.items.length;
                const centerIdx = Math.round(-DRUM.offset / DRUM.ITEM_H);
                const wrappedIdx = wrapIndex(centerIdx, n);
                const player = DRUM.items[wrappedIdx];
                if (player) {
                    editPlayer(player.name);
                }
            }
        }

        // How many items to render above/below center for visibility
        const DRUM_RENDER_BUFFER = 6;

        function wrapIndex(i, len) {
            return ((i % len) + len) % len;
        }

        function renderDrumItems() {
            const n = DRUM.items.length;
            if (n === 0 || DRUM._editing || DRUM._addingNew) {
                return;
            }

            // Which logical index is at center?
            const centerFloat = -DRUM.offset / DRUM.ITEM_H;
            const centerIdx = Math.round(centerFloat);
            DRUM.selectedIndex = wrapIndex(centerIdx, n);

            const centerY = DRUM.containerH / 2 - DRUM.ITEM_H / 2;

            let html = '';
            for (let delta = -DRUM_RENDER_BUFFER; delta <= DRUM_RENDER_BUFFER; delta++) {
                const logicalIdx = centerIdx + delta;
                const wrappedIdx = wrapIndex(logicalIdx, n);
                const player = DRUM.items[wrappedIdx];

                // Y position: how far from center in px
                const itemY = centerY + (logicalIdx * DRUM.ITEM_H + DRUM.offset);
                const isSelected = delta === 0 || (Math.abs(centerFloat - centerIdx) < 0.01 && delta === 0);
                const sel = wrappedIdx === DRUM.selectedIndex ? ' selected' : '';

                html += `<div class="apple-picker-item${sel}" data-name="${player.name}" data-index="${wrappedIdx}" data-logical="${logicalIdx}" style="position:absolute;top:0;left:0;width:100%;transform:translateY(${itemY}px)">${player.name}</div>`;
            }

            DRUM.cylinder.innerHTML = html;
        }

        function getSnappedOffset(logicalIndex) {
            return -logicalIndex * DRUM.ITEM_H;
        }

        // No clamping — infinite scroll
        function clampOffset(off) {
            return off;
        }

        function hardClampOffset(off) {
            return off;
        }

        function positionDrum() {
            // Not used for positioning anymore — renderDrumItems handles it
            // But keep for compat, just re-render
            renderDrumItems();
        }

        function updateDrumSelection() {
            // Handled inside renderDrumItems
        }

        function snapToIndex(logicalIndex) {
            cancelAnimationFrame(DRUM.animFrame);
            const target = getSnappedOffset(logicalIndex);
            animateSnap(target, () => {
                DRUM._savedOffset = DRUM.offset;
                const n = DRUM.items.length;
                const wrappedIdx = wrapIndex(logicalIndex, n);
                const player = DRUM.items[wrappedIdx];
                if (player) editPlayer(player.name);
            });
        }

        // Snap to nearest logical index from current offset
        function snapToNearest() {
            const n = DRUM.items.length;
            if (n === 0) return;
            const logicalIdx = Math.round(-DRUM.offset / DRUM.ITEM_H);
            snapToIndex(logicalIdx);
        }

        function animateSnap(target, callback) {
            const step = () => {
                const diff = target - DRUM.offset;
                if (Math.abs(diff) < 0.5) {
                    DRUM.offset = target;
                    renderDrumItems();
                    if (callback) callback();
                    return;
                }
                DRUM.offset += diff * 0.18;
                renderDrumItems();
                DRUM.animFrame = requestAnimationFrame(step);
            };
            DRUM.animFrame = requestAnimationFrame(step);
        }

        function momentumScroll() {
            if (DRUM.isDragging) return;

            DRUM.velocity *= DRUM.friction;
            DRUM.offset += DRUM.velocity;
            renderDrumItems();

            if (Math.abs(DRUM.velocity) > 0.5) {
                DRUM.animFrame = requestAnimationFrame(momentumScroll);
            } else {
                DRUM.velocity = 0;
                snapToNearest();
            }
        }

        function bindDrumEvents() {
            const overlay = document.getElementById('drum-touch-overlay');

            if (DRUM._bound) return;
            DRUM._bound = true;

            function onDown(clientY) {
                cancelAnimationFrame(DRUM.animFrame);
                DRUM.isDragging = true;
                DRUM.dragStarted = false;
                DRUM.velocity = 0;
                DRUM.lastY = clientY;
                DRUM.lastTime = Date.now();
                DRUM._velocityHistory = [];
            }

            function onMove(clientY) {
                if (!DRUM.isDragging) return;
                const now = Date.now();
                const dy = clientY - DRUM.lastY;
                const dt = Math.max(1, now - DRUM.lastTime);

                if (Math.abs(dy) > 2) DRUM.dragStarted = true;

                DRUM.offset += dy;

                const v = dy * (16 / dt);
                DRUM._velocityHistory.push({ v, t: now });
                DRUM._velocityHistory = DRUM._velocityHistory.filter(s => now - s.t < 100);

                DRUM.lastY = clientY;
                DRUM.lastTime = now;
                renderDrumItems();
            }

            function onUp() {
                if (!DRUM.isDragging) return;
                DRUM.isDragging = false;

                const history = DRUM._velocityHistory || [];
                if (history.length > 0) {
                    const avgV = history.reduce((sum, s) => sum + s.v, 0) / history.length;
                    DRUM.velocity = Math.max(-25, Math.min(25, avgV));
                } else {
                    DRUM.velocity = 0;
                }

                if (Math.abs(DRUM.velocity) < 1) {
                    DRUM.velocity = 0;
                    snapToNearest();
                } else {
                    momentumScroll();
                }
            }

            // Touch — all events on the overlay, nothing can interfere
            overlay.addEventListener('touchstart', (e) => {
                e.preventDefault();
                onDown(e.touches[0].clientY);
            }, { passive: false });

            overlay.addEventListener('touchmove', (e) => {
                e.preventDefault();
                onMove(e.touches[0].clientY);
            }, { passive: false });

            overlay.addEventListener('touchend', (e) => {
                e.preventDefault();
                onUp();
            }, { passive: false });

            overlay.addEventListener('touchcancel', onUp);

            // Mouse — down on overlay, move/up on window
            overlay.addEventListener('mousedown', (e) => { e.preventDefault(); onDown(e.clientY); });
            window.addEventListener('mousemove', (e) => { if (DRUM.isDragging) { e.preventDefault(); onMove(e.clientY); }});
            window.addEventListener('mouseup', onUp);

            // Mouse wheel
            overlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                cancelAnimationFrame(DRUM.animFrame);
                const dir = e.deltaY > 0 ? 1 : -1;
                const logicalIdx = Math.round(-DRUM.offset / DRUM.ITEM_H) + dir;
                snapToIndex(logicalIdx);
            }, { passive: false });
        }

        // === INLINE NAME EDITING ===
        function startDrumInlineEdit(item, index) {
            // Don't start if already editing
            if (DRUM._editing) return;
            DRUM._editing = true;

            const player = DRUM.items[index];
            if (!player) { DRUM._editing = false; return; }
            const oldName = player.name;

            // Create input that replaces the item text
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldName;
            input.className = 'drum-inline-edit';
            input.setAttribute('autocomplete', 'off');
            input.setAttribute('autocorrect', 'off');
            input.setAttribute('spellcheck', 'false');

            // Clear item text content and insert input
            item.textContent = '';
            item.appendChild(input);
            item.classList.add('editing');

            // Focus and select all
            input.focus();
            input.select();

            // Prevent drum drag while editing
            input.addEventListener('mousedown', (e) => e.stopPropagation());
            input.addEventListener('touchstart', (e) => e.stopPropagation());

            let committed = false;

            function commitEdit() {
                if (committed) return;
                committed = true;

                const newName = input.value.trim();
                if (!newName || newName === oldName) {
                    cancelEdit();
                    return;
                }

                // Check for duplicate names
                const duplicate = database.realPlayers.find(p => p.name === newName && p.name !== oldName);
                if (duplicate) {
                    committed = false; // allow retry
                    nwAlert('A player with that name already exists.').then(function() { input.focus(); input.select(); });
                    return;
                }

                // Update in database
                const dbPlayer = database.realPlayers.find(p => p.name === oldName);
                if (dbPlayer) {
                    dbPlayer.name = newName;
                    if (currentPlayerName === oldName) {
                        currentPlayerName = newName;
                        document.getElementById('player-form-title').textContent = newName;
                        document.getElementById('player-name').value = newName;
                    }
                    saveDatabase();
                }

                // Rebuild drum with new sorted order
                DRUM._editing = false;
                // Find the new index position
                const sorted = [...database.realPlayers].sort((a, b) => a.name.localeCompare(b.name));
                const newIdx = sorted.findIndex(p => p.name === newName);
                DRUM._savedOffset = -(newIdx >= 0 ? newIdx : 0) * DRUM.ITEM_H;
                updatePlayerList();
            }

            function cancelEdit() {
                DRUM._editing = false;
                // Re-render to restore
                renderDrumItems();
            }

            // Save on Enter, cancel on Escape
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    commitEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });

            // Save on blur
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!committed) commitEdit();
                }, 50);
            });
        }

        function initApplePicker() {
            // Now handled by updatePlayerList + bindDrumEvents
        }

        function selectPlayerFromDropdown() {
            // Legacy function - no longer needed but keeping for compatibility
        }

        function filterPlayers() {
            // No longer needed with picker, but keeping for compatibility
        }

        function updatePlayerArchetypeDropdown() {
            // No longer needed since we removed archetype dropdown
        }

        function showPlayerForm() {
            // Hide any open form first
            document.getElementById('player-form-section').style.display = 'none';
            currentPlayerName = null;

            // Scroll to top so the drum input is visible
            const playersTab = document.getElementById('players');
            const drumContainer = document.getElementById('drum-container');
            if (drumContainer) {
                drumContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }

            // Don't start if already adding
            if (DRUM.cylinder.querySelector('.drum-new-input')) return;

            // Clear the drum and show a single input item centered
            cancelAnimationFrame(DRUM.animFrame);
            DRUM._addingNew = true;

            // Hide the touch overlay so the input is tappable on mobile
            const overlay = document.getElementById('drum-touch-overlay');
            if (overlay) overlay.style.display = 'none';

            const centerY = DRUM.containerH / 2 - DRUM.ITEM_H / 2;
            DRUM.cylinder.innerHTML = `<div class="apple-picker-item selected editing" style="position:absolute;top:0;left:0;width:100%;transform:translateY(${centerY}px)">
                <input type="text" class="drum-inline-edit drum-new-input" placeholder="Enter player name..." autocomplete="off" autocorrect="off" spellcheck="false" />
            </div>`;

            // Add confirm/cancel buttons below the drum for mobile usability
            let actionBar = document.getElementById('drum-new-player-actions');
            if (!actionBar) {
                actionBar = document.createElement('div');
                actionBar.id = 'drum-new-player-actions';
                actionBar.style.cssText = 'display:flex; justify-content:center; gap:1rem; margin-top:1rem;';
                DRUM.container.parentElement.insertBefore(actionBar, DRUM.container.nextSibling);
            }
            actionBar.innerHTML = `
                <button type="button" class="btn-metallic btn-save" id="drum-new-confirm-btn" title="Confirm" style="width:48px;height:48px;">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
                <button type="button" class="btn-metallic btn-delete" id="drum-new-cancel-btn" title="Cancel" style="width:48px;height:48px;">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            `;
            actionBar.style.display = 'flex';

            const input = DRUM.cylinder.querySelector('.drum-new-input');
            setTimeout(() => input.focus(), 150);

            // Prevent drum drag while typing
            input.addEventListener('mousedown', (e) => e.stopPropagation());
            input.addEventListener('touchstart', (e) => e.stopPropagation());

            function cleanup() {
                // Restore the touch overlay
                if (overlay) overlay.style.display = '';
                // Hide action buttons
                if (actionBar) actionBar.style.display = 'none';
            }

            function commitNewPlayer() {
                const name = input.value.trim();
                if (!name) {
                    cancelNewPlayer();
                    return;
                }

                const duplicate = database.realPlayers.find(p => p.name === name);
                if (duplicate) {
                    nwAlert('A player with that name already exists.').then(function() { input.focus(); input.select(); });
                    return;
                }

                const newPlayer = {
                    name: name,
                    observationsList: [],
                    weaknesses: [],
                    // All dimensions start null = unassessed (greyed out in UI)
                    vpip: null, limpBehavior: null, coldcall: null, openEP: null, openLP: null,
                    pfrAggression: null, threeBetProfile: null, fold3bet: null,
                    flopStrategy: null, foldcbet: null, postflopAggression: null,
                    turnBehavior: null, riverBehavior: null,
                    shortStack: null, midStack: null, deepStack: null,
                    tableTalk: null, attention: null, cunning: null, thinking: null,
                    tiltProfile: null, afterLoss: null, tanking: null, physicalConfidence: null,
                    stackProtection: null, bubbleBehavior: null, finalTableAdj: null,
                    payJumpAwareness: null, skillLevel: null,
                    gender: null, age: null, ethnicity: null, education: null, profession: null,
                    tglChasesDraws: 0, tglLimpAny: 0, tglFaceCards: 0, tglRiverCheap: 0,
                    tglLimpJam: 0, tglCantRiver: 0, tglOverfolds: 0, tglNeverBluffRiver: 0,
                    tglLimpCall: 0, tglSetMines: 0, tglAfraidBust: 0, tglNoLight3bet: 0,
                    tglNoStackDepth: 0, tglTiltProne: 0, tglScaredMoney: 0, tglEgoDriven: 0,
                    tglResultOriented: 0, tglRecklessPressure: 0
                };

                database.realPlayers.push(newPlayer);
                saveDatabase();

                DRUM._addingNew = false;
                cleanup();

                // Rebuild and find the new player
                const sorted = [...database.realPlayers].sort((a, b) => a.name.localeCompare(b.name));
                const newIndex = sorted.findIndex(p => p.name === name);
                DRUM._savedOffset = -(newIndex >= 0 ? newIndex : 0) * DRUM.ITEM_H;

                updatePlayerList();
                editPlayer(name);
            }

            function cancelNewPlayer() {
                DRUM._addingNew = false;
                cleanup();
                // Restore the drum
                renderDrumItems();
            }

            let committed = false;

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    committed = true;
                    commitNewPlayer();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    committed = true;
                    cancelNewPlayer();
                }
            });

            // Blur commit — but skip if confirm/cancel buttons were tapped
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!committed) {
                        // Don't auto-commit on blur when action buttons are available
                        // User might have tapped outside accidentally on mobile
                        // Only auto-cancel if empty
                        const name = input.value.trim();
                        if (!name) {
                            committed = true;
                            cancelNewPlayer();
                        }
                    }
                }, 200);
            });

            // Wire up confirm/cancel buttons
            document.getElementById('drum-new-confirm-btn').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                committed = true;
                commitNewPlayer();
            });
            document.getElementById('drum-new-cancel-btn').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                committed = true;
                cancelNewPlayer();
            });
            // Touch events for mobile (fire before blur)
            document.getElementById('drum-new-confirm-btn').addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                committed = true;
                commitNewPlayer();
            });
            document.getElementById('drum-new-cancel-btn').addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                committed = true;
                cancelNewPlayer();
            });
        }

        function hidePlayerForm() {
            document.getElementById('player-form-section').style.display = 'none';
            currentPlayerName = null;
        }

        function editPlayer(name) {
            if (!database || !database.realPlayers) return;
            const player = database.realPlayers.find(p => p.name === name);
            if (!player) return;
            
            currentPlayerName = name;
            localStorage.setItem('nitwiz_lastPlayer', name);
            document.getElementById('player-form-section').style.display = 'block';
            document.getElementById('player-form-title').textContent = name;
            document.getElementById('delete-player-btn').style.display = 'inline-block';
            
            document.getElementById('player-name').value = player.name;
            
            // Load all dimension chip values (null = unassessed, renders greyed out)
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                section.fields.forEach(function(f) {
                    var val = (f.dbKey in player) ? player[f.dbKey] : null;
                    setPlayerChipValue(f.id, val);
                });
            });

            // Load toggle values
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    section.toggles.forEach(function(t) {
                        setPlayerToggleValue(t.dbKey, player[t.dbKey] || 0);
                    });
                });
            }
            
            // Load custom toggles
            loadCustomTogglesForPlayer(player);
            
            // Load weaknesses
            renderWeaknessPlates(player.weaknesses || []);

            // Load observations — support old string format migration
            let obsList = player.observationsList || [];
            if (obsList.length === 0 && player.observations) {
                obsList = player.observations.split('\n').filter(x => x.trim());
            }
            renderObservationPlates(obsList);
            
            // Load hand history for this player
            renderPlayerHandHistory(name);
        }

        function renderPlayerHandHistory(playerName) {
            const list = document.getElementById('player-hand-history-list');
            if (!list) return;
            
            // Find hands where this player is hero or villain (case-insensitive, trimmed)
            const pn = (playerName || '').trim().toLowerCase();
            const hands = hhStoredHands.filter(function(h) {
                var hero = (h.hero || '').trim().toLowerCase();
                var villain = (h.villainName || '').trim().toLowerCase();
                return hero === pn || villain === pn;
            });
            
            if (hands.length === 0) {
                list.innerHTML = '<div class="notecard-empty">No hands recorded for this player</div>';
                return;
            }
            
            list.innerHTML = '';
            
            hands.forEach(function(hand) {
                const isHero = hand.hero === playerName;
                const role = isHero ? 'Hero' : 'Villain';
                const pos = isHero ? hand.heroPosition : hand.villainPosition;
                const opponent = isHero ? (hand.villainFirstName || hand.villainName || 'Villain') : (hand.heroFirstName || hand.hero || 'Hero');
                const opponentPos = isHero ? hand.villainPosition : hand.heroPosition;
                
                // Build street summary
                var streets = hand.streetActions || {};
                var stNames = ['preflop', 'flop', 'turn', 'river'];
                var stLabels = {preflop: 'PF', flop: 'F', turn: 'T', river: 'R'};
                var parts = [];
                
                stNames.forEach(function(st) {
                    var acts = (streets[st] || []).filter(function(a) { return a && a.action; });
                    if (!acts.length) return;
                    var cc = '';
                    if (st !== 'preflop' && hand.communityCards) {
                        cc = hand.communityCards[st] || '';
                    }
                    var chain = acts.map(function(a) {
                        var who = a.actor === 'villain' ? (hand.villainFirstName || 'V') : (hand.heroFirstName || 'H');
                        var amt = a.amount ? ' ' + parseInt(a.amount).toLocaleString() : '';
                        return who + ':' + a.action + amt;
                    }).join(' \u2192 ');
                    var label = stLabels[st];
                    if (cc) chain = '[' + cc + '] ' + chain;
                    parts.push(label + ': ' + chain);
                });
                
                // Winner
                if (hand.winner) {
                    var winnerName = hand.winner === 'hero' ? (hand.heroFirstName || 'Hero') : (hand.villainFirstName || 'Villain');
                    parts.push('\u2714 ' + winnerName);
                }
                
                // Hole cards
                var cards = [];
                if (hand.heroCards) cards.push((hand.heroFirstName || 'H') + ': ' + hand.heroCards);
                if (hand.villainCards) cards.push((hand.villainFirstName || 'V') + ': ' + hand.villainCards);
                
                var entry = document.createElement('div');
                entry.className = 'notecard-entry';
                entry.style.cursor = 'default';
                
                var textSpan = document.createElement('span');
                textSpan.className = 'notecard-entry-text';
                
                // Build display text
                var header = '#' + hand.handNumber + '  ' + role + ' (' + pos + ') vs ' + opponent + ' (' + opponentPos + ')';
                var detail = parts.join(' | ');
                if (cards.length) detail += (detail ? ' | ' : '') + cards.join(', ');
                if (hand.notes) detail += ' \u2014 "' + hand.notes + '"';
                
                textSpan.textContent = header + (detail ? ' \u2014 ' + detail : '');
                entry.appendChild(textSpan);
                list.appendChild(entry);
            });
        }

        // === INLINE NAME EDITING ON CARD TITLE ===
        (function initNameEditing() {
            const titleEl = document.getElementById('player-form-title');
            let longPressTimer = null;
            let isEditing = false;

            function startNameEdit() {
                if (isEditing || !currentPlayerName) return;
                isEditing = true;

                const oldName = currentPlayerName;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = oldName;
                input.className = 'card-name-edit-input';
                input.setAttribute('autocomplete', 'off');
                input.setAttribute('autocorrect', 'off');
                input.setAttribute('spellcheck', 'false');

                titleEl.textContent = '';
                titleEl.appendChild(input);
                input.focus();
                input.select();

                function commit() {
                    if (!isEditing) return;
                    isEditing = false;
                    const newName = input.value.trim();

                    if (newName && newName !== oldName) {
                        // Check for duplicate
                        const exists = database.realPlayers.some(p => p.name === newName);
                        if (exists) {
                            titleEl.textContent = oldName;
                            return;
                        }
                        // Rename in database
                        const player = database.realPlayers.find(p => p.name === oldName);
                        if (player) {
                            player.name = newName;
                            currentPlayerName = newName;
                            localStorage.setItem('nitwiz_lastPlayer', newName);
                            titleEl.textContent = newName;
                            document.getElementById('player-name').value = newName;
                            saveDatabase();
                        } else {
                            titleEl.textContent = oldName;
                        }
                    } else {
                        titleEl.textContent = oldName;
                    }
                }

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
                    if (e.key === 'Escape') { e.preventDefault(); isEditing = false; titleEl.textContent = oldName; }
                });
                input.addEventListener('blur', () => setTimeout(commit, 50));
            }

            // Double-click
            titleEl.addEventListener('dblclick', (e) => {
                e.preventDefault();
                startNameEdit();
            });

            // Long press (mobile)
            titleEl.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    startNameEdit();
                }, 500);
            }, { passive: false });

            titleEl.addEventListener('touchend', () => clearTimeout(longPressTimer));
            titleEl.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            titleEl.addEventListener('touchcancel', () => clearTimeout(longPressTimer));
        })();

        // === KEY WEAKNESSES & OBSERVATIONS (Notecard System) ===
        let _weaknessData = [];
        let _observationData = [];
        let _editMode = { weakness: false, observation: false };

        function getWeaknessesFromUI() { return [..._weaknessData]; }
        function getObservationsFromUI() { return [..._observationData]; }

        function renderNotecard(type) {
            const data = type === 'weakness' ? _weaknessData : _observationData;
            const container = document.getElementById(type === 'weakness' ? 'player-weakness-list' : 'player-observation-list');
            const isEditing = _editMode[type];

            if (data.length === 0 && !isEditing) {
                container.innerHTML = '<div class="notecard-empty">None recorded</div>';
            } else {
                container.innerHTML = data.map((item, i) => `
                    <div class="notecard-entry" data-index="${i}">
                        <span class="notecard-entry-text">${item}</span>
                        <button type="button" class="notecard-entry-delete" onclick="removeNotecardItem('${type}', ${i})" title="Remove">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                `).join('');
            }

            container.classList.toggle('editing', isEditing);

            // In edit mode, make entries clickable to edit text
            if (isEditing) {
                container.querySelectorAll('.notecard-entry').forEach(entry => {
                    entry.querySelector('.notecard-entry-text').addEventListener('click', () => {
                        startInlineEdit(type, entry);
                    });
                    entry.querySelector('.notecard-entry-text').style.cursor = 'pointer';
                });
            }
        }

        function startInlineEdit(type, entryEl) {
            const data = type === 'weakness' ? _weaknessData : _observationData;
            const index = parseInt(entryEl.dataset.index);
            const textEl = entryEl.querySelector('.notecard-entry-text');
            const oldText = data[index];

            // Replace text with input
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldText;
            input.className = 'notecard-inline-input';
            input.setAttribute('autocomplete', 'off');

            textEl.style.display = 'none';
            entryEl.insertBefore(input, textEl);
            input.focus();
            input.select();

            let committed = false;

            function commit() {
                if (committed) return;
                committed = true;
                const val = input.value.trim();
                if (val && val !== oldText) {
                    data[index] = val;
                    if (type === 'weakness') saveWeaknessesToPlayer(data);
                    else saveObservationsToPlayer(data);
                }
                renderNotecard(type);
            }

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                else if (e.key === 'Escape') { e.preventDefault(); committed = true; renderNotecard(type); }
            });
            input.addEventListener('blur', () => setTimeout(commit, 80));
        }

        function addInlineEntry(type) {
            const container = document.getElementById(type === 'weakness' ? 'player-weakness-list' : 'player-observation-list');
            if (container.querySelector('.notecard-inline-input')) return;

            // Remove "None recorded" if present
            const empty = container.querySelector('.notecard-empty');
            if (empty) empty.remove();

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'notecard-inline-input';
            input.placeholder = type === 'weakness' ? 'Add weakness...' : 'Add observation...';
            input.setAttribute('autocomplete', 'off');
            container.appendChild(input);
            input.focus();

            let committed = false;

            function commit() {
                if (committed) return;
                committed = true;
                const val = input.value.trim();
                if (val) {
                    if (type === 'weakness') { _weaknessData.push(val); saveWeaknessesToPlayer(_weaknessData); }
                    else { _observationData.push(val); saveObservationsToPlayer(_observationData); }
                }
                renderNotecard(type);
            }

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                else if (e.key === 'Escape') { e.preventDefault(); committed = true; renderNotecard(type); }
            });
            input.addEventListener('blur', () => setTimeout(commit, 80));
        }

        function removeNotecardItem(type, index) {
            if (type === 'weakness') { _weaknessData.splice(index, 1); saveWeaknessesToPlayer(_weaknessData); }
            else { _observationData.splice(index, 1); saveObservationsToPlayer(_observationData); }
            renderNotecard(type);
        }

        function renderWeaknessPlates(weaknesses) {
            _weaknessData = weaknesses || [];
            _editMode.weakness = false;
            document.getElementById('weakness-edit-btn').classList.remove('active');
            renderNotecard('weakness');
        }

        function renderObservationPlates(observations) {
            _observationData = observations || [];
            _editMode.observation = false;
            document.getElementById('observation-edit-btn').classList.remove('active');
            renderNotecard('observation');
        }

        function addWeakness(text) {
            const trimmed = text.trim();
            if (!trimmed) return;
            _weaknessData.push(trimmed);
            renderNotecard('weakness');
            saveWeaknessesToPlayer(_weaknessData);
        }

        function removeWeakness(index) { removeNotecardItem('weakness', index); }

        function addObservation(text) {
            const trimmed = text.trim();
            if (!trimmed) return;
            _observationData.push(trimmed);
            renderNotecard('observation');
            saveObservationsToPlayer(_observationData);
        }

        function removeObservation(index) { removeNotecardItem('observation', index); }

        function saveWeaknessesToPlayer(weaknesses) {
            if (!currentPlayerName) return;
            const player = database.realPlayers.find(p => p.name === currentPlayerName);
            if (player) { player.weaknesses = weaknesses; saveDatabase(); }
        }

        function saveObservationsToPlayer(observations) {
            if (!currentPlayerName) return;
            const player = database.realPlayers.find(p => p.name === currentPlayerName);
            if (player) { player.observationsList = observations; saveDatabase(); }
        }

        // Pen toggles edit mode (show × and make entries clickable to edit)
        function toggleNotecard(type) {
            _editMode[type] = !_editMode[type];
            document.getElementById(type + '-edit-btn').classList.toggle('active', _editMode[type]);
            renderNotecard(type);
        }

        document.getElementById('weakness-edit-btn').addEventListener('click', () => toggleNotecard('weakness'));
        document.getElementById('observation-edit-btn').addEventListener('click', () => toggleNotecard('observation'));
        document.getElementById('weakness-add-btn').addEventListener('click', () => addInlineEntry('weakness'));
        document.getElementById('observation-add-btn').addEventListener('click', () => addInlineEntry('observation'));

        // === DESCRIPTOR CHIPS ===
        // Wire up all chip selectors
        document.querySelectorAll('.desc-selector').forEach(selector => {
            selector.addEventListener('click', (e) => {
                const chip = e.target.closest('.desc-chip');
                if (!chip) return;
                // Deselect siblings
                selector.querySelectorAll('.desc-chip').forEach(c => c.classList.remove('active'));
                // Select this one
                chip.classList.add('active');
            });
        });

        // === APP VERSION ===
        var APP_VERSION = '1.1.0';

        // === PLAYER CHIP DIMENSION DEFINITIONS ===
        var PLAYER_DIM_DEFS = {
            sections: [
                { key: 'preflop', title: 'Pre-flop', fields: [
                    { id: 'player-vpip', dbKey: 'vpip', label: 'VPIP', labels: ['Low','Med','High'] },
                    { id: 'player-limp-behavior', dbKey: 'limpBehavior', label: 'Limp Behavior', labels: ['Never','Weak Limper','Trap Limper','Limp-Call Station'] },
                    { id: 'player-coldcall', dbKey: 'coldcall', label: 'Cold Call Freq', labels: ['Low','Med','High'] },
                    { id: 'player-open-ep', dbKey: 'openEP', label: 'Open Discipline (EP)', labels: ['Tight','Reasonable','Too Loose'] },
                    { id: 'player-open-lp', dbKey: 'openLP', label: 'Open Discipline (LP)', labels: ['Passive','Competent','Wide-Steal'] },
                    { id: 'player-pfr-aggression', dbKey: 'pfrAggression', label: 'Pre-flop Aggression', labels: ['Low','Med','High'] },
                    { id: 'player-3bet-profile', dbKey: 'threeBetProfile', label: '3-Bet Profile', labels: ['Value-Heavy','Can Light 3-Bet','Over-Bluffs'] },
                    { id: 'player-fold3bet', dbKey: 'fold3bet', label: 'Defense vs 3-Bet', labels: ['Overfolds','Set-Mines Only','Defends Correctly','Sticky'] }
                ]},
                { key: 'postflop', title: 'Post-flop', fields: [
                    { id: 'player-flop-strategy', dbKey: 'flopStrategy', label: 'Flop Strategy', labels: ['Honest','Auto C-Bets','Fit-or-Fold','Sticky'] },
                    { id: 'player-foldcbet', dbKey: 'foldcbet', label: 'Folds to C-bet', labels: ['Never','Sometimes','Often'] },
                    { id: 'player-postflop-aggression', dbKey: 'postflopAggression', label: 'Post-flop Aggression', labels: ['Low','Med','High'] },
                    { id: 'player-turn-behavior', dbKey: 'turnBehavior', label: 'Turn Behavior <span style="color:#ff8c38">★</span>', labels: ['Shuts Down','Barrel Capable','Over-Folds','Calls Too Much'] },
                    { id: 'player-river-behavior', dbKey: 'riverBehavior', label: 'River Behavior', labels: ['Under-Bluffs','Hero Calls','Can\'t Fold Big Pairs','Scared Money'] }
                ]},
                { key: 'stackpressure', title: 'Stack & Pressure <span style="color:#ff8c38">★</span>', fields: [
                    { id: 'player-short-stack', dbKey: 'shortStack', label: 'Short Stack (≤20bb)', labels: ['Shoves Correctly','Over-Folds','Calls Off Light','Min-Raises Too Much'] },
                    { id: 'player-mid-stack', dbKey: 'midStack', label: 'Mid Stack (20–40bb)', labels: ['Avoids Marginal','Plays Scared','Understands Resteals','Calls Opens Wide'] },
                    { id: 'player-deep-stack', dbKey: 'deepStack', label: 'Deep Stack (60bb+)', labels: ['Comfortable','Avoids Big Pots','Overplays Top Pair','Overvalues Draws'] }
                ]},
                { key: 'dynamics', title: 'Player Dynamics', fields: [
                    { id: 'player-table-talk', dbKey: 'tableTalk', label: 'Table Presence', labels: ['Quiet','Engaged','Talkative'] },
                    { id: 'player-attention', dbKey: 'attention', label: 'Focus Level', labels: ['Low','Med','High'] },
                    { id: 'player-cunning', dbKey: 'cunning', label: 'Cunning', labels: ['Cute','High','WYSIWYG'] },
                    { id: 'player-thinking', dbKey: 'thinking', label: 'Thinking', labels: ['Automaton','Average','Thinking'] },
                    { id: 'player-tilt-profile', dbKey: 'tiltProfile', label: 'Tilt Profile', labels: ['Stable','Slow Burn','Snap-Tilt','Ego Tilt'] },
                    { id: 'player-after-loss', dbKey: 'afterLoss', label: 'After Losing Big Pot', labels: ['Tightens','Spews','Leaves Table','Re-Centers'] },
                    { id: 'player-tanking', dbKey: 'tanking', label: 'Tanking Behavior', labels: ['Genuine','Fake','When Weak','When Strong'] },
                    { id: 'player-physical', dbKey: 'physicalConfidence', label: 'Physical Confidence', labels: ['Comfortable','Hesitant','Watches Reactions','Avoids Eye Contact'] }
                ]},
                { key: 'awareness', title: 'Game Awareness', fields: [
                    { id: 'player-stack-protection', dbKey: 'stackProtection', label: 'Stack Protection', labels: ['Low','Med','High'] },
                    { id: 'player-bubble', dbKey: 'bubbleBehavior', label: 'Bubble Behavior', labels: ['Freezes Up','Attacks','Oblivious'] },
                    { id: 'player-final-table', dbKey: 'finalTableAdj', label: 'Final Table Adjustment', labels: ['Ladder-Focused','Win-Focused','Clueless'] },
                    { id: 'player-pay-jump', dbKey: 'payJumpAwareness', label: 'Pay Jump Awareness', labels: ['Over-Folds','Balanced','Clueless'] },
                    { id: 'player-skill-level', dbKey: 'skillLevel', label: 'Skill Level', labels: ['Beginner','Intermediate','Advanced'] }
                ]},
                { key: 'description', title: 'Player Description', fields: [
                    { id: 'player-gender', dbKey: 'gender', label: 'Gender', labels: ['Male','Female'] },
                    { id: 'player-age', dbKey: 'age', label: 'Age Range', labels: ['Young Stud','Young','Middle','Old','Ancient'] },
                    { id: 'player-ethnicity', dbKey: 'ethnicity', label: 'Ethnicity', labels: ['White','Black','E Asian','S Asian','ME','Hispanic','Other'] },
                    { id: 'player-education', dbKey: 'education', label: 'Education', labels: ['Some','College','Graduate','Unknown'] },
                    { id: 'player-profession', dbKey: 'profession', label: 'Profession', labels: ['White Collar','Blue Collar','Poker Pro','Retired','Other'] }
                ]}
            ],
            toggleSections: [
                { key: 'styleToggles', title: 'Overall Style', toggles: [
                    { id: 'toggle-chases-draws', dbKey: 'tglChasesDraws', label: 'Chases draws' },
                    { id: 'toggle-limp-any', dbKey: 'tglLimpAny', label: 'Limps/cold calls any two' },
                    { id: 'toggle-face-cards', dbKey: 'tglFaceCards', label: 'Loves face cards / any ace' },
                    { id: 'toggle-river-cheap', dbKey: 'tglRiverCheap', label: 'Wants to get to river cheap' },
                    { id: 'toggle-limp-jam', dbKey: 'tglLimpJam', label: 'Limp/jams AK, AQ, 88+' },
                    { id: 'toggle-cant-river', dbKey: 'tglCantRiver', label: 'Unable to play out to river' },
                    { id: 'toggle-overfolds', dbKey: 'tglOverfolds', label: 'Over-folds to pressure' },
                    { id: 'toggle-never-bluff-river', dbKey: 'tglNeverBluffRiver', label: 'Never bluffs river' },
                    { id: 'toggle-limp-call', dbKey: 'tglLimpCall', label: 'Limp/call heavy' },
                    { id: 'toggle-set-mines', dbKey: 'tglSetMines', label: 'Set-mines only' },
                    { id: 'toggle-afraid-bust', dbKey: 'tglAfraidBust', label: 'Afraid of busting' },
                    { id: 'toggle-no-light-3bet', dbKey: 'tglNoLight3bet', label: "Doesn't 3-bet light" },
                    { id: 'toggle-no-stack-depth', dbKey: 'tglNoStackDepth', label: "Doesn't understand stack depth" }
                ]},
                { key: 'psychToggles', title: 'Psychological', toggles: [
                    { id: 'toggle-tilt-prone', dbKey: 'tglTiltProne', label: 'Tilt prone' },
                    { id: 'toggle-scared-money', dbKey: 'tglScaredMoney', label: 'Scared money' },
                    { id: 'toggle-ego-driven', dbKey: 'tglEgoDriven', label: 'Ego-driven' },
                    { id: 'toggle-result-oriented', dbKey: 'tglResultOriented', label: 'Result-oriented' },
                    { id: 'toggle-reckless-pressure', dbKey: 'tglRecklessPressure', label: 'Reckless under pressure' }
                ]}
            ]
        };

        function renderPlayerDimensions() {
            var container = document.getElementById('player-chip-dimensions');
            if (!container) return;
            var html = '';
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                html += '<div class="persona-dim-section">';
                html += '<div class="persona-dim-section-title">' + section.title + '</div>';
                section.fields.forEach(function(f) {
                    html += '<div class="persona-dim-row">';
                    html += '<span class="persona-dim-label">' + f.label + '</span>';
                    html += '<span class="persona-dim-chips" data-player-field="' + f.id + '">';
                    f.labels.forEach(function(lbl, i) {
                        html += '<span class="persona-dim-chip player-dim-chip' + (i === 0 ? ' active' : '') + '" data-value="' + i + '" onclick="tapPlayerChip(this)">' + lbl + '</span>';
                    });
                    html += '</span></div>';
                });
                html += '</div>';
            });
            // Render toggle sections
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    html += '<div class="persona-dim-section">';
                    html += '<div class="persona-dim-section-title">' + section.title + '</div>';
                    html += '<div class="persona-toggle-row" id="toggle-row-' + section.key + '">';
                    section.toggles.forEach(function(t) {
                        html += '<span class="persona-dim-chip player-toggle-chip" data-toggle-id="' + t.id + '" data-dbkey="' + t.dbKey + '" onclick="tapPlayerToggle(this)">' + t.label + '</span>';
                    });
                    html += '</div>';
                    html += '<div class="notecard-actions"><button type="button" class="notecard-add-btn" onclick="addCustomToggle(\'' + section.key + '\')" title="Add custom"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button></div>';
                    html += '</div>';
                });
            }
            container.innerHTML = html;
        }

        function tapPlayerChip(el) {
            // Deactivate siblings, activate this one — marks row as assessed
            var parent = el.parentElement;
            parent.querySelectorAll('.player-dim-chip').forEach(function(c) { c.classList.remove('active'); });
            el.classList.add('active');
            parent.classList.remove('unassessed');
            // Auto-save
            autoSavePlayer();
        }

        function tapPlayerToggle(el) {
            // Toggle on/off (multi-select)
            el.classList.toggle('active');
            autoSavePlayer();
        }

        async function addCustomToggle(sectionKey) {
            if (!currentPlayerName) { await nwAlert('Select a player first'); return; }
            var label = await nwPrompt('Enter custom tag:', 'Tag name');
            if (!label || !label.trim()) return;
            label = label.trim();
            
            var player = database.realPlayers.find(function(p) { return p.name === currentPlayerName; });
            if (!player) return;
            
            // Initialize custom toggles array if needed
            if (!player.customToggles) player.customToggles = {};
            if (!player.customToggles[sectionKey]) player.customToggles[sectionKey] = [];
            
            // Avoid duplicates
            if (player.customToggles[sectionKey].indexOf(label) !== -1) return;
            
            player.customToggles[sectionKey].push(label);
            saveDatabase();
            
            // Add chip to the UI
            renderCustomToggles(sectionKey, player);
        }

        function renderCustomToggles(sectionKey, player) {
            var row = document.getElementById('toggle-row-' + sectionKey);
            if (!row || !player || !player.customToggles || !player.customToggles[sectionKey]) return;
            
            // Remove existing custom chips
            row.querySelectorAll('.custom-toggle-chip').forEach(function(el) { el.remove(); });
            
            player.customToggles[sectionKey].forEach(function(label) {
                var chip = document.createElement('span');
                chip.className = 'persona-dim-chip player-toggle-chip custom-toggle-chip active';
                chip.textContent = label;
                chip.onclick = function() { removeCustomToggle(sectionKey, label, chip); };
                row.appendChild(chip);
            });
        }

        function removeCustomToggle(sectionKey, label, chipEl) {
            if (!currentPlayerName) return;
            var player = database.realPlayers.find(function(p) { return p.name === currentPlayerName; });
            if (!player || !player.customToggles || !player.customToggles[sectionKey]) return;
            
            var idx = player.customToggles[sectionKey].indexOf(label);
            if (idx !== -1) {
                player.customToggles[sectionKey].splice(idx, 1);
                saveDatabase();
            }
            if (chipEl) chipEl.remove();
        }

        function loadCustomTogglesForPlayer(player) {
            // Clear all existing custom chips first
            document.querySelectorAll('.custom-toggle-chip').forEach(function(el) { el.remove(); });
            if (!player || !player.customToggles) return;
            PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                renderCustomToggles(section.key, player);
            });
        }

        function getPlayerChipValue(fieldId) {
            var container = document.querySelector('[data-player-field="' + fieldId + '"]');
            if (!container) return null;
            var active = container.querySelector('.player-dim-chip.active');
            return active ? parseInt(active.dataset.value) : null;
        }

        function getPlayerToggleValue(dbKey) {
            var el = document.querySelector('[data-dbkey="' + dbKey + '"]');
            return el ? (el.classList.contains('active') ? 1 : 0) : 0;
        }

        function setPlayerToggleValue(dbKey, value) {
            var el = document.querySelector('[data-dbkey="' + dbKey + '"]');
            if (el) el.classList.toggle('active', !!value);
        }

        function setPlayerChipValue(fieldId, value) {
            var container = document.querySelector('[data-player-field="' + fieldId + '"]');
            if (!container) return;
            if (value === null || value === undefined) {
                // Unassessed — no chip active, grey out the whole row
                container.querySelectorAll('.player-dim-chip').forEach(function(c) { c.classList.remove('active'); });
                container.classList.add('unassessed');
            } else {
                container.classList.remove('unassessed');
                container.querySelectorAll('.player-dim-chip').forEach(function(c) {
                    c.classList.toggle('active', parseInt(c.dataset.value) === value);
                });
            }
        }

        // Render the chip layout once at startup
        renderPlayerDimensions();

        // Render builder dimensions (same as player, excluding Player Description)
        function renderArchFormDimensions() {
            var container = document.getElementById('arch-chip-dimensions');
            if (!container) return;
            var html = '';
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                if (section.key === 'description') return;
                html += '<div class="persona-dim-section">';
                html += '<div class="persona-dim-section-title">' + section.title + '</div>';
                section.fields.forEach(function(f) {
                    var fieldId = 'archform-' + f.id;
                    html += '<div class="persona-dim-row">';
                    html += '<span class="persona-dim-label">' + f.label + '</span>';
                    html += '<span class="persona-dim-chips unassessed" data-archform-field="' + fieldId + '">';
                    f.labels.forEach(function(lbl, i) {
                        html += '<span class="persona-dim-chip player-dim-chip" data-value="' + i + '" onclick="tapArchFormChip(this)">' + lbl + '</span>';
                    });
                    html += '</span></div>';
                });
                html += '</div>';
            });
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    html += '<div class="persona-dim-section">';
                    html += '<div class="persona-dim-section-title">' + section.title + '</div>';
                    html += '<div class="persona-toggle-row">';
                    section.toggles.forEach(function(t) {
                        var fieldId = 'archform-' + t.id;
                        html += '<span class="persona-dim-chip player-toggle-chip" data-archform-toggle="' + fieldId + '" data-dbkey="' + t.dbKey + '" onclick="tapArchFormToggle(this)">' + t.label + '</span>';
                    });
                    html += '</div></div>';
                });
            }
            container.innerHTML = html;
        }

        function tapArchFormChip(el) {
            var parent = el.parentElement;
            parent.querySelectorAll('.player-dim-chip').forEach(function(c) { c.classList.remove('active'); });
            el.classList.add('active');
            parent.classList.remove('unassessed');
        }

        function tapArchFormToggle(el) {
            el.classList.toggle('active');
        }

        function getArchFormChipValue(fieldId) {
            var container = document.querySelector('[data-archform-field="' + fieldId + '"]');
            if (!container) return null;
            var active = container.querySelector('.player-dim-chip.active');
            return active ? parseInt(active.dataset.value) : null;
        }

        function setArchFormChipValue(fieldId, value) {
            var container = document.querySelector('[data-archform-field="' + fieldId + '"]');
            if (!container) return;
            if (value === null || value === undefined) {
                container.querySelectorAll('.player-dim-chip').forEach(function(c) { c.classList.remove('active'); });
                container.classList.add('unassessed');
            } else {
                container.classList.remove('unassessed');
                container.querySelectorAll('.player-dim-chip').forEach(function(c) {
                    c.classList.toggle('active', parseInt(c.dataset.value) === value);
                });
            }
        }

        function getArchFormToggleValue(fieldId) {
            var el = document.querySelector('[data-archform-toggle="' + fieldId + '"]');
            return el ? (el.classList.contains('active') ? 1 : 0) : 0;
        }

        function setArchFormToggleValue(fieldId, value) {
            var el = document.querySelector('[data-archform-toggle="' + fieldId + '"]');
            if (el) el.classList.toggle('active', !!value);
        }

        function getArchFormDimensions() {
            var dims = {};
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                if (section.key === 'description') return;
                dims[section.key] = {};
                section.fields.forEach(function(f) {
                    dims[section.key][f.dbKey] = getArchFormChipValue('archform-' + f.id);
                });
            });
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    dims[section.key] = {};
                    section.toggles.forEach(function(t) {
                        dims[section.key][t.dbKey] = getArchFormToggleValue('archform-' + t.id);
                    });
                });
            }
            return dims;
        }

        function setArchFormDimensions(dims) {
            if (!dims) return;
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                if (section.key === 'description') return;
                if (!dims[section.key]) return;
                section.fields.forEach(function(f) {
                    var val = dims[section.key][f.dbKey];
                    if (val !== null && val !== undefined) {
                        setArchFormChipValue('archform-' + f.id, val);
                    }
                });
            });
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    if (!dims[section.key]) return;
                    section.toggles.forEach(function(t) {
                        setArchFormToggleValue('archform-' + t.id, dims[section.key][t.dbKey] || 0);
                    });
                });
            }
        }

        function resetArchFormDimensions() {
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                if (section.key === 'description') return;
                section.fields.forEach(function(f) {
                    setArchFormChipValue('archform-' + f.id, null);
                });
            });
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    section.toggles.forEach(function(t) {
                        setArchFormToggleValue('archform-' + t.id, 0);
                    });
                });
            }
        }

        renderArchFormDimensions();

        function setDescChip(field, value) {
            // Now maps to the new chip system
            setPlayerChipValue(field, value);
        }

        function getDescChipValue(field) {
            return getPlayerChipValue(field);
        }

        async function deletePlayer() {
            if (!currentPlayerName) return;
            if (!await nwConfirm('Delete ' + currentPlayerName + '?\n\nAll their data — profile, observations, and hand history — will be permanently erased.', true)) return;
            database.realPlayers = database.realPlayers.filter(p => p.name !== currentPlayerName);
            // Also erase any quick obs data stored under this player's name
            // (quickObs is stored on the player object itself, so filtering covers it)
            currentPlayerName = null;
            saveDatabase();
        }

        document.getElementById('player-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('player-name').value;
            
            const player = {
                name: name,
                observationsList: getObservationsFromUI(),
                weaknesses: getWeaknessesFromUI()
            };
            
            // Read all dimension values from chips
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                section.fields.forEach(function(f) {
                    player[f.dbKey] = getPlayerChipValue(f.id);
                });
            });

            // Read all toggle values
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    section.toggles.forEach(function(t) {
                        player[t.dbKey] = getPlayerToggleValue(t.dbKey);
                    });
                });
            }
            
            if (currentPlayerName) {
                const index = database.realPlayers.findIndex(p => p.name === currentPlayerName);
                database.realPlayers[index] = player;
            } else {
                database.realPlayers.push(player);
            }
            
            saveDatabase();
            // Stay on the saved player's profile — update drum to reflect any changes
            DRUM._savedOffset = DRUM.offset;
        });

        // Brief

        // === AUTO-SAVE PLAYER ON EVERY CHANGE ===
        function autoSavePlayer() {
            if (!currentPlayerName) return;
            const player = database.realPlayers.find(p => p.name === currentPlayerName);
            if (!player) return;
            
            // Read all values from chip dimensions
            PLAYER_DIM_DEFS.sections.forEach(function(section) {
                section.fields.forEach(function(f) {
                    player[f.dbKey] = getPlayerChipValue(f.id);
                });
            });

            // Read all toggle values
            if (PLAYER_DIM_DEFS.toggleSections) {
                PLAYER_DIM_DEFS.toggleSections.forEach(function(section) {
                    section.toggles.forEach(function(t) {
                        player[t.dbKey] = getPlayerToggleValue(t.dbKey);
                    });
                });
            }
            
            saveDatabase();
        }

        // Auto-save on chip clicks is handled by tapPlayerChip() calling autoSavePlayer()

        function updateBriefPlayerSelection() {
            const container = document.getElementById('brief-player-selection');
            const html = database.realPlayers.map(player => `
                <div class="checkbox-group">
                    <input type="checkbox" id="brief-${player.name}" value="${player.name}">
                    <label for="brief-${player.name}">${player.name}</label>
                </div>
            `).join('');
            container.innerHTML = html || '<p style="opacity: 0.5;">No players in database</p>';
        }

        function generateBrief() {
            const selected = Array.from(document.querySelectorAll('#brief-player-selection input:checked'))
                .map(cb => cb.value);
            
            if (selected.length === 0) {
                nwAlert('Select at least one player');
                return;
            }
            
            const briefHtml = selected.map(playerName => {
                const player = database.realPlayers.find(p => p.name === playerName);
                const arch = database.archetypes.find(a => a.id === player.archetypeId);
                
                if (!arch) return '';
                
                return `
                    <div class="brief-player">
                        <div class="brief-player-name">${player.name}</div>
                        <div style="opacity: 0.7; margin-bottom: 1rem;">${arch.name} • ${player.venue || 'No venue'}</div>
                        
                        <div class="brief-section">
                            <div class="brief-section-title">Key Exploits</div>
                            <ul class="brief-list">
                                ${arch.exploits.preflop.slice(0, 3).map(e => `<li>${e}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="brief-section">
                            <div class="brief-section-title">Watch Out For</div>
                            <ul class="brief-list warnings">
                                ${arch.exploits.warnings.slice(0, 2).map(w => `<li>${w}</li>`).join('')}
                            </ul>
                        </div>
                        
                        ${player.notes ? `<div class="brief-section"><div class="brief-section-title">Notes</div><p style="opacity: 0.8;">${player.notes}</p></div>` : ''}
                    </div>
                `;
            }).join('');
            
            document.getElementById('brief-content').innerHTML = briefHtml;
            document.getElementById('brief-output').style.display = 'block';
        }

        // Data
        function updateJsonDisplay() {
            document.getElementById('json-display').textContent = JSON.stringify(database, null, 2);
        }

        function exportData() {
            const dataStr = JSON.stringify(database, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'poker-database.json';
            link.click();
        }

        function importData() {
            const file = document.getElementById('import-file').files[0];
            if (!file) {
                nwAlert('Select a file first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    database = JSON.parse(e.target.result);
                    saveDatabase();
                    nwAlert('Database imported successfully!');
                } catch (err) {
                    nwAlert('Error importing file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        // Splash screen functionality
        function exitApp() {
            // Switch to dashboard tab before exiting
            switchTab('dashboard');
            // Fade main out, fade splash in
            const main = document.getElementById('main-container');
            const splash = document.getElementById('splash-screen');
            main.style.opacity = '0';
            main.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                main.style.display = 'none';
                splash.style.display = 'flex';
                splash.classList.remove('fade-out');
                splash.style.opacity = '0';
                requestAnimationFrame(() => {
                    splash.style.transition = 'opacity 0.35s ease';
                    splash.style.opacity = '1';
                });
            }, 300);
            haptic('medium');
        }

        function hideSplash() {
            const splash = document.getElementById('splash-screen');
            if (!splash || splash.classList.contains('fade-out')) return;
            splash.classList.add('fade-out');
            haptic('light');
            setTimeout(() => {
                splash.style.display = 'none';
                if (_currentUser) {
                    // Auth already resolved — load the app now
                    _loadApp(_currentUser);
                } else {
                    // Auth not yet resolved or not logged in — show login
                    showLoginScreen();
                }
            }, 350);
        }

        // Attach splash tap handler — use both touchend and click,
        // touchend fires immediately on mobile without waiting for 300ms click delay
        (function() {
            var splashEl = document.getElementById('splash-screen');
            if (!splashEl) return;
            var _touched = false;
            splashEl.addEventListener('touchend', function(e) {
                e.preventDefault(); // prevent ghost click
                _touched = true;
                hideSplash();
                setTimeout(function() { _touched = false; }, 600);
            }, { passive: false });
            splashEl.addEventListener('click', function() {
                if (_touched) return; // already handled by touchend
                hideSplash();
            });
        })();

        // === BOTTOM NAV AUTO-HIDE ===
        (function() {
            var navHideTimer = null;
            var nav = null;

            function getNav() {
                if (!nav) nav = document.getElementById('bottom-nav');
                return nav;
            }

            function hideNav() {
                var n = getNav();
                if (n && n.classList.contains('visible')) {
                    n.classList.add('nav-hidden');
                }
            }

            function showNav() {
                var n = getNav();
                if (!n || !n.classList.contains('visible')) return;
                n.classList.remove('nav-hidden');
            }

            function onActivity() {
                hideNav();
                clearTimeout(navHideTimer);
                navHideTimer = setTimeout(showNav, 750);
            }

            // Hide on scroll
            window.addEventListener('scroll', onActivity, { passive: true });
            document.addEventListener('scroll', onActivity, { passive: true });

            // Hide on any touch/pointer interaction (but not on the nav itself)
            document.addEventListener('touchstart', function(e) {
                if (e.target.closest('#bottom-nav')) return;
                onActivity();
            }, { passive: true });

            document.addEventListener('pointerdown', function(e) {
                if (e.target.closest('#bottom-nav')) return;
                onActivity();
            }, { passive: true });

            // Hide while typing in any input/textarea
            document.addEventListener('focusin', function(e) {
                if (e.target.matches('input, textarea, select')) {
                    hideNav();
                    clearTimeout(navHideTimer);
                }
            });
            document.addEventListener('focusout', function(e) {
                if (e.target.matches('input, textarea, select')) {
                    clearTimeout(navHideTimer);
                    navHideTimer = setTimeout(showNav, 750);
                }
            });
        })();

        // === CHIP POP ANIMATION ===
        // Single delegated listener — fires chipPop on any chip/button tap app-wide
        document.addEventListener('pointerdown', function(e) {
            var el = e.target.closest(
                '.persona-dim-chip, .player-dim-chip, .player-toggle-chip, ' +
                '.qo-seat-chip, .qo-action-btn, .desc-chip, .hh-pos-chip, ' +
                '#qo-add-player-btn, #players-add-player-btn, #arch-add-btn, ' +
                '#qo-next-hand-btn'
            );
            if (!el) return;
            el.classList.remove('chip-pop');
            // Force reflow so re-adding the class always replays
            void el.offsetWidth;
            el.classList.add('chip-pop');
            el.addEventListener('animationend', function() {
                el.classList.remove('chip-pop');
            }, { once: true });
        }, { passive: true });

        // === HAPTIC FEEDBACK ===
        function haptic(style) {
            if (!navigator.vibrate) return;
            switch(style) {
                case 'light':   navigator.vibrate(8); break;
                case 'medium':  navigator.vibrate(15); break;
                case 'heavy':   navigator.vibrate(25); break;
                case 'tick':    navigator.vibrate(3); break;
                default:        navigator.vibrate(10);
            }
        }

        // Add haptic feedback to key interactions
        document.addEventListener('click', function(e) {
            const el = e.target.closest('.dashboard-btn, .tab, .desc-chip, .notecard-tab, .exit-btn');
            if (el) haptic('light');
        });

        // Haptic on slider change (throttled)
        let _lastSliderHaptic = 0;
        document.addEventListener('input', function(e) {
            if (e.target.type === 'range') {
                const now = Date.now();
                if (now - _lastSliderHaptic > 60) {
                    haptic('tick');
                    _lastSliderHaptic = now;
                }
            }
        });

        // === SERVICE WORKER REGISTRATION ===
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.log('SW registration failed:', err));
            });
        }

        // ===== LIVE SESSION =====
        let sessionActive = false;
        let sessionStartTime = null;
        let sessionTimerInterval = null;
        let currentBlindLevel = 0;
        let blindTimerInterval = null;
        let blindCountdownInterval = null;
        let blindNextAdvance = null;

        const blindStructure = [
            { sb: 100, bb: 100, ante: 0 },
            { sb: 100, bb: 100, ante: 100 },
            { sb: 100, bb: 200, ante: 200 },
            { sb: 200, bb: 300, ante: 300 },
            { sb: 200, bb: 400, ante: 400 },
            { sb: 300, bb: 600, ante: 600 },
            { sb: 400, bb: 800, ante: 800 },
            { sb: 600, bb: 1200, ante: 1200 },
            { sb: 1000, bb: 1500, ante: 1500 },
            { sb: 1000, bb: 2000, ante: 2000 },
            { sb: 1500, bb: 2500, ante: 2500 },
            { sb: 2000, bb: 3000, ante: 3000 },
            { sb: 2000, bb: 4000, ante: 4000 },
            { sb: 3000, bb: 6000, ante: 6000 },
            { sb: 4000, bb: 8000, ante: 8000 },
            { sb: 6000, bb: 12000, ante: 12000 },
            { sb: 10000, bb: 15000, ante: 15000 },
            { sb: 10000, bb: 20000, ante: 20000 },
            { sb: 15000, bb: 25000, ante: 25000 },
            { sb: 15000, bb: 30000, ante: 30000 },
            { sb: 20000, bb: 40000, ante: 40000 },
            { sb: 30000, bb: 60000, ante: 60000 },
            { sb: 40000, bb: 80000, ante: 80000 },
            { sb: 60000, bb: 120000, ante: 120000 },
            { sb: 100000, bb: 150000, ante: 150000 },
        ];

        function formatChips(n) {
            if (n >= 1000) return (n / 1000) + 'K';
            return n.toString();
        }

        function updateBlindDisplay() {
            const level = blindStructure[currentBlindLevel];
            document.getElementById('blind-level-num').textContent = 'Level ' + (currentBlindLevel + 1);
            document.getElementById('blind-level-values-display').textContent = 
                formatChips(level.sb) + ' / ' + formatChips(level.bb) + ' / ' + formatChips(level.ante);
        }

        function editBlindLevel() {
            const level = blindStructure[currentBlindLevel];
            const display = document.getElementById('blind-level-values-display');
            const editRow = document.getElementById('blind-level-edit-row');
            const sbInput = document.getElementById('blind-sb-input');
            const bbInput = document.getElementById('blind-bb-input');
            const anteInput = document.getElementById('blind-ante-input');

            // Show edit inputs, hide display
            display.classList.add('hidden');
            editRow.classList.remove('hidden');

            // Set current values
            sbInput.value = level.sb;
            bbInput.value = level.bb;
            anteInput.value = level.ante;

            // Focus first input
            sbInput.focus();
            setTimeout(() => sbInput.select(), 0);
        }

        function commitBlindLevel() {
            const level = blindStructure[currentBlindLevel];
            const display = document.getElementById('blind-level-values-display');
            const editRow = document.getElementById('blind-level-edit-row');
            const sbInput = document.getElementById('blind-sb-input');
            const bbInput = document.getElementById('blind-bb-input');
            const anteInput = document.getElementById('blind-ante-input');

            // Parse values
            const sb = parseInt(sbInput.value.replace(/[^0-9]/g, '')) || level.sb;
            const bb = parseInt(bbInput.value.replace(/[^0-9]/g, '')) || level.bb;
            const ante = parseInt(anteInput.value.replace(/[^0-9]/g, '')) || level.ante;

            // Update structure
            blindStructure[currentBlindLevel] = { sb, bb, ante };

            // Hide edit inputs, show display
            editRow.classList.add('hidden');
            display.classList.remove('hidden');

            // Update display
            updateBlindDisplay();
            saveHandHistory();
        }

        function prevBlindLevel() {
            if (currentBlindLevel > 0) {
                currentBlindLevel--;
                updateBlindDisplay();
                resetBlindCountdown();
                saveHandHistory();
            }
        }

        function nextBlindLevel() {
            if (currentBlindLevel < blindStructure.length - 1) {
                currentBlindLevel++;
                updateBlindDisplay();
                resetBlindCountdown();
                saveHandHistory();
            }
        }

        function toggleBlindTimer() {
            const checked = document.getElementById('blind-auto-advance').checked;
            const group = document.getElementById('blind-interval-group');
            const input = document.getElementById('blind-interval');
            
            if (checked) {
                group.style.opacity = '1';
                input.disabled = false;
                startBlindCountdown();
            } else {
                group.style.opacity = '0.4';
                input.disabled = true;
                stopBlindCountdown();
            }
        }

        function startBlindCountdown() {
            stopBlindCountdown();
            const minutes = parseInt(document.getElementById('blind-interval').value) || 20;
            blindNextAdvance = Date.now() + (minutes * 60 * 1000);
            
            blindCountdownInterval = setInterval(() => {
                const remaining = blindNextAdvance - Date.now();
                if (remaining <= 0) {
                    nextBlindLevel();
                    // Reset for next level
                    blindNextAdvance = Date.now() + (minutes * 60 * 1000);
                } else {
                    const mins = Math.floor(remaining / 60000);
                    const secs = Math.floor((remaining % 60000) / 1000);
                    document.getElementById('blind-countdown').textContent = 
                        mins.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0');
                }
            }, 1000);
        }

        function stopBlindCountdown() {
            if (blindCountdownInterval) {
                clearInterval(blindCountdownInterval);
                blindCountdownInterval = null;
            }
            document.getElementById('blind-countdown').textContent = '';
        }

        function resetBlindCountdown() {
            if (document.getElementById('blind-auto-advance').checked) {
                startBlindCountdown();
            }
        }

        function toggleSession() {
            if (!sessionActive) {
                // Start session
                sessionActive = true;
                sessionStartTime = Date.now();

                
                document.getElementById('session-start-btn').style.display = 'none';
                document.getElementById('session-stop-btn').style.display = 'flex';
                document.getElementById('session-status-label').textContent = 'Session active';
                document.getElementById('session-clock').classList.add('active');
                
                sessionTimerInterval = setInterval(updateSessionClock, 1000);
                updateSessionClock();
                saveHandHistory();
            }
        }

        async function endSession() {
            if (!sessionActive) return;
            if (!await nwConfirm('End this session?')) return;
            
            sessionActive = false;
            clearInterval(sessionTimerInterval);
            sessionTimerInterval = null;
            
            document.getElementById('session-start-btn').style.display = 'flex';
            document.getElementById('session-stop-btn').style.display = 'none';
            document.getElementById('session-clock').textContent = '00:00:00';
            document.getElementById('session-clock').classList.remove('active');
            document.getElementById('session-status-label').textContent = 'Session not started';
            saveHandHistory();
        }

        function updateSessionClock() {
            if (!sessionStartTime) return;
            const elapsed = Date.now() - sessionStartTime;
            const hrs = Math.floor(elapsed / 3600000);
            const mins = Math.floor((elapsed % 3600000) / 60000);
            const secs = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('session-clock').textContent = 
                hrs.toString().padStart(2, '0') + ':' + 
                mins.toString().padStart(2, '0') + ':' + 
                secs.toString().padStart(2, '0');
        }

        // ===== COLLAPSIBLE TOURNAMENT INFO =====
        var tourneyInfoCollapsed = false;
        
        function toggleTourneyInfo() {
            tourneyInfoCollapsed = !tourneyInfoCollapsed;
            var fields = document.getElementById('tourney-fields');
            var summary = document.getElementById('tourney-summary');
            var icon = document.getElementById('tourney-toggle-icon');
            
            if (tourneyInfoCollapsed) {
                buildTourneySummary();
                fields.style.display = 'none';
                summary.style.display = 'block';
                icon.textContent = '▶';
            } else {
                fields.style.display = 'block';
                summary.style.display = 'none';
                icon.textContent = '▼';
            }
        }
        
        function buildTourneySummary() {
            var parts = [];
            var buyin = document.getElementById('session-buyin');
            if (buyin && buyin.dataset.rawValue) parts.push('$' + parseInt(buyin.dataset.rawValue).toLocaleString());
            
            var stack = document.getElementById('session-stack');
            if (stack && stack.dataset.rawValue) parts.push(parseInt(stack.dataset.rawValue).toLocaleString() + ' chips');
            
            var blindMin = document.getElementById('session-blind-minutes');
            if (blindMin && blindMin.dataset.rawValue) parts.push(parseInt(blindMin.dataset.rawValue) + 'min levels');
            
            var formatChip = document.querySelector('#session-format-selector .desc-chip.active');
            if (formatChip) parts.push(formatChip.textContent);
            
            var venue = document.getElementById('session-venue');
            if (venue && venue.dataset.rawValue) parts.push(venue.dataset.rawValue);
            
            var notes = document.getElementById('session-tournotes');
            if (notes && notes.dataset.rawValue) parts.push(notes.dataset.rawValue);
            
            var textEl = document.getElementById('tourney-summary-text');
            if (parts.length === 0) {
                textEl.textContent = 'No info entered — tap to edit';
                textEl.style.fontStyle = 'italic';
                textEl.style.color = 'rgba(255,255,255,0.4)';
            } else {
                textEl.textContent = parts.join('  ·  ');
                textEl.style.fontStyle = 'normal';
                textEl.style.color = 'rgba(255,255,255,0.7)';
            }
        }
        
        // ===== QUICK PLAYER OBSERVATIONS =====
        var qoCurrentPlayer = null;
        var qoCurrentPlayerName = '';
        var qoHandNumber = 1;
        var qoPosition = '';
        var qoIpOop = '';
        var qoCurrentStreet = 'preflop';
        var qoStreetActions = { preflop: [], flop: [], turn: [], river: [] };
        var qoStoredHands = [];
        var qoViewingHand = null; // null = live hand
        var qoStreetOrder = ['preflop', 'flop', 'turn', 'river'];
        var qoStreetLabels = { preflop: 'PF', flop: 'F', turn: 'T', river: 'R' };
        var qoHandDone = false;
        var _qoLastNextTime = 0;
        var qoAwaitingResponse = false; // true after Raise/Bet/Re-Raise/Check — waiting to see if action comes back
        
        // Position → default IP/OOP mapping
        var qoPositionDefaults = { SB: 'OOP', BB: 'OOP', UTG: 'OOP', MP: 'OOP', LP: 'IP', D: 'IP' };
        
        // Initial action sets by position (preflop, first action)
        var qoPreflopInitial = {
            SB: ['Fold', 'Complete', 'Cold Call', 'Raise', 'All-in'],
            BB: ['Check', 'Fold', 'Call', 'Raise', 'All-in'],
            UTG: ['Fold', 'Limp', 'Call', 'Raise', 'All-in'],
            MP: ['Fold', 'Limp', 'Cold Call', 'Raise', 'All-in'],
            LP: ['Fold', 'Limp', 'Cold Call', 'Raise', 'All-in'],
            D:  ['Fold', 'Limp', 'Cold Call', 'Raise', 'All-in'],
            X:  ['Fold', 'Limp', 'Cold Call', 'Raise', 'All-in']
        };
        // When facing action back (re-raised, etc.) — same for all positions & streets
        var qoFacingActionButtons = ['Fold', 'Call', 'Re-Raise', 'All-in'];
        // Postflop initial actions
        var qoPostflopInitial = ['Check', 'Bet', 'Fold', 'Call', 'Raise', 'All-in'];
        // After a check (could get bet into)
        var qoAfterCheckButtons = ['Fold', 'Call', 'Raise', 'All-in'];
        
        // Actions that end the hand
        var qoHandEndActions = ['Fold', 'All-in'];
        // Actions that end the street (move to next)
        var qoStreetEndActions = []; // nothing auto-advances except IP Check/Call/Cold Call (handled explicitly)
        // Actions that keep the street open (opponent may act back)
        var qoOpenActions = ['Raise', 'Re-Raise', 'Bet', 'Check'];
        
        // Action → color mapping for log display
        var qoActionColors = {
            'Fold': 'rgba(239,68,68,0.8)', 'Check': 'rgba(255,255,255,0.6)',
            'Call': '#8dc4f0', 'Complete': '#8dc4f0', 'Limp': '#8dc4f0',
            'Bet': '#ff8c38', 'Raise': '#ff8c38', 'Re-Raise': '#ff8c38', 'All-in': '#ffc068'
        };
        
        // ======================================
        // QO DRUM — Quick Obs player picker
        // ======================================
        var QO_DRUM = {
            items: [],
            offset: 0,
            ITEM_H: 44,
            containerH: 132,
            selectedIndex: 0,
            isDragging: false,
            startY: 0,
            lastY: 0,
            velocity: 0,
            lastTime: 0,
            rafId: null,
            cylinder: null,
            container: null,
            overlay: null
        };

        function qoDrumRenderItems() {
            const n = QO_DRUM.items.length;
            if (n === 0) {
                QO_DRUM.cylinder.innerHTML = '<div style="position:absolute;top:50%;left:0;width:100%;transform:translateY(-50%);text-align:center;color:rgba(255,255,255,0.3);font-size:0.8rem;font-family:Outfit,sans-serif;">No players yet</div>';
                return;
            }
            const centerFloat = -QO_DRUM.offset / QO_DRUM.ITEM_H;
            const centerIdx = Math.round(centerFloat);
            QO_DRUM.selectedIndex = ((centerIdx % n) + n) % n;
            const centerY = QO_DRUM.containerH / 2 - QO_DRUM.ITEM_H / 2;
            const buffer = 3;
            let html = '';
            for (let delta = -buffer; delta <= buffer; delta++) {
                const logIdx = centerIdx + delta;
                const wIdx = ((logIdx % n) + n) % n;
                const player = QO_DRUM.items[wIdx];
                const itemY = centerY + (logIdx * QO_DRUM.ITEM_H + QO_DRUM.offset);
                const sel = (wIdx === QO_DRUM.selectedIndex && Math.abs(delta) < 0.5 + 0.01) ? ' selected' : '';
                // delta===0 is always the center
                const isSel = delta === 0 ? ' selected' : '';
                html += `<div class="apple-picker-item${isSel}" data-name="${player.name}" style="position:absolute;top:0;left:0;width:100%;transform:translateY(${itemY}px)">${player.name}</div>`;
            }
            QO_DRUM.cylinder.innerHTML = html;
        }

        function qoDrumSnap() {
            const n = QO_DRUM.items.length;
            if (n === 0) return;
            const centerIdx = Math.round(-QO_DRUM.offset / QO_DRUM.ITEM_H);
            QO_DRUM.offset = -centerIdx * QO_DRUM.ITEM_H;
            const wIdx = ((centerIdx % n) + n) % n;
            QO_DRUM.selectedIndex = wIdx;
            qoDrumRenderItems();
            // Sync hidden select and trigger player load
            const player = QO_DRUM.items[wIdx];
            if (player) {
                const select = document.getElementById('qo-player-select');
                if (select) {
                    select.value = player.name;
                    qoOnPlayerSelect();
                    try { localStorage.setItem('nitwiz_lastQoPlayer', player.name); } catch(e) {}
                }
            }
        }

        function qoDrumMomentum() {
            QO_DRUM.velocity *= 0.93;
            if (Math.abs(QO_DRUM.velocity) < 0.3) {
                QO_DRUM.velocity = 0;
                qoDrumSnap();
                return;
            }
            QO_DRUM.offset += QO_DRUM.velocity;
            qoDrumRenderItems();
            QO_DRUM.rafId = requestAnimationFrame(qoDrumMomentum);
        }

        function qoDrumInit() {
            QO_DRUM.cylinder = document.getElementById('qo-player-drum');
            QO_DRUM.container = document.getElementById('qo-drum-container');
            QO_DRUM.overlay = document.getElementById('qo-drum-touch-overlay');
            if (!QO_DRUM.cylinder || !QO_DRUM.overlay) return;

            // Always replace overlay to get a fresh event-listener surface
            var oldOverlay = QO_DRUM.overlay;
            var newOverlay = oldOverlay.cloneNode(false);
            oldOverlay.parentNode.replaceChild(newOverlay, oldOverlay);
            QO_DRUM.overlay = newOverlay;

            QO_DRUM.containerH = QO_DRUM.container.offsetHeight || 132;

            // Touch events
            QO_DRUM.overlay.addEventListener('touchstart', function(e) {
                if (QO_DRUM.rafId) { cancelAnimationFrame(QO_DRUM.rafId); QO_DRUM.rafId = null; }
                QO_DRUM.isDragging = true;
                QO_DRUM.startY = e.touches[0].clientY;
                QO_DRUM.lastY = QO_DRUM.startY;
                QO_DRUM.velocity = 0;
                QO_DRUM.lastTime = Date.now();
                e.preventDefault();
            }, { passive: false });

            QO_DRUM.overlay.addEventListener('touchmove', function(e) {
                if (!QO_DRUM.isDragging) return;
                const y = e.touches[0].clientY;
                const dy = y - QO_DRUM.lastY;
                const now = Date.now();
                const dt = now - QO_DRUM.lastTime || 16;
                QO_DRUM.velocity = dy / dt * 16;
                QO_DRUM.offset += dy;
                QO_DRUM.lastY = y;
                QO_DRUM.lastTime = now;
                qoDrumRenderItems();
                e.preventDefault();
            }, { passive: false });

            QO_DRUM.overlay.addEventListener('touchend', function(e) {
                QO_DRUM.isDragging = false;
                QO_DRUM.rafId = requestAnimationFrame(qoDrumMomentum);
            });

            // Mouse events
            QO_DRUM.overlay.addEventListener('mousedown', function(e) {
                if (QO_DRUM.rafId) { cancelAnimationFrame(QO_DRUM.rafId); QO_DRUM.rafId = null; }
                QO_DRUM.isDragging = true;
                QO_DRUM.startY = e.clientY;
                QO_DRUM.lastY = QO_DRUM.startY;
                QO_DRUM.velocity = 0;
                QO_DRUM.lastTime = Date.now();
                e.preventDefault();
            });
            QO_DRUM.overlay.addEventListener('mousemove', function(e) {
                if (!QO_DRUM.isDragging) return;
                const dy = e.clientY - QO_DRUM.lastY;
                const now = Date.now();
                const dt = now - QO_DRUM.lastTime || 16;
                QO_DRUM.velocity = dy / dt * 16;
                QO_DRUM.offset += dy;
                QO_DRUM.lastY = e.clientY;
                QO_DRUM.lastTime = now;
                qoDrumRenderItems();
            });
            QO_DRUM.overlay.addEventListener('mouseup', function(e) {
                if (!QO_DRUM.isDragging) return;
                QO_DRUM.isDragging = false;
                QO_DRUM.rafId = requestAnimationFrame(qoDrumMomentum);
            });
            QO_DRUM.overlay.addEventListener('mouseleave', function(e) {
                if (!QO_DRUM.isDragging) return;
                QO_DRUM.isDragging = false;
                QO_DRUM.rafId = requestAnimationFrame(qoDrumMomentum);
            });

            // Mouse wheel (Apple mouse / trackpad)
            QO_DRUM.overlay.addEventListener('wheel', function(e) {
                e.preventDefault();
                if (QO_DRUM.rafId) { cancelAnimationFrame(QO_DRUM.rafId); QO_DRUM.rafId = null; }
                const dir = e.deltaY > 0 ? 1 : -1;
                const currentIdx = Math.round(-QO_DRUM.offset / QO_DRUM.ITEM_H);
                QO_DRUM.offset = -(currentIdx + dir) * QO_DRUM.ITEM_H;
                qoDrumSnap();
            }, { passive: false });

            qoDrumRenderItems();
        }

        async function qoAddNewPlayer() {
            var newName = await nwPrompt('Enter new player name:', 'Player name');
            if (!newName || !newName.trim()) return;
            var trimmed = newName.trim();
            var dup = database.realPlayers.find(function(p) { return p.name.toLowerCase() === trimmed.toLowerCase(); });
            if (dup) {
                await nwAlert('Player already exists. Selecting them.');
                // Find index and snap drum to it
                var idx = QO_DRUM.items.findIndex(function(p) { return p.name === dup.name; });
                if (idx >= 0) { QO_DRUM.offset = -idx * QO_DRUM.ITEM_H; }
                qoDrumSnap();
                return;
            }
            database.realPlayers.push({
                name: trimmed,
                observationsList: [], weaknesses: [],
                vpip: null, limpBehavior: null, coldcall: null, openEP: null, openLP: null,
                pfrAggression: null, threeBetProfile: null, fold3bet: null,
                flopStrategy: null, foldcbet: null, postflopAggression: null,
                turnBehavior: null, riverBehavior: null,
                shortStack: null, midStack: null, deepStack: null,
                tableTalk: null, attention: null, cunning: null, thinking: null,
                tiltProfile: null, afterLoss: null, tanking: null, physicalConfidence: null,
                stackProtection: null, bubbleBehavior: null, finalTableAdj: null,
                payJumpAwareness: null, skillLevel: null,
                gender: null, age: null, ethnicity: null, education: null, profession: null,
                tglChasesDraws: 0, tglLimpAny: 0, tglFaceCards: 0, tglRiverCheap: 0,
                tglLimpJam: 0, tglCantRiver: 0, tglOverfolds: 0, tglNeverBluffRiver: 0,
                tglLimpCall: 0, tglSetMines: 0, tglAfraidBust: 0, tglNoLight3bet: 0,
                tglNoStackDepth: 0, tglTiltProne: 0, tglScaredMoney: 0, tglEgoDriven: 0,
                tglResultOriented: 0, tglRecklessPressure: 0
            });
            database.realPlayers.sort(function(a, b) { return a.name.localeCompare(b.name); });
            saveDatabase();
            if (typeof updatePlayerList === 'function') updatePlayerList();
            qoPopulateDropdown(); // rebuilds drum items
            // Jump drum to new player
            var newIdx = QO_DRUM.items.findIndex(function(p) { return p.name === trimmed; });
            if (newIdx >= 0) { QO_DRUM.offset = -newIdx * QO_DRUM.ITEM_H; }
            qoDrumSnap();
        }

        function qoDrumPopulate(selectName) {
            // Rebuild items array from database, sorted
            QO_DRUM.items = database && database.realPlayers
                ? [...database.realPlayers].sort(function(a,b){ return a.name.localeCompare(b.name); })
                : [];

            // Also rebuild hidden select for JS compat
            var select = document.getElementById('qo-player-select');
            if (select) {
                while (select.options.length > 1) select.remove(1);
                QO_DRUM.items.forEach(function(p) {
                    var opt = document.createElement('option');
                    opt.value = p.name;
                    opt.textContent = p.name;
                    select.appendChild(opt);
                });
            }

            // Find index to center on
            var targetName = selectName || qoCurrentPlayerName;
            if (!targetName) {
                try { targetName = localStorage.getItem('nitwiz_lastQoPlayer'); } catch(e) {}
            }
            var idx = 0;
            if (targetName) {
                var found = QO_DRUM.items.findIndex(function(p) { return p.name === targetName; });
                if (found >= 0) idx = found;
            }
            QO_DRUM.offset = -idx * QO_DRUM.ITEM_H;

            // Always re-init to get fresh DOM refs + re-bind events after tab paint
            setTimeout(function() {
                qoDrumInit();
                qoDrumRenderItems();

                // Auto-load player at center — but only if no hand is in progress or completed
                if (QO_DRUM.items.length > 0) {
                    var player = QO_DRUM.items[idx];
                    var handInProgress = qoHandDone || qoStreetOrder.some(function(s) { return qoStreetActions[s].length > 0; });
                    if (player && select && !handInProgress) {
                        select.value = player.name;
                        if (!qoCurrentPlayerName || qoCurrentPlayerName === player.name) {
                            qoOnPlayerSelect();
                        }
                    }
                }
            }, 50);
        }

        function qoPopulateDropdown() {
            // Delegates to drum-based picker
            qoDrumPopulate();
        }
        
        function qoExpandDrum() {
            document.getElementById('qo-drum-wrapper').style.display = 'block';
            document.getElementById('qo-player-collapsed').style.display = 'none';
            // Re-init after display:block so container dimensions are available
            setTimeout(function() {
                qoDrumInit();
                qoDrumRenderItems();
            }, 20);
        }
        
        async function qoOnPlayerSelect() {
            var select = document.getElementById('qo-player-select');
            var name = select.value;
            var tracker = document.getElementById('qo-tracker');
            
            // Handle add new player
            if (name === '__add_new__') {
                var newName = await nwPrompt('Enter new player name:', 'Player name');
                if (!newName || !newName.trim()) { select.value = qoCurrentPlayerName || ''; return; }
                var trimmed = newName.trim();
                var dup = database.realPlayers.find(function(p) { return p.name.toLowerCase() === trimmed.toLowerCase(); });
                if (dup) {
                    await nwAlert('Player already exists. Selecting them.');
                    select.value = dup.name;
                    name = dup.name;
                } else {
                    database.realPlayers.push({ name: trimmed });
                    database.realPlayers.sort(function(a, b) { return a.name.localeCompare(b.name); });
                    saveDatabase();
                    qoPopulateDropdown();
                    select.value = trimmed;
                    name = trimmed;
                    if (typeof updatePlayerList === 'function') updatePlayerList();
                }
            }
            
            if (!name) {
                tracker.style.display = 'none';
                document.getElementById('qo-drum-wrapper').style.display = 'block';
                document.getElementById('qo-player-collapsed').style.display = 'none';
                qoCurrentPlayer = null;
                qoCurrentPlayerName = '';
                return;
            }
            
            qoCurrentPlayer = database.realPlayers.find(function(p) { return p.name === name; });
            if (!qoCurrentPlayer) { tracker.style.display = 'none'; return; }
            
            qoCurrentPlayerName = name;
            try { localStorage.setItem('nitwiz_lastQoPlayer', name); } catch(e) {}
            // Load stored hands for this player
            if (!qoCurrentPlayer.quickObs) qoCurrentPlayer.quickObs = [];
            qoStoredHands = qoCurrentPlayer.quickObs;
            qoHandNumber = qoStoredHands.length > 0 ? Math.max.apply(null, qoStoredHands.map(function(h) { return h.hand; })) + 1 : 1;
            
            tracker.style.display = 'block';
            qoResetHand(true);
        }
        
        function qoResetHand(clearSeat) {
            if (clearSeat) {
                qoPosition = '';
                qoIpOop = '';
            }
            qoCurrentStreet = 'preflop';
            qoStreetActions = { preflop: [], flop: [], turn: [], river: [] };
            qoHandDone = false;
            qoAwaitingResponse = false;
            qoViewingHand = null;
            
            // Re-render seat chips to reflect persisted state
            document.querySelectorAll('#qo-tracker .qo-seat-chip[data-position]').forEach(function(c) {
                c.classList.remove('active');
                c.style.background = '';
                if (c.dataset.position === qoPosition) {
                    c.classList.add('active');
                    c.style.background = 'linear-gradient(135deg, #8dc4f0 0%, #6ea8dc 100%)';
                }
            });
            qoUpdateIpOopChips();
            
            qoUpdateHandNumber();
            qoRenderStreet();
            qoRenderActionLog();
            qoUpdateStats();
            var notesEl = document.getElementById('qo-hand-notes');
            if (notesEl) notesEl.value = '';
        }
        
        function qoSelectPosition(pos, el) {
            // Collapse drum and show player name now that user is entering hand data
            var drumWrapper = document.getElementById('qo-drum-wrapper');
            if (drumWrapper.style.display !== 'none' && qoCurrentPlayerName) {
                drumWrapper.style.display = 'none';
                document.getElementById('qo-player-collapsed-text').textContent = qoCurrentPlayerName;
                document.getElementById('qo-player-collapsed').style.display = 'block';
            }
            
            // Clear all seat chips
            el.parentElement.querySelectorAll('.qo-seat-chip').forEach(function(c) {
                c.classList.remove('active');
                c.style.background = '';
            });
            
            qoPosition = pos;
            el.classList.add('active');
            el.style.background = 'linear-gradient(135deg, #8dc4f0 0%, #6ea8dc 100%)';
            
            // Auto-derive IP/OOP
            qoIpOop = qoPositionDefaults[pos] || '';
            qoUpdateIpOopChips();
            qoRenderStreet();
        }
        
        function qoUpdateIpOopChips() {
            var ipChip = document.getElementById('qo-ip-chip');
            var oopChip = document.getElementById('qo-oop-chip');
            var locked = (qoPosition === 'SB' || qoPosition === 'D');
            
            ipChip.classList.remove('active');
            ipChip.style.background = '';
            ipChip.style.opacity = '';
            ipChip.style.pointerEvents = '';
            oopChip.classList.remove('active');
            oopChip.style.background = '';
            oopChip.style.opacity = '';
            oopChip.style.pointerEvents = '';
            
            if (qoIpOop === 'IP') {
                ipChip.classList.add('active');
                ipChip.style.background = 'linear-gradient(135deg, #ffa726 0%, #fb8c00 100%)';
            } else if (qoIpOop === 'OOP') {
                oopChip.classList.add('active');
                oopChip.style.background = 'linear-gradient(135deg, #ffa726 0%, #fb8c00 100%)';
            }
            
            // Lock: SB is always OOP, D is always IP — disable the other option
            if (qoPosition === 'SB') {
                ipChip.style.opacity = '0.25';
                ipChip.style.pointerEvents = 'none';
            } else if (qoPosition === 'D') {
                oopChip.style.opacity = '0.25';
                oopChip.style.pointerEvents = 'none';
            }
        }
        
        function qoOverrideIpOop(val, el) {
            // Prevent override for locked positions
            if (qoPosition === 'SB' && val === 'IP') return;
            if (qoPosition === 'D' && val === 'OOP') return;
            qoIpOop = val;
            qoUpdateIpOopChips();
        }
        
        function qoRenderStreet() {
            var label = document.getElementById('qo-street-label');
            var btnContainer = document.getElementById('qo-action-buttons');
            var streetNames = { preflop: 'Preflop', flop: 'Flop', turn: 'Turn', river: 'River' };
            
            // #4 — Show hand complete when done
            if (qoHandDone) {
                label.innerHTML = '<span style="color: #4ade80;">✓ Hand Complete</span>';
                btnContainer.innerHTML = '';
                return;
            }
            
            if (qoViewingHand !== null) {
                // Viewing past hand — show last street reached
                label.innerHTML = '<span style="color: rgba(255,167,38,0.7);">' + (streetNames[qoCurrentStreet] || 'Preflop') + ' (viewing)</span>';
                btnContainer.innerHTML = '';
                return;
            }
            
            label.textContent = streetNames[qoCurrentStreet] || 'Preflop';
            
            // Determine which buttons to show based on state
            var actions;
            var currentActions = qoStreetActions[qoCurrentStreet];
            var lastAction = currentActions.length > 0 ? currentActions[currentActions.length - 1] : null;
            
            if (qoAwaitingResponse) {
                if (lastAction === 'Check') {
                    actions = qoAfterCheckButtons;
                } else {
                    actions = qoFacingActionButtons;
                }
            } else if (currentActions.length === 0) {
                if (qoCurrentStreet === 'preflop') {
                    var pos = qoPosition || 'X';
                    actions = qoPreflopInitial[pos] || qoPreflopInitial.X;
                } else {
                    actions = qoPostflopInitial;
                }
            } else {
                actions = qoPostflopInitial;
            }
            
            var html = '';
            
            // Fold PF quick button — shown only on fresh preflop hands (no actions yet)
            if (qoCurrentStreet === 'preflop' && currentActions.length === 0 && !qoAwaitingResponse) {
                html += '<button class="qo-action-btn" onclick="qoFoldPreflop()" style="'
                    + 'width: 100%; padding: 0.55rem 0.4rem; margin-bottom: 4px;'
                    + 'background: linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95));'
                    + 'border: 1px solid rgba(239, 68, 68, 0.4);'
                    + 'border-radius: 6px; font-family: \'Outfit\', sans-serif;'
                    + 'font-size: 0.75rem; font-weight: 700; color: rgba(239, 68, 68, 0.75);'
                    + 'cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.2);'
                    + 'letter-spacing: 0.04em;'
                    + '">Fold PF (no data)</button>';
            }
            
            // Render action buttons
            actions.forEach(function(action) {
                html += qoBuildActionButton(action);
            });
            
            // Add advance button when awaiting response (no action came back)
            if (qoAwaitingResponse) {
                var onRiver = (qoCurrentStreet === 'river');
                var borderColor = onRiver ? 'rgba(255, 140, 56, 0.5)' : 'rgba(141, 196, 240, 0.5)';
                var textColor  = onRiver ? '#ff8c38' : '#8dc4f0';
                var btnIcon    = onRiver
                    ? '<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><polyline points="20 6 9 17 4 12"></polyline></svg>'
                    : '<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin-right:4px;"><polyline points="9 18 15 12 9 6"></polyline></svg>';
                var btnText    = onRiver ? 'End Hand' : 'Next Street';
                var btnAction  = onRiver ? 'qoEndHand()' : 'qoAdvanceStreet()';
                html += '<button onclick="' + btnAction + '" style="';
                html += 'flex: 1 1 auto; min-width: 80px; padding: 0.7rem 0.5rem;';
                html += 'background: transparent;';
                html += 'border: 2px solid ' + borderColor + ';';
                html += 'border-radius: 6px; font-family: \'Outfit\', sans-serif;';
                html += 'font-size: 0.75rem; font-weight: 700; color: ' + textColor + ';';
                html += 'cursor: pointer;';
                html += '">' + btnIcon + btnText + '</button>';
            }
            
            // #1 — Undo link if any actions recorded
            var totalActions = qoStreetOrder.reduce(function(sum, s) { return sum + qoStreetActions[s].length; }, 0);
            if (totalActions > 0) {
                html += '<div style="width: 100%; text-align: right; margin-top: 4px;">';
                html += '<span onclick="qoUndo()" style="font-family: \'Outfit\', sans-serif; font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.4); cursor: pointer; display:inline-flex; align-items:center; gap:3px;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 .49-3.5"></path></svg>Undo</span>';
                html += '</div>';
            }
            
            btnContainer.innerHTML = html;
        }
        
        function qoBuildActionButton(action) {
            var bgColor = 'linear-gradient(145deg, rgba(22, 34, 62, 0.85), rgba(18, 28, 52, 0.95))';
            var borderColor = 'rgba(255, 255, 255, 0.35)';
            var textColor = 'rgba(255, 255, 255, 0.9)';
            
            if (action === 'Fold') {
                borderColor = 'rgba(239, 68, 68, 0.4)';
                textColor = 'rgba(239, 68, 68, 0.9)';
            }
            

            
            var html = '<button class="qo-action-btn" onclick="qoTapAction(\'' + action + '\')" style="';
            html += 'flex: 1 1 auto; min-width: 55px; padding: 0.7rem 0.4rem;';
            html += 'background: ' + bgColor + ';';
            html += 'border: 1px solid ' + borderColor + ';';
            html += 'border-radius: 6px; font-family: \'Outfit\', sans-serif;';
            html += 'font-size: 0.8rem; font-weight: 700; color: ' + textColor + ';';
            html += 'cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.2);';
            html += '">' + action + '</button>';
            return html;
        }
        
        function qoTapAction(action) {
            if (qoHandDone || qoViewingHand !== null) return;
            
            // Record action on current street
            qoStreetActions[qoCurrentStreet].push(action);
            
            var isIP = (qoIpOop === 'IP');
            
            // Determine next state
            if (qoHandEndActions.indexOf(action) >= 0) {
                // Fold or All-in — hand over regardless of position
                qoHandDone = true;
                qoAwaitingResponse = false;
                qoSaveCurrentHand();
            } else if (isIP && (action === 'Check' || action === 'Call' || action === 'Cold Call')) {
                // IP acting last — Check, Call, or Cold Call closes the street
                qoAwaitingResponse = false;
                qoAdvanceStreetInternal();
                if (qoHandDone) qoSaveCurrentHand(); // river just ended
            } else if (qoStreetEndActions.indexOf(action) >= 0) {
                // Preflop-only closers (Limp, Complete, Cold Call OOP) — always close street
                qoAwaitingResponse = false;
                qoAdvanceStreetInternal();
                if (qoHandDone) qoSaveCurrentHand();
            } else {
                // Raise/Re-Raise/Bet, OOP Check, OOP Call — could face action back
                qoAwaitingResponse = true;
            }
            
            qoRenderStreet();
            qoRenderActionLog();
        }
        
        function qoEndHand() {
            // Explicitly end the hand on the river — save and mark complete, stay on this hand
            qoAwaitingResponse = false;
            qoHandDone = true;
            qoSaveCurrentHand();
            qoRenderStreet();
            qoRenderActionLog();
        }
        
        function qoAdvanceStreet() {
            // User tapped "→" — no action came back, advance to next street
            qoAwaitingResponse = false;
            qoAdvanceStreetInternal();
            if (qoHandDone) qoSaveCurrentHand(); // river just ended via advance
            qoRenderStreet();
            qoRenderActionLog();
        }
        
        function qoAdvanceStreetInternal() {
            var idx = qoStreetOrder.indexOf(qoCurrentStreet);
            if (idx < qoStreetOrder.length - 1) {
                qoCurrentStreet = qoStreetOrder[idx + 1];
            } else {
                qoHandDone = true; // River ended
            }
        }
        
        // #1 — Undo last action
        function qoUndo() {
            if (qoViewingHand !== null) return;
            
            // If hand is done, un-done it
            if (qoHandDone) {
                qoHandDone = false;
            }
            
            var isIP = (qoIpOop === 'IP');
            
            // Helper: given the last recorded action, should we be awaiting a response?
            function _deriveAwaiting(lastAction) {
                if (!lastAction) return false;
                if (qoHandEndActions.indexOf(lastAction) >= 0) return false;
                if (isIP && (lastAction === 'Check' || lastAction === 'Call' || lastAction === 'Cold Call')) return false;
                if (qoStreetEndActions.indexOf(lastAction) >= 0) return false;
                // Raise/Bet/Re-Raise, OOP Check, OOP Call — awaiting response
                return true;
            }
            
            // Pop last action from current street
            var currentActions = qoStreetActions[qoCurrentStreet];
            if (currentActions.length > 0) {
                currentActions.pop();
                var lastAction = currentActions.length > 0 ? currentActions[currentActions.length - 1] : null;
                qoAwaitingResponse = _deriveAwaiting(lastAction);
            } else {
                // Current street is empty — go back to previous street
                var idx = qoStreetOrder.indexOf(qoCurrentStreet);
                if (idx > 0) {
                    qoCurrentStreet = qoStreetOrder[idx - 1];
                    var prevActions = qoStreetActions[qoCurrentStreet];
                    if (prevActions.length > 0) {
                        prevActions.pop();
                        var lastAction = prevActions.length > 0 ? prevActions[prevActions.length - 1] : null;
                        qoAwaitingResponse = _deriveAwaiting(lastAction);
                    }
                }
            }
            
            qoRenderStreet();
            qoRenderActionLog();
        }
        
        // #6 — Running stats
        function qoUpdateStats() {
            var statsEl = document.getElementById('qo-stats-bar');
            if (!statsEl) return;
            
            if (!qoStoredHands || qoStoredHands.length === 0) {
                statsEl.style.display = 'none';
                return;
            }
            
            var total = qoStoredHands.length;
            var vpipCount = 0;
            var pfrCount = 0;
            var foldPfCount = 0;
            var farCount = 0;    // hands where player folded after raising on any street
            var raisedCount = 0; // hands where player raised on any street (denominator for FAR)
            
            var raiseActions = ['Raise', 'Re-Raise', 'Bet'];
            
            qoStoredHands.forEach(function(h) {
                if (h.vpip) vpipCount++;
                if (h.pfr) pfrCount++;
                
                var pf = h.streets && h.streets.preflop;
                var firstPf = Array.isArray(pf) ? pf[0] : pf;
                if (firstPf === 'Fold' || h.pfFold) foldPfCount++;
                
                // FAR: did they raise/bet on any street, then fold on a later action or street?
                var didRaise = false;
                var foldedAfter = false;
                var streets = h.streets || {};
                ['preflop', 'flop', 'turn', 'river'].forEach(function(s) {
                    var acts = streets[s];
                    if (!acts) return;
                    var actArr = Array.isArray(acts) ? acts : [acts];
                    actArr.forEach(function(a) {
                        if (raiseActions.indexOf(a) >= 0) didRaise = true;
                        if (a === 'Fold' && didRaise) foldedAfter = true;
                    });
                });
                
                if (didRaise) raisedCount++;
                if (foldedAfter) farCount++;
            });
            
            var vpipPct = Math.round((vpipCount / total) * 100);
            var pfrPct = Math.round((pfrCount / total) * 100);
            var foldPfPct = Math.round((foldPfCount / total) * 100);
            var farPct = raisedCount > 0 ? Math.round((farCount / raisedCount) * 100) : 0;
            
            var dot = '  <span style="color: rgba(255,255,255,0.25);">·</span>  ';
            
            statsEl.style.display = 'block';
            statsEl.innerHTML = '<span style="color: rgba(255,255,255,0.5);">' + total + ' hands</span>'
                + dot + '<span style="color: #8dc4f0;">VPIP ' + vpipPct + '%</span>'
                + dot + '<span style="color: #ff8c38;">PFR ' + pfrPct + '%</span>'
                + dot + '<span style="color: rgba(239,68,68,0.7);">PF Fold ' + foldPfPct + '%</span>'
                + dot + '<span style="color: rgba(255,192,104,0.8);">FAR ' + farPct + '%</span>'
                + (raisedCount > 0 ? '<span style="color: rgba(255,255,255,0.3);"> (' + farCount + '/' + raisedCount + ')</span>' : '');
        }
        
        function qoRenderActionLog() {
            var container = document.getElementById('qo-action-log');
            var html = '';
            var hasActions = false;
            
            qoStreetOrder.forEach(function(street) {
                var actions = qoStreetActions[street];
                if (actions && actions.length > 0) {
                    hasActions = true;
                    if (html) html += '<br>';
                    html += '<span style="font-weight: 800; color: #ffc068;">' + qoStreetLabels[street] + '</span><span style="color: rgba(255,255,255,0.3);">:</span> ';
                    actions.forEach(function(action, i) {
                        if (i > 0) html += ' <span style="color: rgba(255,255,255,0.25);">→</span> ';
                        var color = action === 'Fold' ? 'rgba(239,68,68,0.85)' : 'rgba(255,255,255,0.55)';
                        html += '<span style="font-weight: 600; color: ' + color + ';">' + action + '</span>';
                    });
                }
            });
            
            if (!hasActions && qoViewingHand === null) {
                html = '<span style="color: rgba(255,255,255,0.3); font-style: italic;">Tap an action to begin recording</span>';
            }
            
            container.innerHTML = '<div style="font-family: \'Outfit\', sans-serif; font-size: 0.85rem; line-height: 1.8;">' + html + '</div>';
        }
        
        function qoUpdateHandNumber() {
            var el = document.getElementById('qo-hand-number');
            var btn = document.getElementById('qo-next-hand-btn');
            var lastLink = document.getElementById('qo-last-hand-link');
            if (!el) return;
            if (qoViewingHand !== null) {
                el.textContent = 'Hand #' + qoViewingHand.hand + ' (viewing)';
                el.style.color = 'rgba(255, 167, 38, 0.7)';
                if (btn) btn.innerHTML = 'Return to Live';
                if (lastLink) lastLink.style.display = 'none';
            } else if (qoHandDone) {
                // Hand complete but user hasn't tapped New yet — don't advance the display
                return;
            } else {
                var newLabel = 'Hand #' + qoHandNumber;
                var changed = el.textContent !== newLabel;
                el.textContent = newLabel;
                el.style.color = '#ff8c38';
                if (changed) {
                    el.classList.remove('qo-hand-num-pulse');
                    void el.offsetWidth; // force reflow to restart animation
                    el.classList.add('qo-hand-num-pulse');
                    setTimeout(function() { el.classList.remove('qo-hand-num-pulse'); }, 1000);
                }
                if (btn) btn.innerHTML = 'New <svg width="17" height="18" viewBox="0 0 20 22" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="12" x2="4" y2="4"/><line x1="9" y1="12" x2="9" y2="1"/><line x1="14" y1="12" x2="14" y2="1"/><line x1="19" y1="12" x2="19" y2="4"/><path d="M4 12 Q2 20 10 21 Q18 21 19 12"/></svg>';
                if (lastLink) lastLink.style.display = (qoStoredHands && qoStoredHands.length > 0) ? 'block' : 'none';
            }
        }
        
        function qoSaveCurrentHand() {
            // Only save if at least one action was recorded
            var hasAction = qoStreetOrder.some(function(s) { return qoStreetActions[s].length > 0; });
            if (!hasAction) return;
            
            var handData = {
                hand: qoHandNumber,
                position: qoPosition || 'X',
                ipOop: qoIpOop || 'X',
                streets: JSON.parse(JSON.stringify(qoStreetActions)),
                notes: (document.getElementById('qo-hand-notes').value || '').trim(),
                timestamp: Date.now()
            };
            
            // Compute VPIP from first preflop action
            var pfActions = qoStreetActions.preflop;
            var firstPfAction = pfActions.length > 0 ? pfActions[0] : null;
            if (!firstPfAction || firstPfAction === 'Fold') {
                handData.vpip = false;
            } else if (qoPosition === 'BB' && firstPfAction === 'Check') {
                handData.vpip = false;
            } else {
                handData.vpip = true;
            }
            
            // Compute PFR — did they raise at any point preflop?
            handData.pfr = pfActions.some(function(a) {
                return a === 'Raise' || a === 'Re-Raise' || a === 'All-in';
            });
            
            // Store
            if (!qoCurrentPlayer.quickObs) qoCurrentPlayer.quickObs = [];
            var existIdx = qoCurrentPlayer.quickObs.findIndex(function(h) { return h.hand === qoHandNumber; });
            if (existIdx >= 0) {
                qoCurrentPlayer.quickObs[existIdx] = handData;
            } else {
                qoCurrentPlayer.quickObs.push(handData);
            }
            qoStoredHands = qoCurrentPlayer.quickObs;
            saveDatabase();
            qoUpdateStats();
        }
        
        function qoNextHand() {
            var now = Date.now();
            if (now - _qoLastNextTime < 500) return;
            _qoLastNextTime = now;
            
            // If viewing a past hand, just return to live
            if (qoViewingHand !== null) {
                qoViewingHand = null;
                qoResetHand();
                return;
            }
            
            // Re-save to capture any notes entered after auto-save on completion
            qoSaveCurrentHand();
            qoHandNumber++;
            qoResetHand();
        }
        
        function qoFoldPreflop() {
            if (qoHandDone || qoViewingHand !== null) return;
            // Save a minimal hand record: dealt, folded preflop, no voluntary action
            var handData = {
                hand: qoHandNumber,
                position: qoPosition || 'X',
                ipOop: qoIpOop || 'X',
                streets: { preflop: ['Fold'], flop: [], turn: [], river: [] },
                notes: '',
                timestamp: Date.now(),
                vpip: false,
                pfr: false,
                pfFold: true
            };
            if (!qoCurrentPlayer.quickObs) qoCurrentPlayer.quickObs = [];
            var existIdx = qoCurrentPlayer.quickObs.findIndex(function(h) { return h.hand === qoHandNumber; });
            if (existIdx >= 0) {
                qoCurrentPlayer.quickObs[existIdx] = handData;
            } else {
                qoCurrentPlayer.quickObs.push(handData);
            }
            qoStoredHands = qoCurrentPlayer.quickObs;
            saveDatabase();
            qoHandNumber++;
            qoResetHand();
        }
        
        function qoPreviousHand() {
            if (qoStoredHands.length === 0) return;
            
            if (qoViewingHand === null) {
                // Save current first if it has actions
                qoSaveCurrentHand();
                qoViewingHand = qoStoredHands[qoStoredHands.length - 1];
            } else {
                var idx = qoStoredHands.findIndex(function(h) { return h.hand === qoViewingHand.hand; });
                if (idx > 0) {
                    qoViewingHand = qoStoredHands[idx - 1];
                } else {
                    return;
                }
            }
            qoLoadViewedHand();
        }
        
        function qoNextStoredHand() {
            if (qoViewingHand === null) return;
            var idx = qoStoredHands.findIndex(function(h) { return h.hand === qoViewingHand.hand; });
            if (idx < qoStoredHands.length - 1) {
                qoViewingHand = qoStoredHands[idx + 1];
                qoLoadViewedHand();
            } else {
                // Return to live
                qoViewingHand = null;
                qoResetHand();
            }
        }
        
        function qoLoadViewedHand() {
            if (!qoViewingHand) return;
            
            qoStreetActions = JSON.parse(JSON.stringify(qoViewingHand.streets));
            // Backward compat: convert old single-action format to arrays
            qoStreetOrder.forEach(function(s) {
                if (qoStreetActions[s] && !Array.isArray(qoStreetActions[s])) {
                    qoStreetActions[s] = [qoStreetActions[s]];
                } else if (!qoStreetActions[s]) {
                    qoStreetActions[s] = [];
                }
            });
            qoPosition = qoViewingHand.position || '';
            qoIpOop = qoViewingHand.ipOop || '';
            qoHandDone = true;
            qoAwaitingResponse = false;
            
            // Find the last street with actions
            qoCurrentStreet = 'preflop';
            for (var i = qoStreetOrder.length - 1; i >= 0; i--) {
                if (qoStreetActions[qoStreetOrder[i]] && qoStreetActions[qoStreetOrder[i]].length > 0) {
                    qoCurrentStreet = qoStreetOrder[i]; break;
                }
            }
            
            // Highlight seat chip
            document.querySelectorAll('#qo-tracker .qo-seat-chip[data-position]').forEach(function(c) {
                c.classList.remove('active');
                c.style.background = '';
                if (c.dataset.position === qoPosition) {
                    c.classList.add('active');
                    c.style.background = 'linear-gradient(135deg, #8dc4f0 0%, #6ea8dc 100%)';
                }
            });
            
            qoUpdateIpOopChips();
            qoUpdateHandNumber();
            qoRenderStreet();
            qoRenderActionLog();
            var notesEl = document.getElementById('qo-hand-notes');
            if (notesEl) notesEl.value = qoViewingHand.notes || '';
        }
        
        function qoShowHandJumpMenu() {
            if (qoStoredHands.length === 0) return;
            
            var existing = document.getElementById('qo-jump-overlay');
            if (existing) { existing.remove(); return; }
            
            var overlay = document.createElement('div');
            overlay.id = 'qo-jump-overlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; display: flex; align-items: center; justify-content: center;';
            
            var panel = document.createElement('div');
            panel.style.cssText = 'background: linear-gradient(145deg, #1a2440, #141c34); border: 1px solid rgba(255,140,56,0.3); border-radius: 10px; padding: 1rem; max-height: 60vh; overflow-y: auto; min-width: 260px; max-width: 320px;';
            
            var title = document.createElement('div');
            title.textContent = 'Jump to Hand';
            title.style.cssText = "font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 800; color: #ff8c38; margin-bottom: 0.75rem; text-align: center;";
            panel.appendChild(title);
            
            qoStoredHands.forEach(function(h) {
                var row = document.createElement('div');
                row.style.cssText = "display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; border-radius: 6px; cursor: pointer; margin-bottom: 4px;";
                
                var actionsStr = '';
                qoStreetOrder.forEach(function(s) {
                    var acts = h.streets[s];
                    if (acts && (Array.isArray(acts) ? acts.length > 0 : acts)) {
                        if (actionsStr) actionsStr += ' | ';
                        var actList = Array.isArray(acts) ? acts : [acts];
                        actionsStr += qoStreetLabels[s] + ':' + actList.join('→');
                    }
                });
                
                var isActive = qoViewingHand && qoViewingHand.hand === h.hand;
                if (isActive) row.style.background = 'rgba(255,140,56,0.2)';
                
                var label = document.createElement('span');
                label.textContent = '#' + h.hand + '  ' + (h.position || 'X') + '  ' + actionsStr;
                label.style.cssText = "font-family: 'Outfit', sans-serif; font-size: 0.8rem; font-weight: 600; color: " + (isActive ? '#ffc068' : 'rgba(255,255,255,0.85)') + "; flex: 1;";
                row.appendChild(label);
                
                // Delete button
                var delBtn = document.createElement('button');
                delBtn.innerHTML = '✕';
                delBtn.style.cssText = "background: none; border: none; color: rgba(239,68,68,0.6); font-size: 0.85rem; cursor: pointer; padding: 4px 6px; border-radius: 4px; line-height: 1; flex-shrink: 0;";
                delBtn.onmouseenter = function() { this.style.color = '#ef4444'; this.style.background = 'rgba(239,68,68,0.15)'; };
                delBtn.onmouseleave = function() { this.style.color = 'rgba(239,68,68,0.6)'; this.style.background = 'none'; };
                (function(handNum) {
                    delBtn.onclick = function(e) {
                        e.stopPropagation();
                        var idx = qoStoredHands.findIndex(function(x) { return x.hand === handNum; });
                        if (idx >= 0) { qoStoredHands.splice(idx, 1); saveDatabase(); qoUpdateStats(); }
                        if (qoViewingHand && qoViewingHand.hand === handNum) { qoViewingHand = null; qoResetHand(); }
                        overlay.remove();
                    };
                })(h.hand);
                row.appendChild(delBtn);
                
                (function(hand) {
                    label.onclick = function() {
                        overlay.remove();
                        qoViewingHand = hand;
                        qoLoadViewedHand();
                    };
                })(h);
                
                panel.appendChild(row);
            });
            
            overlay.appendChild(panel);
            overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };
            document.body.appendChild(overlay);
        }

        // Initialize blind display
        updateBlindDisplay();

        // ===== HAND HISTORY =====
        var hhSelectedSeat=null,hhSelectedPos='',hhSavedHands=[];
        var hhStreetActions={preflop:[],flop:[],turn:[],river:[]};
        
        // Position action order for each street
        var hhActionOrder = {
            preflop: ['UTG', 'MP', 'HJ', 'CO', 'D', 'SB', 'BB'],
            postflop: ['SB', 'BB', 'UTG', 'MP', 'HJ', 'CO', 'D']
        };
        
        function hhGetTrackedPlayersInOrder(street) {
            var tracked = getTrackedPlayers();
            if (tracked.length === 0) return [];
            
            var order = street === 'preflop' ? hhActionOrder.preflop : hhActionOrder.postflop;
            
            // Sort tracked players by action order
            return tracked.sort(function(a, b) {
                var aIdx = order.indexOf(a.position);
                var bIdx = order.indexOf(b.position);
                if (aIdx === -1) aIdx = 999;
                if (bIdx === -1) bIdx = 999;
                return aIdx - bIdx;
            });
        }
        var hhActionChoices=['Check','Bet','Fold','Call','Limp','Raise','Re-Raise','All-in'];
        var hhNeedsAmount={Bet:1,Raise:1,'Re-Raise':1,'All-in':1};
        
        // Check if an action is a betting action (keeps action open)
        function hhIsBettingAction(action) {
            return action === 'Bet' || action === 'Raise' || action === 'Re-Raise' || action === 'All-in';
        }
        
        // Check if an action closes the betting round
        function hhClosesRound(action) {
            return action === 'Call' || action === 'Check' || action === 'Fold';
        }
        
        // Get valid actions based on previous action (action hierarchy)
        function hhGetValidActions(street, currentPlayerName) {
            var trackedPlayers = getTrackedPlayers();
            
            // SIMPLE MODE: When tracking 0 or 1 player, show simplified actions
            if (trackedPlayers.length <= 1) {
                if (street === 'preflop') {
                    // PreFlop: No Check option
                    return ['Bet', 'Call', 'Fold', 'All-in', 'Re-Raise'];
                } else {
                    // Post-Flop: Include Check
                    return ['Check', 'Bet', 'Call', 'Fold', 'All-in', 'Re-Raise'];
                }
            }
            
            // COMPLEX MODE: When tracking 2 players, use full poker logic
            var acts = hhStreetActions[street];
            if (!acts || acts.length === 0) {
                // First action on the street
                if (street === 'preflop') {
                    // First actor preflop: Bet or Limp only
                    return ['Bet', 'Limp'];
                } else {
                    return ['Check', 'Bet', 'All-in'];
                }
            }
            
            // Find the last action by the OTHER player (not current player)
            var lastOpponentAction = null;
            for (var i = acts.length - 1; i >= 0; i--) {
                if (acts[i].action && acts[i].player !== currentPlayerName) {
                    lastOpponentAction = acts[i].action;
                    break;
                }
            }
            
            // If no opponent action yet, it's the first action
            if (!lastOpponentAction) {
                if (street === 'preflop') {
                    return ['Bet', 'Limp'];
                } else {
                    return ['Check', 'Bet', 'All-in'];
                }
            }
            
            // After opponent folds, hand is over
            if (lastOpponentAction === 'Fold') {
                return [];
            }
            
            // After opponent checks: Check / Bet / Fold / All-in
            if (lastOpponentAction === 'Check') {
                return ['Check', 'Bet', 'Fold', 'All-in'];
            }
            
            // After Bet: Call / Raise / All-in / Fold
            if (lastOpponentAction === 'Bet') {
                return ['Fold', 'Call', 'Raise', 'All-in'];
            }
            
            // After Raise: Call / Re-Raise / All-in / Fold
            if (lastOpponentAction === 'Raise') {
                return ['Fold', 'Call', 'Re-Raise', 'All-in'];
            }
            
            // After Re-Raise: Call / Re-Raise / All-in / Fold
            if (lastOpponentAction === 'Re-Raise') {
                return ['Fold', 'Call', 'Re-Raise', 'All-in'];
            }
            
            // After All-in: Call / All-in / Fold
            if (lastOpponentAction === 'All-in') {
                return ['Fold', 'Call', 'All-in'];
            }
            
            // After opponent calls, round is complete (they closed the betting)
            if (lastOpponentAction === 'Call') {
                return [];
            }
            
            // Special PreFlop case: After Limp
            if (lastOpponentAction === 'Limp' && street === 'preflop') {
                return ['Check', 'Raise', 'All-in', 'Fold'];
            }
            
            // Fallback
            return hhActionChoices;
        }
        var hhSelectedOutcome='',hhSelectedDetail='';
        var hhCurrentHandIdx=1,hhHandCounter=0,hhIsReadonly=false;

        // Legacy stubs (session players removed)
        function hhSyncSeats() {}
        function hhGetPlayerName(seat) { return ''; }
        
        function hhAddAction(street) {
            if(hhIsReadonly) return;
            
            // Check if previous street is complete before allowing action on current street
            if (street === 'flop' && !hhIsStreetComplete('preflop')) {
                return; // PreFlop not complete
            }
            if (street === 'turn' && (!hhIsStreetComplete('preflop') || !hhIsStreetComplete('flop'))) {
                return; // PreFlop or Flop not complete
            }
            if (street === 'river' && (!hhIsStreetComplete('preflop') || !hhIsStreetComplete('flop') || !hhIsStreetComplete('turn'))) {
                return; // PreFlop, Flop, or Turn not complete
            }
            
            var trackedPlayers = hhGetTrackedPlayersInOrder(street);
            
            if (trackedPlayers.length === 0) {
                // No tracked players - use old behavior
                hhStreetActions[street].push({action:'',amount:'',note:''});
            } else if (trackedPlayers.length === 1) {
                // One tracked player - add action with that player
                hhStreetActions[street].push({
                    player: trackedPlayers[0].name,
                    action: '',
                    amount: '',
                    note: ''
                });
            } else {
                // Multiple tracked players - determine next player to act
                var lastPlayer = null;
                var acts = hhStreetActions[street];
                
                // Find the last player who acted
                for(var i = acts.length - 1; i >= 0; i--) {
                    if(acts[i].player) {
                        lastPlayer = acts[i].player;
                        break;
                    }
                }
                
                // Determine next player in action order
                var nextPlayer = null;
                if(!lastPlayer) {
                    // No previous actions, start with first player
                    nextPlayer = trackedPlayers[0].name;
                } else {
                    // Find current player's index and get next
                    var currentIdx = -1;
                    for(var i = 0; i < trackedPlayers.length; i++) {
                        if(trackedPlayers[i].name === lastPlayer) {
                            currentIdx = i;
                            break;
                        }
                    }
                    
                    // Cycle to next player (wraps around)
                    if(currentIdx !== -1) {
                        var nextIdx = (currentIdx + 1) % trackedPlayers.length;
                        nextPlayer = trackedPlayers[nextIdx].name;
                    } else {
                        // Fallback to first player
                        nextPlayer = trackedPlayers[0].name;
                    }
                }
                
                hhStreetActions[street].push({
                    player: nextPlayer,
                    action: '',
                    amount: '',
                    note: ''
                });
            }
            
            hhRenderStreet(street);
            
            // Focus the action dropdown
            var cells = document.querySelectorAll('.hh-action-select[data-street="'+street+'"]');
            if(cells.length) setTimeout(function(){cells[cells.length-1].focus()},30);
        }

        function hhRenderStreet(street){
            var c = document.getElementById('actions-' + street);
            var acts = hhStreetActions[street];
            var trackedPlayers = hhGetTrackedPlayersInOrder(street);
            
            // Check if previous streets are complete before rendering this street
            var shouldRender = true;
            if (street === 'flop' && !hhIsStreetComplete('preflop')) {
                shouldRender = false;
            }
            if (street === 'turn' && (!hhIsStreetComplete('preflop') || !hhIsStreetComplete('flop'))) {
                shouldRender = false;
            }
            if (street === 'river' && (!hhIsStreetComplete('preflop') || !hhIsStreetComplete('flop') || !hhIsStreetComplete('turn'))) {
                shouldRender = false;
            }
            
            if(!shouldRender || !acts.length){
                c.innerHTML = '';
                hhRenderPlayerCount(street);
                return;
            }
            
            // Read-only mode
            if(hhIsReadonly){
                var h = '';
                for(var i = 0; i < acts.length; i++){
                    if(!acts[i].action) continue;
                    if(h) h += '<span class="hh-dash">\u2013</span>';
                    
                    // Show player first name if present
                    if(acts[i].player) {
                        var firstName = acts[i].player.split(' ')[0];
                        h += '<span class="hh-player-name">' + firstName + ': </span>';
                    }
                    
                    var amt = acts[i].amount ? ' <span class="hh-at-amt">' + parseInt(acts[i].amount).toLocaleString() + '</span>' : '';
                    h += '<span class="hh-action-text">' + acts[i].action + amt + '</span>';
                }
                c.innerHTML = h;
                hhRenderPlayerCount(street);
                return;
            }
            
            // Edit mode - check if we have 2 tracked players for column layout
            var isStreetComplete = hhIsStreetComplete(street);
            
            if(trackedPlayers.length === 2) {
                // Two-column layout: one column per player
                var player1 = trackedPlayers[0];
                var player2 = trackedPlayers[1];
                
                // Separate actions by player
                var player1Actions = [];
                var player2Actions = [];
                
                for(var i = 0; i < acts.length; i++) {
                    if(acts[i].player === player1.name) {
                        player1Actions.push({index: i, action: acts[i]});
                    } else if(acts[i].player === player2.name) {
                        player2Actions.push({index: i, action: acts[i]});
                    }
                }
                
                var h = '<div class="hh-two-column-layout">';
                
                // Player 1 column
                h += '<div class="hh-player-column">';
                h += '<div class="hh-player-column-header">' + player1.name.split(' ')[0] + '</div>';
                for(var i = 0; i < player1Actions.length; i++) {
                    var item = player1Actions[i];
                    var a = item.action;
                    var idx = item.index;
                    var sa = a.action && hhNeedsAmount[a.action];
                    var isLastAction = (idx === acts.length - 1);
                    
                    h += '<div class="hh-action-cell">';
                    
                    // Show as text if: (1) not the last action, OR (2) street is complete
                    if(a.action && (!isLastAction || isStreetComplete)) {
                        var amt = a.amount ? ' ' + parseInt(a.amount).toLocaleString() : '';
                        h += '<span class="hh-action-display" onclick="hhMakeEditable(\'' + street + '\',' + idx + ')">' + a.action + amt + '</span>';
                    } else {
                        // Show dropdown for last action or incomplete actions
                        var actionsToShow;
                        if (a.action) {
                            actionsToShow = hhActionChoices;
                        } else {
                            actionsToShow = hhGetValidActions(street, a.player);
                        }
                        
                        h += '<select class="hh-action-select' + (a.action ? ' has-value' : '') + '" data-street="' + street + '" data-idx="' + idx + '" onchange="hhOnActionChange(this)">';
                        h += '<option value="">...</option>';
                        
                        for(var j = 0; j < actionsToShow.length; j++){
                            h += '<option value="' + actionsToShow[j] + '"' + (a.action === actionsToShow[j] ? ' selected' : '') + '>' + actionsToShow[j] + '</option>';
                        }
                        h += '</select>';
                        
                        h += '<input type="text" class="hh-action-amt' + (sa ? ' visible' : '') + '" data-street="' + street + '" data-idx="' + idx + '" inputmode="numeric" placeholder="$" value="' + (a.amount || '') + '" onchange="hhOnAmtChange(this)" onkeydown="hhOnAmtKey(event,this)">';
                        h += '<button class="hh-action-x" onclick="hhRemoveAction(\'' + street + '\',' + idx + ')">\u2715</button>';
                    }
                    h += '</div>';
                }
                h += '</div>';
                
                // Player 2 column
                h += '<div class="hh-player-column">';
                h += '<div class="hh-player-column-header">' + player2.name.split(' ')[0] + '</div>';
                for(var i = 0; i < player2Actions.length; i++) {
                    var item = player2Actions[i];
                    var a = item.action;
                    var idx = item.index;
                    var sa = a.action && hhNeedsAmount[a.action];
                    var isLastAction = (idx === acts.length - 1);
                    
                    h += '<div class="hh-action-cell">';
                    
                    // Show as text if: (1) not the last action, OR (2) street is complete
                    if(a.action && (!isLastAction || isStreetComplete)) {
                        var amt = a.amount ? ' ' + parseInt(a.amount).toLocaleString() : '';
                        h += '<span class="hh-action-display" onclick="hhMakeEditable(\'' + street + '\',' + idx + ')">' + a.action + amt + '</span>';
                    } else {
                        // Show dropdown for last action or incomplete actions
                        var actionsToShow;
                        if (a.action) {
                            actionsToShow = hhActionChoices;
                        } else {
                            actionsToShow = hhGetValidActions(street, a.player);
                        }
                        
                        h += '<select class="hh-action-select' + (a.action ? ' has-value' : '') + '" data-street="' + street + '" data-idx="' + idx + '" onchange="hhOnActionChange(this)">';
                        h += '<option value="">...</option>';
                        
                        for(var j = 0; j < actionsToShow.length; j++){
                            h += '<option value="' + actionsToShow[j] + '"' + (a.action === actionsToShow[j] ? ' selected' : '') + '>' + actionsToShow[j] + '</option>';
                        }
                        h += '</select>';
                        
                        h += '<input type="text" class="hh-action-amt' + (sa ? ' visible' : '') + '" data-street="' + street + '" data-idx="' + idx + '" inputmode="numeric" placeholder="$" value="' + (a.amount || '') + '" onchange="hhOnAmtChange(this)" onkeydown="hhOnAmtKey(event,this)">';
                        h += '<button class="hh-action-x" onclick="hhRemoveAction(\'' + street + '\',' + idx + ')">\u2715</button>';
                    }
                    h += '</div>';
                }
                h += '</div>';
                
                h += '</div>';
                c.innerHTML = h;
                
            } else {
                // Single column layout (0 or 1 tracked player)
                var h = '';
                for(var i = 0; i < acts.length; i++){
                    var a = acts[i];
                    var sa = a.action && hhNeedsAmount[a.action];
                    var isLastAction = (i === acts.length - 1);
                    
                    if(i > 0) h += '<span class="hh-dash">\u2013</span>';
                    
                    h += '<div class="hh-action-cell">';
                    
                    // Show player first name label if present
                    if(a.player) {
                        var firstName = a.player.split(' ')[0];
                        h += '<span class="hh-player-label">' + firstName + '</span>';
                    }
                    
                    // Show as text if: (1) not the last action, OR (2) street is complete
                    if(a.action && (!isLastAction || isStreetComplete)) {
                        var amt = a.amount ? ' ' + parseInt(a.amount).toLocaleString() : '';
                        h += '<span class="hh-action-display" onclick="hhMakeEditable(\'' + street + '\',' + i + ')">' + a.action + amt + '</span>';
                    } else {
                        // Show dropdown for last action or incomplete actions
                        var actionsToShow;
                        if (a.action) {
                            actionsToShow = hhActionChoices;
                        } else if (a.player) {
                            actionsToShow = hhGetValidActions(street, a.player);
                        } else {
                            actionsToShow = hhActionChoices;
                        }
                        
                        h += '<select class="hh-action-select' + (a.action ? ' has-value' : '') + '" data-street="' + street + '" data-idx="' + i + '" onchange="hhOnActionChange(this)">';
                        h += '<option value="">...</option>';
                        
                        for(var j = 0; j < actionsToShow.length; j++){
                            h += '<option value="' + actionsToShow[j] + '"' + (a.action === actionsToShow[j] ? ' selected' : '') + '>' + actionsToShow[j] + '</option>';
                        }
                        h += '</select>';
                        
                        h += '<input type="text" class="hh-action-amt' + (sa ? ' visible' : '') + '" data-street="' + street + '" data-idx="' + i + '" inputmode="numeric" placeholder="$" value="' + (a.amount || '') + '" onchange="hhOnAmtChange(this)" onkeydown="hhOnAmtKey(event,this)">';
                        h += '<button class="hh-action-x" onclick="hhRemoveAction(\'' + street + '\',' + i + ')">\u2715</button>';
                    }
                    h += '</div>';
                }
                c.innerHTML = h;
            }
            
            hhRenderPlayerCount(street);
        }
        
        function hhMakeEditable(street, idx) {
            // Temporarily mark this action as editable by rendering
            // We'll just re-render - the check for isLastAction will be false for everything
            // So we need a different approach - let's add a flag
            hhRenderStreet(street);
            // Focus the dropdown
            var sel = document.querySelector('.hh-action-select[data-street="'+street+'"][data-idx="'+idx+'"]');
            if(sel) setTimeout(function(){sel.focus()},30);
        }

        function hhRenderPlayerCount(street){if(street==='preflop'){var nw=document.getElementById('pf-note-wrap'),ni=document.getElementById('pf-note');if(!nw||!ni)return;if(hhIsReadonly){var nv=ni.value.trim();nw.innerHTML=nv?'<span class="hh-pf-note-text">'+nv+'</span>':'';ni.style.display='none';}else{nw.innerHTML='';ni.style.display='';}return;}var w=document.getElementById('pc-wrap-'+street),s=document.getElementById('players-'+street),cw=document.getElementById('cc-wrap-'+street),ci=document.getElementById('cc-'+street);if(!w||!s||!cw||!ci)return;if(hhIsReadonly){var v=s.value;w.innerHTML=v?'<span class="hh-pc-text">'+v+'</span>':'<span class="hh-pc-text">\u2013</span>';s.style.display='none';var cv=ci.value.trim();cw.innerHTML=cv?'<span class="hh-cc-text">'+cv+'</span>':'<span class="hh-cc-text">\u2013</span>';ci.style.display='none';}else{w.innerHTML='';s.style.display='';cw.innerHTML='';ci.style.display='';}}


        function hhOnActionChange(sel){
            var st=sel.dataset.street;
            var idx=+sel.dataset.idx;
            
            hhStreetActions[st][idx].action=sel.value;
            hhStreetActions[st][idx].amount='';
            hhRenderStreet(st);
            hhCheckForFold();
            hhCheckForShowdown();
            hhUpdateStreetStates();
            
            if(hhNeedsAmount[sel.value]){
                var inp=document.querySelector('.hh-action-amt[data-street="'+st+'"][data-idx="'+idx+'"]');
                if(inp)setTimeout(function(){inp.focus()},30);
            }
        }
        
        function hhIsStreetComplete(street) {
            var acts = hhStreetActions[street];
            if (!acts || acts.length === 0) return false;
            
            // Get tracked players (use global function, not street-specific)
            var trackedPlayers = getTrackedPlayers();
            
            // If we're tracking 2 players, we need at least 2 actions for completion
            if (trackedPlayers.length === 2 && acts.length < 2) {
                return false;
            }
            
            // Get last action
            var lastAction = null;
            for (var i = acts.length - 1; i >= 0; i--) {
                if (acts[i].action) {
                    lastAction = acts[i].action;
                    break;
                }
            }
            
            // No action yet
            if (!lastAction) return false;
            
            // Fold always ends the hand immediately
            if (lastAction === 'Fold') return true;
            
            // SIMPLE MODE: Street completes immediately if 0 or 1 tracked player (any action except Fold)
            if (trackedPlayers.length <= 1) {
                // Any action that's not Fold completes the street
                return true;
            }
            
            // TWO PLAYER MODE: Full poker logic
            if (trackedPlayers.length === 2) {
                var trackedPlayersInOrder = hhGetTrackedPlayersInOrder(street);
                var player1Name = trackedPlayersInOrder[0].name;
                var player2Name = trackedPlayersInOrder[1].name;
                
                var player1Acted = false;
                var player2Acted = false;
                
                for (var i = 0; i < acts.length; i++) {
                    if (acts[i].action) {
                        if (acts[i].player === player1Name) player1Acted = true;
                        if (acts[i].player === player2Name) player2Acted = true;
                    }
                }
                
                // Both players must have acted
                if (!player1Acted || !player2Acted) {
                    return false;
                }
            }
            
            // Sequences that end a street:
            // - Check → Check (all streets)
            // - Bet → Call
            // - Raise → Call  
            // - Re-Raise → Call
            
            // Call or Check closes the round (after both players have acted)
            if (lastAction === 'Call' || lastAction === 'Check') {
                return true;
            }
            
            // Betting actions keep the round open
            return false;
        }
        
        var hhUpdateCounter = 0;
        
        function hhUpdateStreetStates() {
            hhUpdateCounter++;
            
            var streets = ['preflop', 'flop', 'turn', 'river'];
            var allRows = document.querySelectorAll('.hh-table-row');
            
            // Check completion status of each street
            var preflopComplete = hhIsStreetComplete('preflop');
            var flopComplete = hhIsStreetComplete('flop');
            var turnComplete = hhIsStreetComplete('turn');
            
            // Grey out streets based on completion
            allRows.forEach(function(row, idx) {
                if (idx === 0) {
                    // Preflop - always enabled
                    row.classList.remove('hh-street-disabled');
                } else if (idx === 1) {
                    // Flop - disabled until preflop complete
                    if (preflopComplete) {
                        row.classList.remove('hh-street-disabled');
                    } else {
                        row.classList.add('hh-street-disabled');
                    }
                } else if (idx === 2) {
                    // Turn - disabled until flop complete
                    if (preflopComplete && flopComplete) {
                        row.classList.remove('hh-street-disabled');
                    } else {
                        row.classList.add('hh-street-disabled');
                    }
                } else if (idx === 3) {
                    // River - disabled until turn complete
                    if (preflopComplete && flopComplete && turnComplete) {
                        row.classList.remove('hh-street-disabled');
                    } else {
                        row.classList.add('hh-street-disabled');
                    }
                }
            });
            
            // Disable + buttons on completed streets to prevent accidental additions
            var addPreflopBtn = document.getElementById('hh-add-preflop');
            var addFlopBtn = document.getElementById('hh-add-flop');
            var addTurnBtn = document.getElementById('hh-add-turn');
            var addRiverBtn = document.getElementById('hh-add-river');
            
            // Disable + button if street is complete
            if (addPreflopBtn) addPreflopBtn.disabled = preflopComplete;
            if (addFlopBtn) addFlopBtn.disabled = flopComplete;
            if (addTurnBtn) addTurnBtn.disabled = turnComplete;
            if (addRiverBtn) addRiverBtn.disabled = hhIsStreetComplete('river');
            
            // Re-render all streets to show/hide actions based on completion
            streets.forEach(function(st) {
                hhRenderStreet(st);
            });
        }
        
        function hhOnCombinedActionChange(sel) {
            var st = sel.dataset.street;
            var idx = +sel.dataset.idx;
            var value = sel.value;
            
            if (!value) {
                hhStreetActions[st][idx].player = '';
                hhStreetActions[st][idx].action = '';
                hhStreetActions[st][idx].amount = '';
                hhRenderStreet(st);
                return;
            }
            
            // Split "PlayerName::Action"
            var parts = value.split('::');
            if (parts.length === 2) {
                hhStreetActions[st][idx].player = parts[0];
                hhStreetActions[st][idx].action = parts[1];
                hhStreetActions[st][idx].amount = '';
                hhRenderStreet(st);
                hhCheckForFold();
                
                // Focus amount if needed
                if(hhNeedsAmount[parts[1]]){
                    var inp=document.querySelector('.hh-action-amt[data-street="'+st+'"][data-idx="'+idx+'"]');
                    if(inp)setTimeout(function(){inp.focus()},30);
                }
            }
        }
        
        function hhOnAmtChange(inp){hhStreetActions[inp.dataset.street][+inp.dataset.idx].amount=inp.value.trim();}
        function hhOnAmtKey(e,inp){if(e.key==='Enter'){e.preventDefault();inp.blur();}}
        function hhRemoveAction(st,idx){hhStreetActions[st].splice(idx,1);hhRenderStreet(st);hhCheckForFold();hhUpdateStreetStates();}
        var hhStreetLabels={preflop:'Pre-flop',flop:'Flop',turn:'Turn',river:'River'};

        function hhCheckForShowdown() {
            var showdownSection = document.getElementById('hh-showdown-section');
            var showdownPlayers = document.getElementById('hh-showdown-players');
            var outcomeSection = document.getElementById('hh-outcome-section');
            if (!showdownSection || !showdownPlayers) return;
            
            var trackedPlayers = getTrackedPlayers();
            
            // Show outcome input only when tracking 0 or 1 player
            if (outcomeSection) {
                if (trackedPlayers.length <= 1) {
                    outcomeSection.style.display = 'block';
                } else {
                    outcomeSection.style.display = 'none';
                }
            }
            
            // Showdown section only for 2 players
            if (trackedPlayers.length !== 2) {
                showdownSection.style.display = 'none';
                return;
            }
            
            var hasShowdown = false;
            var streets = ['preflop', 'flop', 'turn', 'river'];
            
            // Check for showdown sequences on any street:
            // 1. All-in → Call
            // 2. All-in → All-in
            for (var s = 0; s < streets.length; s++) {
                var acts = hhStreetActions[streets[s]];
                for (var i = 0; i < acts.length - 1; i++) {
                    // All-in followed by Call
                    if (acts[i].action === 'All-in' && acts[i + 1].action === 'Call') {
                        hasShowdown = true;
                        break;
                    }
                    // All-in followed by All-in
                    if (acts[i].action === 'All-in' && acts[i + 1].action === 'All-in') {
                        hasShowdown = true;
                        break;
                    }
                }
                if (hasShowdown) break;
            }
            
            // Check for Check-Check on River only (showdown)
            if (!hasShowdown && hhIsStreetComplete('river')) {
                var riverActs = hhStreetActions['river'];
                if (riverActs && riverActs.length > 0) {
                    var lastAction = null;
                    for (var i = riverActs.length - 1; i >= 0; i--) {
                        if (riverActs[i].action) {
                            lastAction = riverActs[i].action;
                            break;
                        }
                    }
                    // Showdown if River ends with Call or Check (not Fold)
                    if (lastAction === 'Call' || lastAction === 'Check') {
                        hasShowdown = true;
                    }
                }
            }
            
            if (hasShowdown) {
                // Show showdown section and create input fields for each player
                showdownSection.style.display = 'block';
                
                var html = '';
                for (var i = 0; i < trackedPlayers.length; i++) {
                    var playerName = trackedPlayers[i].name.split(' ')[0];
                    html += '<div class="hh-showdown-player">';
                    html += '<div class="hh-showdown-player-name">' + playerName + '</div>';
                    html += '<input type="text" class="hh-showdown-cards-input" placeholder="AsKh" maxlength="4" data-player="' + trackedPlayers[i].name + '">';
                    html += '</div>';
                }
                showdownPlayers.innerHTML = html;
            } else {
                showdownSection.style.display = 'none';
            }
        }
        
        function hhCheckForFold(){
            // Outcome section removed - fold detection no longer needed
        }

        function hhToggleOutcome(el){
            // Outcome section removed
        }
        function hhToggleDetail(el){
            // Outcome section removed
        }

        function hhSetReadonly(on){
            hhIsReadonly=on;
            var card=document.getElementById('hh-card-inner');
            if(card){
                if(on)card.classList.add('readonly');
                else card.classList.remove('readonly');
            }
            ['preflop','flop','turn','river'].forEach(function(st){hhRenderStreet(st);});
        }

        function hhBuildHandData(){
            var player=hhGetPlayerName(hhSelectedSeat)||'Player';
            var pos=hhSelectedPos||'?';
            var time=new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:true});
            var sts=['preflop','flop','turn','river'];
            var lbls={preflop:'PF',flop:'F',turn:'T',river:'R'};
            var parts=[];
            
            for(var s=0;s<sts.length;s++){
                var st=sts[s];
                var acts=hhStreetActions[st].filter(function(a){return a.action});
                if(!acts.length)continue;
                
                var cc=st==='preflop'?'':(document.getElementById('cc-'+st)?document.getElementById('cc-'+st).value.trim():'');
                var chain=acts.map(function(a){
                    var amt=a.amount?' '+parseInt(a.amount).toLocaleString():'';
                    return a.action+amt;
                }).join(' → ');
                
                var label=lbls[st];
                if(cc)chain='['+cc+'] '+chain;
                parts.push(label+': '+chain);
            }
            
            var notesEl=document.getElementById('hh-notes');
            var notes=notesEl?notesEl.value.trim():'';
            if(notes)parts.push('"'+notes+'"');
            
            var outcomeEl=document.getElementById('hh-outcome-input');
            var outcome=outcomeEl?outcomeEl.value.trim():'';
            
            return {
                time:time,
                text:'🃏 '+player+' ('+pos+') — '+parts.join(' | '),
                data:{
                    seat:hhSelectedSeat,
                    pos:hhSelectedPos,
                    streets:JSON.parse(JSON.stringify(hhStreetActions)),
                    communityCards:JSON.parse(JSON.stringify(hhTrackerCommunityCards)),
                    outcome:outcome,
                    notes:notes
                }
            };
        }

        function hhHasContent(){return['preflop','flop','turn','river'].some(function(st){return hhStreetActions[st].some(function(a){return a.action})})||hhSelectedOutcome||hhGetPlayerName(hhSelectedSeat);}

        function hhRebuildEntry(entry){var d=entry.data,player=hhGetPlayerName(d.seat),pos=d.pos||'?',sts=['preflop','flop','turn','river'],lbls={preflop:'PF',flop:'F',turn:'T',river:'R'},parts=[];for(var s=0;s<sts.length;s++){var st=sts[s],acts=d.streets[st].filter(function(a){return a.action});if(!acts.length)continue;var pc=st==='preflop'?'':(d.playerCounts[st]||'');var cc=st==='preflop'?'':(d.communityCards?d.communityCards[st]:'');var chain=acts.map(function(a){var amt=a.amount?' '+parseInt(a.amount).toLocaleString():'';var nt=a.note?' ('+a.note+')':'';return a.action+amt+nt}).join(' \u2192 ');var label=lbls[st];if(pc)label+='('+pc+')';if(cc)chain='['+cc+'] '+chain;if(st==='preflop'&&d.pfNote)chain+=' ('+d.pfNote+')';parts.push(label+': '+chain);}if(d.outcome&&d.outcome!=='Fold'){var o=d.outcome;if(o==='Wins'&&d.detail){if(d.detail==='Shows')o+=' \u2014 Shows'+(d.showsHand?' '+d.showsHand:'');else o+=' \u2014 No SD';}parts.push(o);}if(d.notes)parts.push('"'+d.notes+'"');entry.text='\uD83C\uDCCF '+player+' ('+pos+') \u2014 '+parts.join(' | ');return entry;}

        function hhAutoSaveCurrent(){if(!hhHasContent()||!hhGetPlayerName(hhSelectedSeat))return;if(hhCurrentHandIdx>=0){hhSavedHands[hhCurrentHandIdx].data.notes=document.getElementById('hh-notes').value.trim();hhSavedHands[hhCurrentHandIdx]=hhRebuildEntry(hhSavedHands[hhCurrentHandIdx]);}else{hhHandCounter++;var entry=hhBuildHandData();entry.handNum=hhHandCounter;hhSavedHands.push(entry);hhCurrentHandIdx=hhSavedHands.length-1;}}

        function hhSaveAndNext() {
            console.log('Save & Next clicked');
            console.log('Current index:', hhCurrentHandIdx);
            console.log('Saved hands:', hhSavedHands.length);
            
            // Build hand data
            try {
                var entry = hhBuildHandData();
                entry.handNum = hhCurrentHandIdx;
                
                if (hhCurrentHandIdx <= hhSavedHands.length) {
                    // Update existing hand (array is 0-indexed, so Hand #1 is at position 0)
                    console.log('Updating Hand #' + hhCurrentHandIdx);
                    hhSavedHands[hhCurrentHandIdx - 1] = entry;
                } else {
                    // Create new hand
                    console.log('Creating new Hand #' + hhCurrentHandIdx);
                    hhHandCounter++;
                    hhSavedHands.push(entry);
                }
                
                console.log('Saved. Total hands:', hhSavedHands.length);
            } catch (e) {
                console.error('Error saving hand:', e);
            }
            
            // Move to next hand (new entry)
            hhCurrentHandIdx = hhSavedHands.length + 1;
            console.log('Moving to Hand #' + hhCurrentHandIdx);
            
            // Clear for next entry
            hhStreetActions = {preflop:[], flop:[], turn:[], river:[]};
            
            var notesInput = document.getElementById('hh-notes');
            if (notesInput) notesInput.value = '';
            
            ['flop','turn','river'].forEach(function(st){
                var ccInput = document.getElementById('cc-' + st);
                if (ccInput) ccInput.value = '';
            });
            
            var outcomeInput = document.getElementById('hh-outcome-input');
            if (outcomeInput) outcomeInput.value = '';
            
            // Update UI
            hhSetReadonly(false);
            hhUpdateHandNumber();
            hhUpdateStreetStates();
            ['preflop', 'flop', 'turn', 'river'].forEach(function(st) {
                hhRenderStreet(st);
            });
            hhUpdateNavButtons();
        }
        
        function hhUpdateNavButtons() {
            var prevBtn = document.querySelector('.hh-nav-btn[onclick*="hhPrevHand"]');
            var nextBtn = document.querySelector('.hh-nav-btn[onclick*="hhNextHand"]');
            
            if (prevBtn) {
                // Disable prev if at first hand (index 1)
                if (hhCurrentHandIdx <= 1) {
                    prevBtn.disabled = true;
                    prevBtn.style.opacity = '0.3';
                    prevBtn.style.cursor = 'not-allowed';
                } else {
                    prevBtn.disabled = false;
                    prevBtn.style.opacity = '1';
                    prevBtn.style.cursor = 'pointer';
                }
            }
            
            if (nextBtn) {
                // Disable next if already on new hand (beyond saved hands)
                if (hhCurrentHandIdx > hhSavedHands.length) {
                    nextBtn.disabled = true;
                    nextBtn.style.opacity = '0.3';
                    nextBtn.style.cursor = 'not-allowed';
                } else {
                    nextBtn.disabled = false;
                    nextBtn.style.opacity = '1';
                    nextBtn.style.cursor = 'pointer';
                }
            }
        }
        
        function hhPrevHand(){
            if (hhCurrentHandIdx <= 1) return;
            hhAutoSaveCurrent();
            hhCurrentHandIdx--;
            hhLoadHand(hhCurrentHandIdx);
            hhUpdateNavButtons();
        }
        
        function hhNextHand(){
            if (hhCurrentHandIdx > hhSavedHands.length) return;
            hhAutoSaveCurrent();
            hhCurrentHandIdx++;
            
            if (hhCurrentHandIdx <= hhSavedHands.length) {
                // Load saved hand
                hhLoadHand(hhCurrentHandIdx);
            } else {
                // Clear for new hand
                hhStreetActions = {preflop:[], flop:[], turn:[], river:[]};
                var notesInput = document.getElementById('hh-notes');
                if (notesInput) notesInput.value = '';
                ['flop','turn','river'].forEach(function(st){
                    var ccInput = document.getElementById('cc-' + st);
                    if (ccInput) ccInput.value = '';
                });
                var outcomeInput = document.getElementById('hh-outcome-input');
                if (outcomeInput) outcomeInput.value = '';
                
                hhSetReadonly(false);
                hhUpdateHandNumber();
                hhUpdateStreetStates();
                ['preflop', 'flop', 'turn', 'river'].forEach(function(st) {
                    hhRenderStreet(st);
                });
            }
            
            hhUpdateNavButtons();
        }

        function hhLoadHand(index){
            console.log('Loading Hand #' + index);
            
            // Hand #1 is at array position 0, Hand #2 at position 1, etc.
            var arrayPos = index - 1;
            var h = hhSavedHands[arrayPos];
            
            if(!h || !h.data) {
                console.log('No hand data for Hand #' + index);
                return;
            }
            
            hhCurrentHandIdx = index;
            var d = h.data;
            
            // Set player and position
            hhSelectedSeat = d.seat;
            hhSelectedPos = d.pos || '';
            
            // Update position chips
            document.querySelectorAll('.hh-pos-chip').forEach(function(c){
                if(d.pos && c.dataset.pos === d.pos) {
                    c.classList.add('active');
                } else {
                    c.classList.remove('active');
                }
            });
            
            // Load street actions
            hhStreetActions = JSON.parse(JSON.stringify(d.streets));
            
            // Load cards
            ['flop','turn','river'].forEach(function(st){
                var ccInput = document.getElementById('cc-' + st);
                if (ccInput && d.communityCards) {
                    ccInput.value = d.communityCards[st] || '';
                }
            });
            
            // Load notes
            var notesInput = document.getElementById('hh-notes');
            if (notesInput) {
                notesInput.value = d.notes || '';
            }
            
            // Load outcome
            var outcomeInput = document.getElementById('hh-outcome-input');
            if (outcomeInput) {
                outcomeInput.value = d.outcome || '';
            }
            
            // Update UI - editable
            hhSetReadonly(false);
            hhUpdateHandNumber();
            hhUpdateStreetStates();
            ['preflop', 'flop', 'turn', 'river'].forEach(function(st) {
                hhRenderStreet(st);
            });
            hhUpdateNavButtons();
            
            console.log('Hand #' + index + ' loaded');
        }

        function hhNewHand(preservePlayerAndPosition){
            try {
                console.log('hhNewHand called, preserve:', preservePlayerAndPosition);
                hhCurrentHandIdx = -1;
                hhStreetActions = {preflop:[], flop:[], turn:[], river:[]};
                console.log('Street actions cleared');
                
                // Save current selections if preserving
                var savedSeat = preservePlayerAndPosition ? hhSelectedSeat : null;
                var savedPos = preservePlayerAndPosition ? hhSelectedPos : '';
                console.log('Saved seat:', savedSeat, 'Saved pos:', savedPos);
                
                // Reset player and position
                hhSelectedSeat = savedSeat; // Keep seat if preserving, otherwise null
                hhSelectedPos = savedPos; // Keep position if preserving, otherwise ''
                
                // Reset position chips (then restore if preserving)
                document.querySelectorAll('.hh-pos-chip').forEach(function(c){
                    c.classList.remove('active');
                });
                
                if (savedPos) {
                    document.querySelectorAll('.hh-pos-chip').forEach(function(c){
                        if(c.dataset.pos === savedPos) {
                            c.classList.add('active');
                        }
                    });
                    console.log('Restored position:', hhSelectedPos);
                }
                
                // Clear notes and cards
                var notesInput = document.getElementById('hh-notes');
                if (notesInput) notesInput.value = '';
                
                ['flop','turn','river'].forEach(function(st){
                    var ccInput = document.getElementById('cc-' + st);
                    if (ccInput) ccInput.value = '';
                });
                
                // Clear outcome input
                var outcomeInput = document.getElementById('hh-outcome-input');
                if (outcomeInput) outcomeInput.value = '';
                
                console.log('About to call hhSetReadonly...');
                hhSetReadonly(false);
                console.log('hhSetReadonly completed');
                
                console.log('About to call hhUpdateHandNumber...');
                hhUpdateHandNumber();
                console.log('hhUpdateHandNumber completed');
                
                console.log('About to call hhUpdateStreetStates...');
                hhUpdateStreetStates();
                console.log('hhUpdateStreetStates completed');
                
                console.log('About to re-render streets...');
                // Re-render all streets to ensure they display properly
                ['preflop', 'flop', 'turn', 'river'].forEach(function(st) {
                    hhRenderStreet(st);
                });
                console.log('Streets re-rendered. Current hand index:', hhCurrentHandIdx);
                
                hhUpdateNavButtons();
            } catch (e) {
                console.error('Error in hhNewHand:', e);
            }
        }

        function hhUpdateHandNumber(){
            var el=document.getElementById('hh-hand-number');
            var nav=document.getElementById('hh-nav-counter');
            
            // Title always shows current index
            el.textContent = 'Hand #' + hhCurrentHandIdx;
            
            // Counter shows position
            if (hhCurrentHandIdx <= hhSavedHands.length) {
                // Viewing a saved hand
                nav.innerHTML = hhCurrentHandIdx + ' / ' + hhSavedHands.length;
            } else {
                // On a new unsaved hand
                nav.innerHTML = hhCurrentHandIdx + ' / ' + hhCurrentHandIdx;
            }
        }

        // ===== HAND TRACKER STATE =====
        let hhTrackerHero = null;
        let hhTrackerHeroFirstName = null;
        let hhTrackerHeroPosition = null;
        let hhTrackerVillainName = null;
        let hhTrackerVillainFirstName = null;
        let hhTrackerVillainPosition = null;
        let hhTrackerPositionType = null;
        let hhTrackerCurrentStreet = 'preflop';
        let hhTrackerStreetActions = { preflop: [], flop: [], turn: [], river: [] };
        let hhTrackerCommunityCards = { flop: '', turn: '', river: '' };
        let hhTrackerPendingAction = null;
        let hhTrackerNextActor = null;
        let hhTrackerWinner = null;
        
        // Hand storage
        let hhStoredHands = [];
        let hhCurrentHandNumber = 1;
        let hhViewingHandNumber = null; // null means current live hand
        
        // Load persisted hand history and session
        (function loadHandHistory() {
            try {
                const saved = localStorage.getItem('nitwiz_handHistory');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    hhStoredHands = parsed.hands || [];
                    hhCurrentHandNumber = parsed.nextHandNumber || (hhStoredHands.length + 1);
                }
                const savedSession = localStorage.getItem('nitwiz_sessionData');
                if (savedSession) {
                    const sess = JSON.parse(savedSession);
                    window._pendingSessionRestore = sess;
                }
            } catch(e) { console.warn('Failed to load hand history:', e); }
        })();
        
        function getSessionSnapshot() {
            // Tournament Info — prefer dataset.rawValue (set after commit) over .value
            function getFieldVal(id) {
                var el = document.getElementById(id);
                if (!el) return '';
                return el.dataset.rawValue || el.value || '';
            }
            
            const buyin = getFieldVal('session-buyin');
            const blindMin = getFieldVal('session-blind-minutes');
            const stack = getFieldVal('session-stack');
            const venue = getFieldVal('session-venue');
            const tournotes = getFieldVal('session-tournotes');
            const formatSel = document.querySelector('#session-format-selector .desc-chip.active');
            const format = formatSel ? parseInt(formatSel.dataset.value) : 0;
            
            return {
                // Tournament info
                buyin: buyin,
                blindMinutes: blindMin,
                startingStack: stack,
                venue: venue,
                tournotes: tournotes,
                format: format,
                // Table setup
                blindLevel: currentBlindLevel,
                blindStructure: JSON.parse(JSON.stringify(blindStructure)),
                // Live session state
                sessionActive: sessionActive,
                sessionStartTime: sessionStartTime
            };
        }
        
        var _isRestoring = false;
        
        function restoreSessionSnapshot(sess) {
            if (!sess) return;
            _isRestoring = true;
            try {
                // Tournament info — set both value and rawValue for each field
                var fieldMap = {
                    'session-buyin': sess.buyin,
                    'session-blind-minutes': sess.blindMinutes,
                    'session-stack': sess.startingStack,
                    'session-venue': sess.venue,
                    'session-tournotes': sess.tournotes
                };
                var commitFields = ['buyin', 'blindmin', 'stack', 'venue', 'tournotes'];
                
                Object.keys(fieldMap).forEach(function(id) {
                    var val = fieldMap[id];
                    if (val) {
                        var el = document.getElementById(id);
                        if (el) {
                            el.value = val;
                            el.dataset.rawValue = val;
                        }
                    }
                });
                
                // Commit each field to trigger display formatting
                if (typeof commitSessionField === 'function') {
                    commitFields.forEach(function(f) {
                        try { commitSessionField(f); } catch(e) {}
                    });
                }
                
                if (sess.format !== undefined) {
                    var selector = document.getElementById('session-format-selector');
                    if (selector) {
                        selector.querySelectorAll('.desc-chip').forEach(function(c) {
                            c.classList.toggle('active', parseInt(c.dataset.value) === sess.format);
                        });
                    }
                }
                // Blind structure & level
                if (sess.blindStructure) {
                    for (var i = 0; i < sess.blindStructure.length && i < blindStructure.length; i++) {
                        blindStructure[i] = sess.blindStructure[i];
                    }
                }
                if (sess.blindLevel !== undefined) {
                    currentBlindLevel = sess.blindLevel;
                    updateBlindDisplay();
                }
                // Session timer state
                if (sess.sessionActive && sess.sessionStartTime) {
                    sessionActive = true;
                    sessionStartTime = sess.sessionStartTime;
                    sessionTimerInterval = setInterval(updateSessionClock, 1000);
                    updateSessionClock();
                    document.getElementById('session-start-btn').style.display = 'none';
                    document.getElementById('session-stop-btn').style.display = 'flex';
                    document.getElementById('session-clock').classList.add('active');
                    document.getElementById('session-status-label').textContent = 'Session in progress';
                }
                // Auto-collapse tournament info if user had already started playing hands
                if (hhStoredHands.length > 0 && !tourneyInfoCollapsed) {
                    toggleTourneyInfo();
                }
            } catch(e) { console.warn('Failed to restore session:', e); }
            _isRestoring = false;
        }
        
        function saveHandHistory() {
            if (_isRestoring) return;
            try {
                localStorage.setItem('nitwiz_handHistory', JSON.stringify({
                    hands: hhStoredHands,
                    nextHandNumber: hhCurrentHandNumber
                }));
                var snap = getSessionSnapshot();
                localStorage.setItem('nitwiz_sessionData', JSON.stringify(snap));
                saveToFirebase();
            } catch(e) { console.warn('Failed to save hand history:', e); }
        }
        
        // Auto-save session data when app goes to background (critical for mobile PWA)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && !_isRestoring) {
                saveHandHistory();
            }
        });
        
        // Also save on beforeunload (desktop browser close)
        window.addEventListener('beforeunload', function() {
            if (!_isRestoring) saveHandHistory();
        });
        
        // Periodic auto-save every 30 seconds
        setInterval(function() {
            if (!_isRestoring) saveHandHistory();
        }, 30000);
        
        const hhPositionHierarchy = ['SB', 'BB', 'UTG', 'MP', 'HJ', 'CO', 'BTN'];
        const hhPreflopSequence = ['UTG', 'MP', 'HJ', 'CO', 'BTN', 'SB', 'BB'];
        const hhPostflopSequence = ['SB', 'BB', 'UTG', 'MP', 'HJ', 'CO', 'BTN'];

        // ===== HAND TRACKER FUNCTIONS =====
        function hhOnHeroSelect() {
            const select = document.getElementById('hh-hero-select');
            
            // Handle "Add New Player" selection
            if (select.value === '__add_new__') {
                hhAddNewPlayerFromSelect('hh-hero-select', function() {
                    hhOnHeroSelect(); // Re-run with the newly selected player
                });
                return;
            }
            
            hhTrackerHero = select.value;
            
            // Extract first name
            if (hhTrackerHero) {
                hhTrackerHeroFirstName = hhTrackerHero.split(' ')[0];
                // Remember last-used hero
                try { localStorage.setItem('nitwiz_lastHero', hhTrackerHero); } catch(e) {}
            } else {
                hhTrackerHeroFirstName = null;
            }
            
            if (hhTrackerHero) {
                // Populate villain dropdown with all players except selected hero
                const villainSelect = document.getElementById('hh-villain-select');
                villainSelect.innerHTML = '<option value="">-- Generic --</option>';
                
                // Add "Add New Player" option to villain dropdown
                const addNewVillain = document.createElement('option');
                addNewVillain.value = '__add_new__';
                addNewVillain.textContent = '+ New';
                addNewVillain.style.fontWeight = '600';
                villainSelect.appendChild(addNewVillain);

                if (database && database.realPlayers) {
                    database.realPlayers.forEach(player => {
                        if (player.name !== hhTrackerHero) {
                            const option = document.createElement('option');
                            option.value = player.name;
                            option.textContent = player.name;
                            villainSelect.appendChild(option);
                        }
                    });
                }
                
                // Try auto-finalize if everything is set
                hhTryFinalize();
            }
        }
        
        function hhOnVillainSelect() {
            const select = document.getElementById('hh-villain-select');
            
            // Handle "Add New Player" selection
            if (select.value === '__add_new__') {
                hhAddNewPlayerFromSelect('hh-villain-select', function() {
                    hhOnVillainSelect(); // Re-run with the newly selected player
                });
                return;
            }
            
            const selectedVillain = select.value;
            
            // Extract first name for villain if a player was selected
            if (selectedVillain) {
                hhTrackerVillainName = selectedVillain;
                hhTrackerVillainFirstName = selectedVillain.split(' ')[0];
            } else {
                hhTrackerVillainName = null;
                hhTrackerVillainFirstName = null;
            }
            
            hhTryFinalize();
        }
        
        function hhSelectHeroPos(pos) {
            // Clear previous hero position selection
            document.getElementById('hh-hero-pos-chips').querySelectorAll('.hh-pos-chip').forEach(function(c) {
                c.classList.remove('active');
                c.style.background = '';
            });
            
            hhTrackerHeroPosition = pos;
            const chip = event.target;
            chip.classList.add('active');
            chip.style.background = 'linear-gradient(135deg, #8dc4f0 0%, #6ea8dc 100%)';
            
            // If villain has same position, clear it
            if (hhTrackerVillainPosition === pos) {
                hhTrackerVillainPosition = null;
                document.getElementById('hh-villain-pos-chips').querySelectorAll('.hh-pos-chip').forEach(function(c) {
                    c.classList.remove('active');
                    c.style.background = '';
                });
            }
            
            // Mark hero's position on villain chips
            hhUpdateVillainChipStates();
            
            hhTryFinalize();
        }
        
        function hhUpdateVillainChipStates() {
            document.getElementById('hh-villain-pos-chips').querySelectorAll('.hh-pos-chip').forEach(function(c) {
                var chipPos = c.getAttribute('data-position');
                if (chipPos === hhTrackerHeroPosition) {
                    c.classList.add('taken-by-hero');
                } else {
                    c.classList.remove('taken-by-hero');
                }
            });
        }
        
        function hhSelectVillainPos(pos) {
            // Don't allow same position as hero
            if (pos === hhTrackerHeroPosition) return;
            
            // Clear previous villain position selection
            document.getElementById('hh-villain-pos-chips').querySelectorAll('.hh-pos-chip').forEach(function(c) {
                c.classList.remove('active');
                c.style.background = '';
            });
            
            hhTrackerVillainPosition = pos;
            const chip = event.target;
            chip.classList.add('active');
            chip.style.background = 'linear-gradient(135deg, #ffa726 0%, #fb8c00 100%)';
            
            hhTryFinalize();
        }
        
        function hhTryFinalize() {
            // Only finalize when hero, hero position, and villain position are all set
            if (!hhTrackerHero || !hhTrackerHeroPosition || !hhTrackerVillainPosition) return;
            
            // Calculate IP/OOP
            if (hhTrackerHeroPosition === 'BTN') {
                hhTrackerPositionType = 'IP';
            } else if (hhTrackerHeroPosition === 'SB') {
                hhTrackerPositionType = 'OOP';
            } else {
                const heroIdx = hhPositionHierarchy.indexOf(hhTrackerHeroPosition);
                const villainIdx = hhPositionHierarchy.indexOf(hhTrackerVillainPosition);
                hhTrackerPositionType = (heroIdx < villainIdx) ? 'OOP' : 'IP';
            }
            
            hhFinalizeSetup();
        }
        
        // Legacy compatibility
        function hhSelectSharedPosition(pos) {
            // No longer used - split into hhSelectHeroPos / hhSelectVillainPos
        }
        
        function hhClearPositionChips() {
            var heroChips = document.getElementById('hh-hero-pos-chips');
            if (heroChips) heroChips.querySelectorAll('.hh-pos-chip').forEach(function(c) { c.classList.remove('active'); c.style.background = ''; });
            var villainChips = document.getElementById('hh-villain-pos-chips');
            if (villainChips) villainChips.querySelectorAll('.hh-pos-chip').forEach(function(c) { c.classList.remove('active', 'taken-by-hero'); c.style.background = ''; });
        }
        
        function hhHighlightPositionChips() {
            hhClearPositionChips();
            if (hhTrackerHeroPosition) {
                var heroChips = document.getElementById('hh-hero-pos-chips');
                if (heroChips) heroChips.querySelectorAll('.hh-pos-chip').forEach(function(c) {
                    if (c.dataset.position === hhTrackerHeroPosition) { c.classList.add('active'); c.style.background = 'linear-gradient(135deg, #8dc4f0 0%, #6ea8dc 100%)'; }
                });
                hhUpdateVillainChipStates();
            }
            if (hhTrackerVillainPosition) {
                var villainChips = document.getElementById('hh-villain-pos-chips');
                if (villainChips) villainChips.querySelectorAll('.hh-pos-chip').forEach(function(c) {
                    if (c.dataset.position === hhTrackerVillainPosition) { c.classList.add('active'); c.style.background = 'linear-gradient(135deg, #ffa726 0%, #fb8c00 100%)'; }
                });
            }
        }
        
        function hhFinalizeSetup() {
            // Set readonly data for compatibility
            document.getElementById('hh-readonly-hero').textContent = hhTrackerHero;
            document.getElementById('hh-readonly-position').textContent = hhTrackerHeroPosition;
            
            const villainName = hhTrackerVillainName || 'Villain';
            const villainReadonly = document.getElementById('hh-readonly-villain');
            villainReadonly.innerHTML = `${villainName} (${hhTrackerVillainPosition})`;
            
            hhStartHand();
            
            // Save initial hand state
            hhSaveCurrentHandState();
        }
        
        function hhStartHand() {
            hhTrackerCurrentStreet = 'preflop';
            hhTrackerStreetActions = { preflop: [], flop: [], turn: [], river: [] };
            
            const heroIdx = hhPreflopSequence.indexOf(hhTrackerHeroPosition);
            const villainIdx = hhPreflopSequence.indexOf(hhTrackerVillainPosition);
            hhTrackerNextActor = (heroIdx < villainIdx) ? 'hero' : 'villain';
            
            // Auto-collapse tournament info when hand actions begin
            if (!tourneyInfoCollapsed) toggleTourneyInfo();
            
            hhShowStreet('preflop');
            document.getElementById('hh-street-card').style.display = 'block';
        }
        
        /* ===== CARD ROLLER ENGINE ===== */
        var CC_RANKS = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];
        var CC_SUITS = ['\u2660','\u2665','\u2666','\u2663']; // ♠♥♦♣
        var CC_SUIT_CODES = ['s','h','d','c'];

        function ccWrap(i, len) { return ((i % len) + len) % len; }

        // ===== TAP-GRID CARD PICKER =====
        var ccPickerTarget = null; // {type:'community', street:'flop', idx:0} or {type:'hole', panel:'hh-hero-roller-panel', input:'hh-hero-cards', idx:0}
        var ccPickerRank = null;
        var ccAllDealtCards = []; // track dealt cards like ['As','Kh'] to grey out
        
        function ccGetAllDealtCards() {
            var dealt = [];
            var target = ccPickerTarget;
            // Community cards
            ['flop','turn','river'].forEach(function(st) {
                var parsed = ccParseCards(hhTrackerCommunityCards[st] || '');
                parsed.forEach(function(c, idx) {
                    // Skip the slot we're currently picking for
                    if (target && target.type === 'community' && target.street === st && target.idx === idx) return;
                    var sc = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'}[c.suit] || 's';
                    dealt.push(c.rank + sc);
                });
            });
            // Hero cards
            var heroCards = ccParseCards(document.getElementById('hh-hero-cards').value || '');
            heroCards.forEach(function(c, idx) {
                if (target && target.type === 'hole' && target.input === 'hh-hero-cards' && target.idx === idx) return;
                var sc = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'}[c.suit] || 's';
                dealt.push(c.rank + sc);
            });
            // Villain cards
            var villainCards = ccParseCards(document.getElementById('hh-villain-cards').value || '');
            villainCards.forEach(function(c, idx) {
                if (target && target.type === 'hole' && target.input === 'hh-villain-cards' && target.idx === idx) return;
                var sc = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'}[c.suit] || 's';
                dealt.push(c.rank + sc);
            });
            return dealt;
        }
        
        function ccBuildAllRollers() {
            // Now builds tap-grid slots instead of rollers
            var panel = document.getElementById('cc-roller-panel');
            panel.innerHTML = '';
            panel.style.display = 'flex';
            panel.style.background = 'none';
            panel.style.border = 'none';
            panel.style.boxShadow = 'none';
            panel.style.padding = '0';
            panel.style.flexDirection = 'column';
            panel.style.alignItems = 'center';
            
            // Slots row
            var slotsRow = document.createElement('div');
            slotsRow.className = 'cc-card-slots';
            
            var streets = [
                {street:'flop', idx:0, label:'F'}, {street:'flop', idx:1}, {street:'flop', idx:2},
                {street:'turn', idx:0, label:'T'},
                {street:'river', idx:0, label:'R'}
            ];
            
            streets.forEach(function(info, c) {
                // Add separators
                if (c === 3 || c === 4) {
                    var sep = document.createElement('div');
                    sep.className = 'cc-slot-sep';
                    slotsRow.appendChild(sep);
                }
                
                var slot = document.createElement('div');
                slot.className = 'cc-card-slot';
                slot.dataset.street = info.street;
                slot.dataset.cardIdx = String(info.idx);
                
                var existing = ccParseCards(hhTrackerCommunityCards[info.street] || '');
                if (existing[info.idx]) {
                    var card = existing[info.idx];
                    var suitCode = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'}[card.suit] || 's';
                    slot.classList.add('filled', 'suit-' + suitCode);
                    slot.innerHTML = '<span style="font-weight:800;font-size:0.9rem;">' + card.rank + '</span><span style="font-size:1rem;">' + card.suit + '</span>';
                } else {
                    slot.textContent = '?';
                }
                
                slot.onclick = function() { ccOpenPicker({type:'community', street: info.street, idx: info.idx}, slot); };
                slotsRow.appendChild(slot);
            });
            
            panel.appendChild(slotsRow);
            
            // Picker area (hidden by default)
            var pickerArea = document.createElement('div');
            pickerArea.id = 'cc-picker-area';
            panel.appendChild(pickerArea);
        }

        function ccOpenPicker(target, slotEl) {
            ccPickerTarget = target;
            ccPickerRank = null;
            
            // Highlight active slot
            document.querySelectorAll('.cc-card-slot').forEach(function(s) { s.classList.remove('active'); });
            if (slotEl) slotEl.classList.add('active');
            
            // If slot already has a card, clear it first
            if (slotEl && slotEl.classList.contains('filled')) {
                ccClearSlot(target);
                slotEl.classList.remove('filled', 'suit-s', 'suit-h', 'suit-d', 'suit-c');
                slotEl.innerHTML = '?';
                slotEl.style.color = '';
            }
            
            ccShowRankPicker();
        }
        
        function ccClearSlot(target) {
            if (target.type === 'community') {
                var cards = ccParseCards(hhTrackerCommunityCards[target.street] || '');
                // Replace the specific card with null
                if (target.idx < cards.length) {
                    cards[target.idx] = null;
                }
                // Rebuild string - for community cards, gaps matter
                // Use placeholder approach: only include non-null cards sequentially
                var str = '';
                var suitMap = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'};
                cards.forEach(function(c) {
                    if (c) str += c.rank + (suitMap[c.suit] || 's');
                });
                hhTrackerCommunityCards[target.street] = str;
            } else if (target.type === 'hole') {
                var el = document.getElementById(target.input);
                if (!el) return;
                var cards = ccParseCards(el.value || '');
                if (target.idx < cards.length) {
                    cards[target.idx] = null;
                }
                var str = '';
                var suitMap = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'};
                cards.forEach(function(c) {
                    if (c) str += c.rank + (suitMap[c.suit] || 's');
                });
                el.value = str;
            }
        }
        
        function ccGetPickerArea() {
            if (!ccPickerTarget) return null;
            if (ccPickerTarget.type === 'community') {
                return document.getElementById('cc-picker-area');
            } else if (ccPickerTarget.type === 'hole') {
                return document.getElementById('cc-hole-picker-' + ccPickerTarget.panel);
            }
            return null;
        }
        
        function ccShowRankPicker() {
            var area = ccGetPickerArea();
            if (!area) return;
            area.innerHTML = '';
            
            var panel = document.createElement('div');
            panel.className = 'cc-picker-panel';
            
            var label = document.createElement('div');
            label.className = 'cc-picker-label';
            label.textContent = 'Pick rank';
            panel.appendChild(label);
            
            var row = document.createElement('div');
            row.className = 'cc-rank-row';
            
            CC_RANKS.forEach(function(rank) {
                var btn = document.createElement('button');
                btn.className = 'cc-rank-btn';
                btn.textContent = rank;
                btn.onclick = function() {
                    ccPickerRank = rank;
                    ccShowSuitPicker();
                };
                row.appendChild(btn);
            });
            
            panel.appendChild(row);
            area.appendChild(panel);
        }
        
        function ccShowSuitPicker() {
            var area = ccGetPickerArea();
            if (!area) return;
            area.innerHTML = '';
            
            var dealt = ccGetAllDealtCards();
            
            var panel = document.createElement('div');
            panel.className = 'cc-picker-panel';
            
            var label = document.createElement('div');
            label.className = 'cc-picker-label';
            label.textContent = ccPickerRank + ' — pick suit';
            panel.appendChild(label);
            
            var row = document.createElement('div');
            row.className = 'cc-suit-row';
            
            var suits = [
                {sym:'\u2660', code:'s', cls:'suit-s'},
                {sym:'\u2665', code:'h', cls:'suit-h'},
                {sym:'\u2666', code:'d', cls:'suit-d'},
                {sym:'\u2663', code:'c', cls:'suit-c'}
            ];
            
            suits.forEach(function(s) {
                var btn = document.createElement('button');
                btn.className = 'cc-suit-btn ' + s.cls;
                btn.textContent = s.sym;
                
                // Check if this rank+suit already dealt
                var cardKey = ccPickerRank + s.code;
                if (dealt.indexOf(cardKey) >= 0) {
                    btn.classList.add('used');
                }
                
                btn.onclick = function() {
                    ccCommitCard(ccPickerRank, s.code, s.sym);
                };
                row.appendChild(btn);
            });
            
            panel.appendChild(row);
            area.appendChild(panel);
        }
        
        function ccCommitCard(rank, suitCode, suitSym) {
            var target = ccPickerTarget;
            if (!target) return;
            
            if (target.type === 'community') {
                // Build updated card string
                var cards = ccParseCards(hhTrackerCommunityCards[target.street] || '');
                // Ensure array is large enough
                while (cards.length <= target.idx) cards.push(null);
                cards[target.idx] = {rank: rank, suit: suitSym};
                
                var str = '';
                var suitMap = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'};
                cards.forEach(function(c) {
                    if (c) str += c.rank + (suitMap[c.suit] || 's');
                });
                hhTrackerCommunityCards[target.street] = str;
                
                // Update the slot display
                var slots = document.querySelectorAll('.cc-card-slot');
                slots.forEach(function(slot) {
                    if (slot.dataset.street === target.street && parseInt(slot.dataset.cardIdx) === target.idx) {
                        slot.classList.remove('suit-s','suit-h','suit-d','suit-c');
                        slot.classList.add('filled', 'suit-' + suitCode);
                        slot.innerHTML = '<span style="font-weight:800;font-size:0.9rem;">' + rank + '</span><span style="font-size:1rem;">' + suitSym + '</span>';
                        slot.classList.remove('active');
                    }
                });
                
                // Auto-advance to next empty slot
                ccAutoAdvanceCommunity(target.street, target.idx);
            } else if (target.type === 'hole') {
                var cards = ccParseCards(document.getElementById(target.input).value || '');
                while (cards.length <= target.idx) cards.push(null);
                cards[target.idx] = {rank: rank, suit: suitSym};
                
                var str = '';
                var suitMap = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'};
                cards.forEach(function(c) {
                    if (c) str += c.rank + (suitMap[c.suit] || 's');
                });
                document.getElementById(target.input).value = str;
                
                // Rebuild the hole card display
                ccBuildHoleSlots(target.panel, target.input);
                
                // Auto-advance to next empty hole slot
                ccAutoAdvanceHole(target.panel, target.input, target.idx);
            }
            
            hhSaveCurrentHandState();
        }
        
        function ccAutoAdvanceCommunity(street, idx) {
            // Find next empty slot
            var order = [
                {street:'flop',idx:0},{street:'flop',idx:1},{street:'flop',idx:2},
                {street:'turn',idx:0},{street:'river',idx:0}
            ];
            var startFound = false;
            for (var i = 0; i < order.length; i++) {
                if (order[i].street === street && order[i].idx === idx) { startFound = true; continue; }
                if (!startFound) continue;
                
                var cards = ccParseCards(hhTrackerCommunityCards[order[i].street] || '');
                if (!cards[order[i].idx]) {
                    // Found empty slot — open picker on it
                    var slots = document.querySelectorAll('.cc-card-slot');
                    slots.forEach(function(slot) {
                        if (slot.dataset.street === order[i].street && parseInt(slot.dataset.cardIdx) === order[i].idx) {
                            ccOpenPicker({type:'community', street: order[i].street, idx: order[i].idx}, slot);
                        }
                    });
                    return;
                }
            }
            // All filled — close picker
            var area = document.getElementById('cc-picker-area');
            if (area) area.innerHTML = '';
            document.querySelectorAll('.cc-card-slot').forEach(function(s) { s.classList.remove('active'); });
        }
        
        function ccAutoAdvanceHole(panelId, inputId, idx) {
            var cards = ccParseCards(document.getElementById(inputId).value || '');
            var nextIdx = idx + 1;
            if (nextIdx < 2 && !cards[nextIdx]) {
                var panel = document.getElementById(panelId);
                var slots = panel.querySelectorAll('.cc-card-slot');
                if (slots[nextIdx]) {
                    ccOpenHolePicker(panelId, inputId, nextIdx, slots[nextIdx]);
                }
                return;
            }
            // Done — close picker
            var area = document.getElementById('cc-hole-picker-' + panelId);
            if (area) area.innerHTML = '';
            var panel = document.getElementById(panelId);
            if (panel) panel.querySelectorAll('.cc-card-slot').forEach(function(s) { s.classList.remove('active'); });
        }

        function ccSyncAllValues() {
            // No longer needed for rollers — community cards already stored in hhTrackerCommunityCards
        }

        function ccShowBoard() {
            var board = document.getElementById('hh-community-board');
            board.style.display = 'block';
            ccBuildLabels();
            ccBuildAllRollers();
        }

        function ccBuildLabels() {
            // We'll build labels after rollers render, measuring actual widths
            // For now, use requestAnimationFrame to let rollers lay out first
            requestAnimationFrame(function() {
                var labels = document.getElementById('cc-board-labels');
                labels.innerHTML = '';
                var panel = document.getElementById('cc-roller-panel');
                var children = panel.children; // pairs and seps in order

                // Map each panel child to a label element
                var pairIdx = 0;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    var w = child.offsetWidth;
                    var ml = parseFloat(getComputedStyle(child).marginLeft) || 0;
                    var mr = parseFloat(getComputedStyle(child).marginRight) || 0;
                    var totalW = w + ml + mr;

                    if (child.classList.contains('cc-roller-sep')) {
                        // Separator spacer
                        var spacer = document.createElement('div');
                        spacer.style.width = totalW + 'px';
                        spacer.style.flexShrink = '0';
                        labels.appendChild(spacer);
                    } else if (child.classList.contains('cc-roller-pair')) {
                        pairIdx++;
                        var cell = document.createElement('div');
                        cell.className = 'cc-board-label-cell';
                        cell.style.width = totalW + 'px';
                        cell.style.flexShrink = '0';

                        if (pairIdx <= 3) {
                            // Flop cells (pairs 1, 2, 3)
                            if (pairIdx === 2) {
                                // Center flop pair — just the text
                                var txt = document.createElement('span');
                                txt.className = 'cc-board-label-text';
                                txt.textContent = 'Flop';
                                cell.appendChild(txt);
                            }
                            // Pairs 1 and 3 are empty spacers
                        } else if (pairIdx === 4) {
                            var t = document.createElement('span');
                            t.className = 'cc-board-label-text';
                            t.textContent = 'Turn';
                            cell.appendChild(t);
                        } else if (pairIdx === 5) {
                            var r = document.createElement('span');
                            r.className = 'cc-board-label-text';
                            r.textContent = 'River';
                            cell.appendChild(r);
                        }

                        labels.appendChild(cell);
                    }
                }
            });
        }

        function ccHideBoard() {
            document.getElementById('hh-community-board').style.display = 'none';
        }

        /* ===== SHOWDOWN CARD ROLLERS (hero/villain hole cards) ===== */
        function hhBuildHoleCardRollers() {
            ccBuildHoleSlots('hh-hero-roller-panel', 'hh-hero-cards');
            ccBuildHoleSlots('hh-villain-roller-panel', 'hh-villain-cards');
            // Set labels to player first names
            var heroLabel = document.getElementById('hh-hero-cards-label');
            var villainLabel = document.getElementById('hh-villain-cards-label');
            if (heroLabel) heroLabel.textContent = hhTrackerHeroFirstName || 'Hero';
            if (villainLabel) villainLabel.textContent = hhTrackerVillainFirstName || 'Villain';
        }
        
        function ccBuildHoleSlots(panelId, inputId) {
            var panel = document.getElementById(panelId);
            panel.innerHTML = '';
            panel.style.display = 'flex';
            panel.style.flexDirection = 'column';
            panel.style.alignItems = 'center';
            panel.style.background = 'none';
            panel.style.border = 'none';
            panel.style.boxShadow = 'none';
            panel.style.padding = '0';
            
            var slotsRow = document.createElement('div');
            slotsRow.className = 'cc-card-slots';
            
            var existing = ccParseCards(document.getElementById(inputId).value || '');
            
            for (var c = 0; c < 2; c++) {
                if (c > 0) {
                    var sep = document.createElement('div');
                    sep.className = 'cc-slot-sep';
                    sep.style.height = '24px';
                    slotsRow.appendChild(sep);
                }
                
                var slot = document.createElement('div');
                slot.className = 'cc-card-slot';
                slot.dataset.cardIdx = String(c);
                
                if (existing[c]) {
                    var card = existing[c];
                    var suitCode = {'\u2660':'s','\u2665':'h','\u2666':'d','\u2663':'c'}[card.suit] || 's';
                    slot.classList.add('filled', 'suit-' + suitCode);
                    slot.innerHTML = '<span style="font-weight:800;font-size:0.9rem;">' + card.rank + '</span><span style="font-size:1rem;">' + card.suit + '</span>';
                } else {
                    slot.textContent = '?';
                }
                
                (function(idx) {
                    slot.onclick = function() { ccOpenHolePicker(panelId, inputId, idx, slot); };
                })(c);
                
                slotsRow.appendChild(slot);
            }
            
            panel.appendChild(slotsRow);
            
            var pickerArea = document.createElement('div');
            pickerArea.id = 'cc-hole-picker-' + panelId;
            panel.appendChild(pickerArea);
        }
        
        function ccOpenHolePicker(panelId, inputId, idx, slotEl) {
            ccPickerTarget = {type:'hole', panel: panelId, input: inputId, idx: idx};
            ccPickerRank = null;
            
            // Highlight active slot in this panel
            var panel = document.getElementById(panelId);
            panel.querySelectorAll('.cc-card-slot').forEach(function(s) { s.classList.remove('active'); });
            if (slotEl) slotEl.classList.add('active');
            
            // If slot already has a card, clear it
            if (slotEl && slotEl.classList.contains('filled')) {
                ccClearSlot(ccPickerTarget);
                slotEl.classList.remove('filled', 'suit-s', 'suit-h', 'suit-d', 'suit-c');
                slotEl.innerHTML = '?';
                slotEl.style.color = '';
            }
            
            ccShowRankPicker();
        }

        function hhBuildHoleCol(items, startIdx, isSuit, panelId, hiddenInputId) {
            var col = document.createElement('div');
            col.className = 'cc-roller-col';
            col.dataset.index = String(startIdx);

            var up = document.createElement('div');
            up.className = 'cc-roller-arrow up';
            up.addEventListener('click', function() {
                var i = ccWrap(parseInt(col.dataset.index) - 1, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                hhSyncHoleCards(panelId, hiddenInputId);
            });
            col.appendChild(up);

            var val = document.createElement('div');
            val.className = 'cc-roller-val';
            val.textContent = items[startIdx];
            if (isSuit) val.style.fontSize = '1.3rem';
            col.appendChild(val);

            var dn = document.createElement('div');
            dn.className = 'cc-roller-arrow down';
            dn.addEventListener('click', function() {
                var i = ccWrap(parseInt(col.dataset.index) + 1, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                hhSyncHoleCards(panelId, hiddenInputId);
            });
            col.appendChild(dn);

            // Swipe
            var touchY = 0;
            col.addEventListener('touchstart', function(e) { touchY = e.touches[0].clientY; }, {passive: true});
            col.addEventListener('touchmove', function(e) {
                var dy = touchY - e.touches[0].clientY;
                if (Math.abs(dy) > 25) {
                    e.preventDefault();
                    var dir = dy > 0 ? 1 : -1;
                    var i = ccWrap(parseInt(col.dataset.index) + dir, items.length);
                    col.dataset.index = String(i);
                    val.textContent = items[i];
                    touchY = e.touches[0].clientY;
                    hhSyncHoleCards(panelId, hiddenInputId);
                }
            }, {passive: false});

            // Scroll
            col.addEventListener('wheel', function(e) {
                e.preventDefault();
                var dir = e.deltaY > 0 ? 1 : -1;
                var i = ccWrap(parseInt(col.dataset.index) + dir, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                hhSyncHoleCards(panelId, hiddenInputId);
            }, {passive: false});

            return col;
        }

        function hhSyncHoleCards(panelId, hiddenInputId) {
            var panel = document.getElementById(panelId);
            var pairs = panel.querySelectorAll('.cc-roller-pair');
            var result = '';
            for (var p = 0; p < pairs.length; p++) {
                var cols = pairs[p].querySelectorAll('.cc-roller-col');
                var rIdx = parseInt(cols[0].dataset.index);
                var sIdx = parseInt(cols[1].dataset.index);
                result += CC_RANKS[rIdx] + CC_SUIT_CODES[sIdx];
            }
            document.getElementById(hiddenInputId).value = result;
        }

        function ccBuildCol(items, startIdx, isSuit, street, cardIdx, type) {
            var col = document.createElement('div');
            col.className = 'cc-roller-col';
            col.dataset.index = String(startIdx);
            col.dataset.type = type;
            col.dataset.cardIdx = String(cardIdx);
            col.dataset.street = street;
            col.dataset.count = isSuit ? '4' : '13';

            // Up arrow
            var up = document.createElement('div');
            up.className = 'cc-roller-arrow up';
            up.addEventListener('click', function() {
                var i = ccWrap(parseInt(col.dataset.index) - 1, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                ccSyncAllValues();
            });
            col.appendChild(up);

            // Value
            var val = document.createElement('div');
            val.className = 'cc-roller-val';
            val.textContent = items[startIdx];
            if (isSuit) val.style.fontSize = '1.3rem';
            col.appendChild(val);

            // Down arrow
            var dn = document.createElement('div');
            dn.className = 'cc-roller-arrow down';
            dn.addEventListener('click', function() {
                var i = ccWrap(parseInt(col.dataset.index) + 1, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                ccSyncAllValues();
            });
            col.appendChild(dn);

            // Swipe support
            var touchY = 0;
            col.addEventListener('touchstart', function(e) { touchY = e.touches[0].clientY; }, {passive: true});
            col.addEventListener('touchmove', function(e) {
                var dy = touchY - e.touches[0].clientY;
                if (Math.abs(dy) > 25) {
                    e.preventDefault();
                    var dir = dy > 0 ? 1 : -1;
                    var i = ccWrap(parseInt(col.dataset.index) + dir, items.length);
                    col.dataset.index = String(i);
                    val.textContent = items[i];
                    touchY = e.touches[0].clientY;
                    ccSyncAllValues();
                }
            }, {passive: false});

            // Scroll support
            col.addEventListener('wheel', function(e) {
                e.preventDefault();
                var dir = e.deltaY > 0 ? 1 : -1;
                var i = ccWrap(parseInt(col.dataset.index) + dir, items.length);
                col.dataset.index = String(i);
                val.textContent = items[i];
                ccSyncAllValues();
            }, {passive: false});

            return col;
        }

        function ccParseCards(str) {
            // Parse "AsKh10d" into [{rank:'A',suit:'♠'}, {rank:'K',suit:'♥'}, {rank:'10',suit:'♦'}]
            var cards = [];
            var i = 0;
            while (i < str.length) {
                var rank = '';
                if (str.substr(i, 2) === '10') { rank = '10'; i += 2; }
                else { rank = str[i]; i++; }
                if (i < str.length) {
                    var sc = str[i].toLowerCase(); i++;
                    var suitMap = {s:'\u2660', h:'\u2665', d:'\u2666', c:'\u2663'};
                    cards.push({rank: rank.toUpperCase(), suit: suitMap[sc] || '\u2660'});
                }
            }
            return cards;
        }

        function hhShowStreet(street) {
            hhTrackerCurrentStreet = street;
            
            const streetNames = { preflop: 'PreFlop', flop: 'Flop', turn: 'Turn', river: 'River' };
            document.getElementById('hh-street-name').textContent = streetNames[street];
            
            // Show the 5-card community board once we leave preflop
            if (street !== 'preflop') {
                ccShowBoard();
            } else {
                ccHideBoard();
            }
            
            if (street !== 'preflop') {
                hhTrackerNextActor = (hhTrackerPositionType === 'OOP') ? 'hero' : 'villain';
            }
            
            hhRenderActions();
            hhShowActionButtons();
        }
        
        function hhRenderActions() {
            const container = document.getElementById('hh-action-history');
            container.innerHTML = '';
            
            const actions = hhTrackerStreetActions[hhTrackerCurrentStreet];
            actions.forEach(item => {
                const div = document.createElement('div');
                div.className = 'hh-action-item ' + item.actor;
                let text;
                if (item.actor === 'hero') {
                    text = hhTrackerHeroFirstName + ': ';
                } else {
                    const villainName = hhTrackerVillainFirstName || 'Villain';
                    text = villainName + ': ';
                }
                text += item.action;
                if (item.amount) text += ' ' + item.amount;
                div.textContent = text;
                container.appendChild(div);
            });
        }
        
        function hhGetValidActions() {
            const actions = hhTrackerStreetActions[hhTrackerCurrentStreet];
            
            if (actions.length === 0) {
                if (hhTrackerCurrentStreet === 'preflop') {
                    if (hhTrackerHeroPosition === 'BB' && hhTrackerNextActor === 'hero') {
                        return ['Check', 'Raise', 'All-in'];
                    } else {
                        return ['Limp', 'Raise', 'All-in'];
                    }
                } else {
                    return ['Check', 'Bet', 'All-in'];
                }
            }
            
            const lastAction = actions[actions.length - 1].action;
            
            if (hhTrackerCurrentStreet === 'preflop') {
                if (lastAction === 'Limp') {
                    if ((hhTrackerNextActor === 'hero' && hhTrackerHeroPosition === 'BB') || 
                        (hhTrackerNextActor === 'villain' && hhTrackerVillainPosition === 'BB')) {
                        return ['Check', 'Call', 'Raise', 'Re-Raise', 'All-in', 'Fold'];
                    } else {
                        return ['Call', 'Raise', 'Re-Raise', 'All-in', 'Fold'];
                    }
                } else if (lastAction === 'Raise') {
                    return ['Call', 'Re-Raise', 'All-in', 'Fold'];
                } else if (lastAction === 'Re-Raise') {
                    return ['Call', 'Re-Raise', 'All-in', 'Fold'];
                } else if (lastAction === 'All-in') {
                    return ['Call', 'Fold'];
                } else if (lastAction === 'Check') {
                    return ['Check', 'Raise', 'All-in'];
                }
            }
            
            if (lastAction === 'Check') {
                return ['Check', 'Bet', 'All-in'];
            } else if (lastAction === 'Bet') {
                return ['Call', 'Raise', 'Re-Raise', 'All-in', 'Fold'];
            } else if (lastAction === 'Raise') {
                return ['Call', 'Re-Raise', 'All-in', 'Fold'];
            } else if (lastAction === 'Re-Raise') {
                return ['Call', 'Re-Raise', 'All-in', 'Fold'];
            } else if (lastAction === 'All-in') {
                return ['Call', 'Fold'];
            }
            
            return ['Check', 'Call', 'Raise', 'Re-Raise', 'Fold', 'All-in'];
        }
        
        function hhShowActionButtons() {
            const container = document.getElementById('hh-action-buttons');
            container.innerHTML = '';
            
            const actorDisplay = document.getElementById('hh-actor-display');
            actorDisplay.classList.remove('flash');
            void actorDisplay.offsetWidth;
            
            if (hhTrackerNextActor === 'hero') {
                actorDisplay.textContent = ` - ${hhTrackerHeroFirstName}'s Action`;
                actorDisplay.className = 'hh-actor-name hero active';
            } else {
                const villainName = hhTrackerVillainFirstName || 'Villain';
                actorDisplay.textContent = ` - ${villainName}'s Action`;
                actorDisplay.className = 'hh-actor-name villain active';
            }
            
            const actions = hhGetValidActions();
            actions.forEach(action => {
                const btn = document.createElement('button');
                btn.className = 'hh-action-btn';
                btn.textContent = action;
                btn.onclick = () => hhSelectAction(action);
                container.appendChild(btn);
            });
        }
        
        function hhSelectAction(action) {
            hhTrackerPendingAction = action;
            document.getElementById('hh-action-buttons').innerHTML = '';
            
            if (action === 'Bet' || action === 'Raise' || action === 'Re-Raise' || action === 'All-in') {
                document.getElementById('hh-amount-row').classList.add('visible');
                document.getElementById('hh-amount-input').value = '';
                document.getElementById('hh-amount-input').focus();
            } else {
                hhCommitAction(null);
            }
        }
        
        function hhCommitCurrentAction() {
            const amount = document.getElementById('hh-amount-input').value.trim();
            hhCommitAction(amount || null);
        }
        
        function hhCommitAction(amount) {
            document.getElementById('hh-amount-row').classList.remove('visible');
            
            hhTrackerStreetActions[hhTrackerCurrentStreet].push({
                actor: hhTrackerNextActor,
                action: hhTrackerPendingAction,
                amount: amount
            });
            
            hhRenderActions();
            
            // Save current hand state in real-time
            hhSaveCurrentHandState();
            
            if (hhCheckStreetComplete()) {
                return;
            }
            
            hhTrackerNextActor = (hhTrackerNextActor === 'hero') ? 'villain' : 'hero';
            hhShowActionButtons();
        }
        
        function hhCheckStreetComplete() {
            const actions = hhTrackerStreetActions[hhTrackerCurrentStreet];
            if (actions.length < 2) return false;
            
            const lastAction = actions[actions.length - 1];
            const secondLastAction = actions[actions.length - 2];
            
            if (lastAction.action === 'Fold') {
                hhEndHand('fold');
                return true;
            }
            
            if (lastAction.action === 'Check' && secondLastAction.action === 'Check') {
                hhAdvanceStreet();
                return true;
            }
            
            if (lastAction.action === 'Check' && secondLastAction.action === 'Limp') {
                hhAdvanceStreet();
                return true;
            }
            
            if (lastAction.action === 'Call' && secondLastAction.action === 'Limp') {
                hhAdvanceStreet();
                return true;
            }
            
            if ((secondLastAction.action === 'Bet' || secondLastAction.action === 'Raise' || secondLastAction.action === 'Re-Raise') 
                && lastAction.action === 'Call') {
                hhAdvanceStreet();
                return true;
            }
            
            if (secondLastAction.action === 'All-in' && lastAction.action === 'Call') {
                hhHandleAllInCall();
                return true;
            }
            
            if (secondLastAction.action === 'All-in' && lastAction.action === 'Fold') {
                hhEndHand('fold');
                return true;
            }
            
            return false;
        }
        
        function hhAdvanceStreet() {
            const streets = ['preflop', 'flop', 'turn', 'river'];
            const currentIndex = streets.indexOf(hhTrackerCurrentStreet);
            
            if (currentIndex < streets.length - 1) {
                hhShowStreet(streets[currentIndex + 1]);
            } else {
                hhShowShowdown();
            }
        }
        
        function hhHandleAllInCall() {
            hhShowShowdown();
        }
        
        function hhEndHand(reason) {
            document.getElementById('hh-street-card').style.display = 'none';
            hhShowResults(reason);
        }
        
        function hhShowShowdown() {
            document.getElementById('hh-street-card').style.display = 'none';
            hhShowResults('showdown');
        }
        
        function hhShowResults(reason) {
            const resultsCard = document.getElementById('hh-results-card');
            const resultsTitle = document.getElementById('hh-results-title');
            const summaryDiv = document.getElementById('hh-hand-summary');
            
            resultsTitle.textContent = reason === 'fold' ? 'Hand Complete - Fold' : 'Showdown';
            
            let summary = '<div class="hh-hand-summary">';
            const streets = ['preflop', 'flop', 'turn', 'river'];
            let accumulatedCards = '';
            
            streets.forEach(street => {
                const actions = hhTrackerStreetActions[street];
                if (actions.length > 0) {
                    const streetNames = { preflop: 'PreFlop', flop: 'Flop', turn: 'Turn', river: 'River' };
                    
                    summary += '<div class="hh-summary-street">';
                    summary += '<div class="hh-summary-street-name">';
                    summary += '<span style="text-transform: uppercase;">' + streetNames[street] + '</span>';
                    
                    if (street !== 'preflop' && hhTrackerCommunityCards[street]) {
                        if (accumulatedCards) accumulatedCards += ' ';
                        accumulatedCards += hhTrackerCommunityCards[street];
                        summary += ' <span>[' + accumulatedCards + ']</span>';
                    } else if (street !== 'preflop' && accumulatedCards) {
                        summary += ' <span>[' + accumulatedCards + ']</span>';
                    }
                    
                    summary += '</div>';
                    
                    actions.forEach(item => {
                        summary += '<div class="hh-summary-action ' + item.actor + '">';
                        if (item.actor === 'hero') {
                            summary += hhTrackerHeroFirstName + ': ';
                        } else {
                            const villainName = hhTrackerVillainFirstName || 'Villain';
                            summary += villainName + ': ';
                        }
                        summary += item.action;
                        if (item.amount) summary += ' ' + item.amount;
                        summary += '</div>';
                    });
                    
                    summary += '</div>';
                }
            });
            
            summary += '</div>';
            summaryDiv.innerHTML = summary;
            resultsCard.style.display = 'block';
            hhBuildHoleCardRollers();
            
            // Update winner button text to show player names
            const heroBtn = document.getElementById('hh-winner-btn-hero');
            const villainBtn = document.getElementById('hh-winner-btn-villain');
            if (heroBtn && hhTrackerHeroFirstName) {
                heroBtn.textContent = hhTrackerHeroFirstName;
            }
            if (villainBtn) {
                const villainName = hhTrackerVillainFirstName || 'Villain';
                villainBtn.textContent = villainName;
            }
            
            // Show notes and navigation sections
            document.getElementById('hh-notes-section').style.display = 'block';
            document.getElementById('hh-navigation-section').style.display = 'block';
        }
        
        function hhSetWinner(who) {
            hhTrackerWinner = who;
            document.querySelectorAll('#hh-results-card .hh-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function hhSkipStreet() {
            hhAdvanceStreet();
        }
        
        function hhNextHandDifferentPlayers() {
            var now = Date.now();
            if (now - _lastNextHandTime < 500) return;
            _lastNextHandTime = now;
            
            // Finalize and save current hand to completed storage
            hhFinalizeCurrentHand();
            
            // Increment hand number (keep counter going)
            hhCurrentHandNumber++;
            saveHandHistory();
            hhViewingHandNumber = null; // Back to live mode
            hhUpdateHandNumberDisplay();
            
            // Clear player data - user will select new players
            hhTrackerHero = null;
            hhTrackerHeroFirstName = null;
            hhTrackerHeroPosition = null;
            hhTrackerVillainName = null;
            hhTrackerVillainFirstName = null;
            hhTrackerVillainPosition = null;
            hhTrackerPositionType = null;
            hhClearPositionChips();
            hhTrackerCurrentStreet = 'preflop';
            hhTrackerStreetActions = { preflop: [], flop: [], turn: [], river: [] };
            hhTrackerCommunityCards = { flop: '', turn: '', river: '' }; ccHideBoard();
            hhTrackerPendingAction = null;
            hhTrackerNextActor = null;
            hhTrackerWinner = null;
            
            // Clear dropdowns
            document.getElementById('hh-hero-select').value = '';
            document.getElementById('hh-villain-select').value = '';
            
            // Go back to player selection screen
            document.getElementById('hh-street-card').style.display = 'none';
            document.getElementById('hh-results-card').style.display = 'none';
            document.getElementById('hh-notes-section').style.display = 'none';
            
            // Keep navigation visible so user can view history
            document.getElementById('hh-navigation-section').style.display = 'block';
            
            // Reset all chips and inputs
            document.querySelectorAll('.hh-pos-chip').forEach(chip => {
                chip.classList.remove('active', 'disabled');
                chip.style.background = '';
                chip.style.opacity = '1';
                chip.style.cursor = 'pointer';
            });
            document.querySelectorAll('.hh-toggle-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('hh-hero-cards').value = '';
            document.getElementById('hh-villain-cards').value = '';
            document.getElementById('hh-hand-notes').value = '';
        }
        
        var _lastNextHandTime = 0;
        function hhNextHand() {
            var now = Date.now();
            if (now - _lastNextHandTime < 500) return;
            _lastNextHandTime = now;
            
            // Finalize and save current hand to completed storage
            hhFinalizeCurrentHand();
            
            // Increment hand number
            hhCurrentHandNumber++;
            saveHandHistory();
            hhViewingHandNumber = null; // Back to live mode
            hhUpdateHandNumberDisplay();
            
            // Save current player names
            const savedHero = hhTrackerHero;
            const savedHeroFirstName = hhTrackerHeroFirstName;
            const savedVillainName = hhTrackerVillainName;
            const savedVillainFirstName = hhTrackerVillainFirstName;
            
            // Reset positions and hand data
            hhTrackerHeroPosition = null;
            hhTrackerVillainPosition = null;
            hhTrackerPositionType = null;
            hhClearPositionChips();
            hhTrackerCurrentStreet = 'preflop';
            hhTrackerStreetActions = { preflop: [], flop: [], turn: [], river: [] };
            hhTrackerCommunityCards = { flop: '', turn: '', river: '' }; ccHideBoard();
            hhTrackerPendingAction = null;
            hhTrackerNextActor = null;
            hhTrackerWinner = null;
            
            // Restore player names
            hhTrackerHero = savedHero;
            hhTrackerHeroFirstName = savedHeroFirstName;
            hhTrackerVillainName = savedVillainName;
            hhTrackerVillainFirstName = savedVillainFirstName;
            
            // Keep dropdowns populated with current selections
            document.getElementById('hh-hero-select').value = savedHero || '';
            document.getElementById('hh-villain-select').value = savedVillainName || '';
            
            // Show position selection
            document.getElementById('hh-street-card').style.display = 'none';
            document.getElementById('hh-results-card').style.display = 'none';
            document.getElementById('hh-notes-section').style.display = 'none';
            
            // Show navigation section so user can view history while setting up new hand
            document.getElementById('hh-navigation-section').style.display = 'block';
            
            // Reset position instruction with player names
            const instruction = document.getElementById('hh-position-instruction');
            if (instruction && savedHeroFirstName) {
                instruction.innerHTML = `Select position for <span style="color: #8dc4f0;">${savedHeroFirstName}</span>`;
            }
            
            // Reset all position chips
            document.querySelectorAll('.hh-pos-chip').forEach(chip => {
                chip.classList.remove('active', 'disabled');
                chip.style.background = '';
                chip.style.opacity = '1';
                chip.style.cursor = 'pointer';
            });
            document.querySelectorAll('.hh-toggle-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('hh-hero-cards').value = '';
            document.getElementById('hh-villain-cards').value = '';
            document.getElementById('hh-hand-notes').value = '';
            
            // Repopulate villain dropdown with all players except hero
            if (savedHero && database && database.realPlayers) {
                const villainSelect = document.getElementById('hh-villain-select');
                villainSelect.innerHTML = '<option value="">-- Generic Villain --</option>';
                
                database.realPlayers.forEach(player => {
                    if (player.name !== savedHero) {
                        const option = document.createElement('option');
                        option.value = player.name;
                        option.textContent = player.name;
                        villainSelect.appendChild(option);
                    }
                });
                
                // Restore villain selection if it existed
                if (savedVillainName) {
                    villainSelect.value = savedVillainName;
                }
            }
        }
        
        function hhResetHand() {
            hhTrackerHero = null;
            hhTrackerHeroFirstName = null;
            hhTrackerHeroPosition = null;
            hhTrackerVillainName = null;
            hhTrackerVillainFirstName = null;
            hhTrackerVillainPosition = null;
            hhTrackerPositionType = null;
            hhClearPositionChips();
            hhTrackerCurrentStreet = 'preflop';
            hhTrackerStreetActions = { preflop: [], flop: [], turn: [], river: [] };
            hhTrackerCommunityCards = { flop: '', turn: '', river: '' }; ccHideBoard();
            hhTrackerPendingAction = null;
            hhTrackerNextActor = null;
            hhTrackerWinner = null;
            
            document.getElementById('hh-hero-select').value = '';
            document.getElementById('hh-villain-select').value = '';
            document.getElementById('hh-street-card').style.display = 'none';
            document.getElementById('hh-results-card').style.display = 'none';
            document.getElementById('hh-notes-section').style.display = 'none';
            document.getElementById('hh-navigation-section').style.display = 'none';
            
            // Reset position instruction
            const instruction = document.getElementById('hh-position-instruction');
            if (instruction) {
                instruction.textContent = 'Click to select Player 1\'s position';
            }
            
            // Reset all position chips
            document.querySelectorAll('.hh-pos-chip').forEach(chip => {
                chip.classList.remove('active', 'disabled');
                chip.style.background = '';
                chip.style.opacity = '1';
                chip.style.cursor = 'pointer';
            });
            document.querySelectorAll('.hh-toggle-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('hh-hero-cards').value = '';
            document.getElementById('hh-villain-cards').value = '';
        }
        
        // Hand storage functions
        function hhGetCurrentHandData() {
            // Capture current hand state
            return {
                handNumber: hhCurrentHandNumber,
                hero: hhTrackerHero,
                heroFirstName: hhTrackerHeroFirstName,
                heroPosition: hhTrackerHeroPosition,
                villainName: hhTrackerVillainName,
                villainFirstName: hhTrackerVillainFirstName,
                villainPosition: hhTrackerVillainPosition,
                positionType: hhTrackerPositionType,
                streetActions: JSON.parse(JSON.stringify(hhTrackerStreetActions)),
                communityCards: JSON.parse(JSON.stringify(hhTrackerCommunityCards)),
                winner: hhTrackerWinner,
                heroCards: document.getElementById('hh-hero-cards')?.value || '',
                villainCards: document.getElementById('hh-villain-cards')?.value || '',
                notes: document.getElementById('hh-hand-notes')?.value || '',
                timestamp: new Date().toISOString(),
                inProgress: true
            };
        }
        
        function hhSaveCurrentHandState() {
            // Real-time save - updates the current hand in storage
            const handData = hhGetCurrentHandData();
            
            // Find if current hand already exists in storage
            const existingIndex = hhStoredHands.findIndex(h => h.handNumber === hhCurrentHandNumber);
            if (existingIndex >= 0) {
                // Update existing
                hhStoredHands[existingIndex] = handData;
            } else {
                // Add new
                hhStoredHands.push(handData);
            }
            
            saveHandHistory();
            
            // Refresh player hand history if viewing a player
            if (currentPlayerName) renderPlayerHandHistory(currentPlayerName);
        }
        
        function hhFinalizeCurrentHand() {
            // Mark hand as complete and finalize
            const handData = hhGetCurrentHandData();
            handData.inProgress = false;
            
            const existingIndex = hhStoredHands.findIndex(h => h.handNumber === hhCurrentHandNumber);
            if (existingIndex >= 0) {
                hhStoredHands[existingIndex] = handData;
            } else {
                hhStoredHands.push(handData);
            }
            
            saveHandHistory();
            
            // Refresh player hand history if viewing a player
            if (currentPlayerName) renderPlayerHandHistory(currentPlayerName);
        }
        
        function hhUpdateHandNumberDisplay() {
            const display = document.getElementById('hh-hand-number');
            const editLink = document.getElementById('hh-edit-hand-link');
            if (display) {
                if (hhViewingHandNumber !== null) {
                    display.textContent = `#${hhViewingHandNumber} (viewing)`;
                    display.style.color = 'rgba(255, 167, 38, 0.7)';
                } else {
                    display.textContent = `#${hhCurrentHandNumber}`;
                    display.style.color = '#ff8c38';
                }
            }
            // Show Edit Hand link only when viewing a past stored hand
            if (editLink) {
                var isViewingPast = hhViewingHandNumber !== null && hhStoredHands.find(function(h) { return h.handNumber === hhViewingHandNumber && !h.inProgress; });
                editLink.style.display = isViewingPast ? 'inline' : 'none';
            }
        }
        
        function hhPreviousHand() {
            if (hhViewingHandNumber === null) {
                // Currently viewing live hand, go to most recent stored
                if (hhStoredHands.length === 0) return;
                hhViewingHandNumber = hhStoredHands[hhStoredHands.length - 1].handNumber;
            } else {
                // Find previous hand
                const currentIndex = hhStoredHands.findIndex(h => h.handNumber === hhViewingHandNumber);
                if (currentIndex > 0) {
                    hhViewingHandNumber = hhStoredHands[currentIndex - 1].handNumber;
                }
            }
            hhLoadStoredHand(hhViewingHandNumber);
        }
        
        function hhNextStoredHand() {
            if (hhViewingHandNumber === null) return; // Already at live hand
            
            const currentIndex = hhStoredHands.findIndex(h => h.handNumber === hhViewingHandNumber);
            if (currentIndex < hhStoredHands.length - 1) {
                // Go to next stored hand
                hhViewingHandNumber = hhStoredHands[currentIndex + 1].handNumber;
                hhLoadStoredHand(hhViewingHandNumber);
            } else {
                // Check if next hand is the current hand
                const nextHandNumber = hhStoredHands[currentIndex].handNumber + 1;
                if (nextHandNumber === hhCurrentHandNumber) {
                    // Return to current live hand
                    hhViewingHandNumber = null;
                    hhReturnToLiveHand();
                } else {
                    // Already at the end
                    hhViewingHandNumber = null;
                    hhUpdateHandNumberDisplay();
                }
            }
        }
        
        function hhLoadStoredHand(handNumber) {
            const hand = hhStoredHands.find(h => h.handNumber === handNumber);
            if (!hand) return;
            
            const isCurrentHand = (handNumber === hhCurrentHandNumber);
            
            // Load hand data into display
            hhTrackerHero = hand.hero;
            hhTrackerHeroFirstName = hand.heroFirstName;
            hhTrackerHeroPosition = hand.heroPosition;
            hhTrackerVillainName = hand.villainName;
            hhTrackerVillainFirstName = hand.villainFirstName;
            hhTrackerVillainPosition = hand.villainPosition;
            hhTrackerPositionType = hand.positionType;
            hhTrackerStreetActions = JSON.parse(JSON.stringify(hand.streetActions));
            hhTrackerCommunityCards = JSON.parse(JSON.stringify(hand.communityCards));
            hhTrackerWinner = hand.winner;
            
            // Update setup display - set dropdowns and highlight position chips
            if (hand.hero) document.getElementById('hh-hero-select').value = hand.hero;
            if (hand.villainName) document.getElementById('hh-villain-select').value = hand.villainName;
            hhHighlightPositionChips();
            
            // Update display
            
            // Only show position selection if this is the CURRENT hand AND it's in progress (not completed yet)
            const showPositionSelection = isCurrentHand && hand.inProgress && !hand.winner;
            document.getElementById('hh-street-card').style.display = showPositionSelection ? 'block' : 'none';
            
            // Show readonly summary
            document.getElementById('hh-readonly-hero').textContent = hand.hero;
            document.getElementById('hh-readonly-position').textContent = hand.heroPosition;
            const villainName = hand.villainName || 'Villain';
            document.getElementById('hh-readonly-villain').innerHTML = `${villainName} <span style="color: rgba(255, 255, 255, 0.7);">(${hand.villainPosition})</span>`;
            
            // Show results if hand is complete
            if (!hand.inProgress || hand.winner) {
                hhShowResults(hand.winner ? 'showdown' : 'fold');
            }
            
            document.getElementById('hh-hero-cards').value = hand.heroCards;
            document.getElementById('hh-villain-cards').value = hand.villainCards;
            document.getElementById('hh-hand-notes').value = hand.notes || '';
            // Rebuild hole card rollers with restored values
            if (!hand.inProgress || hand.winner) {
                hhBuildHoleCardRollers();
            }
            
            // Update viewing state
            if (!isCurrentHand) {
                hhViewingHandNumber = handNumber;
            }
            hhUpdateHandNumberDisplay();
        }
        
        function hhShowHandJumpMenu() {
            // Build list of available hands
            var items = [];
            hhStoredHands.forEach(function(h) {
                var heroName = h.heroFirstName || 'Hero';
                var villainName = h.villainFirstName || 'Villain';
                var label = '#' + h.handNumber + '  ' + heroName + ' vs ' + villainName;
                if (h.winner) label += ' (' + h.winner + ' wins)';
                else if (h.inProgress) label += ' (in progress)';
                items.push({ number: h.handNumber, label: label, canDelete: true });
            });
            
            if (items.length === 0) return;
            
            // Add current hand if not in stored
            if (!hhStoredHands.find(function(h) { return h.handNumber === hhCurrentHandNumber; })) {
                items.push({ number: hhCurrentHandNumber, label: '#' + hhCurrentHandNumber + '  (current)', canDelete: false });
            }
            
            // Build simple dropdown overlay
            var existing = document.getElementById('hh-hand-jump-overlay');
            if (existing) { existing.remove(); return; } // toggle off
            
            var overlay = document.createElement('div');
            overlay.id = 'hh-hand-jump-overlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; display: flex; align-items: center; justify-content: center;';
            
            var panel = document.createElement('div');
            panel.style.cssText = 'background: linear-gradient(145deg, #1a2440, #141c34); border: 1px solid rgba(255,140,56,0.3); border-radius: 10px; padding: 1rem; max-height: 60vh; overflow-y: auto; min-width: 260px; max-width: 320px;';
            
            var title = document.createElement('div');
            title.textContent = 'Jump to Hand';
            title.style.cssText = "font-family: 'Outfit', sans-serif; font-size: 1rem; font-weight: 800; color: #ff8c38; margin-bottom: 0.75rem; text-align: center;";
            panel.appendChild(title);
            
            items.forEach(function(item) {
                var row = document.createElement('div');
                row.style.cssText = "display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; border-radius: 6px; cursor: pointer; margin-bottom: 4px;";
                if (item.number === (hhViewingHandNumber || hhCurrentHandNumber)) {
                    row.style.background = 'rgba(255,140,56,0.2)';
                }
                
                var label = document.createElement('span');
                label.textContent = item.label;
                label.style.cssText = "font-family: 'Outfit', sans-serif; font-size: 0.85rem; font-weight: 600; color: rgba(255,255,255,0.85); flex: 1;";
                if (item.number === (hhViewingHandNumber || hhCurrentHandNumber)) {
                    label.style.color = '#ffc068';
                }
                row.appendChild(label);
                
                // Delete button
                if (item.canDelete) {
                    var delBtn = document.createElement('button');
                    delBtn.innerHTML = '✕';
                    delBtn.style.cssText = "background: none; border: none; color: rgba(239,68,68,0.6); font-size: 0.85rem; cursor: pointer; padding: 4px 6px; border-radius: 4px; line-height: 1; flex-shrink: 0;";
                    delBtn.onmouseenter = function() { this.style.color = '#ef4444'; this.style.background = 'rgba(239,68,68,0.15)'; };
                    delBtn.onmouseleave = function() { this.style.color = 'rgba(239,68,68,0.6)'; this.style.background = 'none'; };
                    (function(handNum) {
                        delBtn.onclick = function(e) {
                            e.stopPropagation();
                            hhDeleteHand(handNum);
                            overlay.remove();
                        };
                    })(item.number);
                    row.appendChild(delBtn);
                }
                
                (function(handNum) {
                    label.onclick = function() {
                        overlay.remove();
                        if (handNum === hhCurrentHandNumber && !hhStoredHands.find(function(h) { return h.handNumber === handNum; })) {
                            hhViewingHandNumber = null;
                            hhReturnToLiveHand();
                        } else {
                            hhViewingHandNumber = handNum;
                            hhLoadStoredHand(handNum);
                        }
                        hhUpdateHandNumberDisplay();
                    };
                })(item.number);
                
                panel.appendChild(row);
            });
            
            overlay.appendChild(panel);
            overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };
            document.body.appendChild(overlay);
        }
        
        function hhDeleteHand(handNumber) {
            var idx = hhStoredHands.findIndex(function(h) { return h.handNumber === handNumber; });
            if (idx < 0) return;
            
            hhStoredHands.splice(idx, 1);
            saveHandHistory();
            
            // If we were viewing the deleted hand, return to live
            if (hhViewingHandNumber === handNumber) {
                hhViewingHandNumber = null;
                hhReturnToLiveHand();
                hhUpdateHandNumberDisplay();
            }
            
            // Refresh player hand history if viewing a player
            if (currentPlayerName) renderPlayerHandHistory(currentPlayerName);
        }
        
        function hhEditViewedHand() {
            if (hhViewingHandNumber === null) return;
            var hand = hhStoredHands.find(function(h) { return h.handNumber === hhViewingHandNumber; });
            if (!hand) return;
            
            // Mark hand as in-progress so it can be edited
            hand.inProgress = true;
            hand.winner = null;
            
            // Make this the current hand for editing
            hhCurrentHandNumber = hand.handNumber;
            hhViewingHandNumber = null;
            
            // Restore hand data
            hhTrackerHero = hand.hero;
            hhTrackerHeroFirstName = hand.heroFirstName;
            hhTrackerHeroPosition = hand.heroPosition;
            hhTrackerVillainName = hand.villainName;
            hhTrackerVillainFirstName = hand.villainFirstName;
            hhTrackerVillainPosition = hand.villainPosition;
            hhTrackerPositionType = hand.positionType;
            hhTrackerStreetActions = JSON.parse(JSON.stringify(hand.streetActions));
            hhTrackerCommunityCards = JSON.parse(JSON.stringify(hand.communityCards));
            hhTrackerWinner = null;
            
            // Set up the UI for editing
            if (hand.hero) document.getElementById('hh-hero-select').value = hand.hero;
            if (hand.villainName) document.getElementById('hh-villain-select').value = hand.villainName;
            hhHighlightPositionChips();
            
            document.getElementById('hh-hero-cards').value = hand.heroCards || '';
            document.getElementById('hh-villain-cards').value = hand.villainCards || '';
            document.getElementById('hh-hand-notes').value = hand.notes || '';
            
            // Find last street with actions and show from there
            hhTrackerCurrentStreet = 'preflop';
            var streets = ['preflop', 'flop', 'turn', 'river'];
            for (var i = streets.length - 1; i >= 0; i--) {
                if (hhTrackerStreetActions[streets[i]] && hhTrackerStreetActions[streets[i]].length > 0) {
                    hhTrackerCurrentStreet = streets[i];
                    break;
                }
            }
            
            // Show street card and action buttons
            hhFinalizeSetup();
            hhUpdateHandNumberDisplay();
            saveHandHistory();
        }
        
        function hhReturnToLiveHand() {
            // Check if current hand has been started
            const currentHandInStorage = hhStoredHands.find(h => h.handNumber === hhCurrentHandNumber);
            
            if (currentHandInStorage) {
                // Restore current hand in progress
                hhLoadStoredHand(hhCurrentHandNumber);
                hhViewingHandNumber = null;
                hhUpdateHandNumberDisplay();
                
                // If hand is in progress, show the action buttons
                if (currentHandInStorage.inProgress) {
                    document.getElementById('hh-street-card').style.display = 'block';
                    hhShowActionButtons();
                }
            } else {
                // Current hand hasn't started yet - show position selection
                hhViewingHandNumber = null;
                hhUpdateHandNumberDisplay();
                    document.getElementById('hh-results-card').style.display = 'none';
                document.getElementById('hh-notes-section').style.display = 'none';
            }
        }
        
        // Populate player dropdown from database
        function hhPopulatePlayerDropdown() {
            const select = document.getElementById('hh-hero-select');
            if (!select) return;
            
            // Clear existing options except first
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            // Add "Add New Player" option first
            const addNewOption = document.createElement('option');
            addNewOption.value = '__add_new__';
            addNewOption.textContent = '+ New';
            addNewOption.style.fontWeight = '600';
            select.appendChild(addNewOption);

            // Add players from database
            if (database && database.realPlayers) {
                database.realPlayers.forEach(player => {
                    const option = document.createElement('option');
                    option.value = player.name;
                    option.textContent = player.name;
                    select.appendChild(option);
                });
            }
            
            // Auto-select last-used hero if no hero currently set
            if (!hhTrackerHero) {
                try {
                    var lastHero = localStorage.getItem('nitwiz_lastHero');
                    if (lastHero) {
                        // Verify player still exists in dropdown
                        for (var i = 0; i < select.options.length; i++) {
                            if (select.options[i].value === lastHero) {
                                select.value = lastHero;
                                hhOnHeroSelect();
                                break;
                            }
                        }
                    }
                } catch(e) {}
            }
        }
        
        async function hhAddNewPlayerFromSelect(selectId, callback) {
            const name = await nwPrompt('Enter new player name:', 'Player name');
            if (!name || !name.trim()) {
                // Reset the select to default
                document.getElementById(selectId).value = '';
                return;
            }
            const trimmed = name.trim();

            // Check for duplicate
            const duplicate = database.realPlayers.find(p => p.name.toLowerCase() === trimmed.toLowerCase());
            if (duplicate) {
                await nwAlert('A player with that name already exists. Selecting them instead.');
                document.getElementById(selectId).value = duplicate.name;
                if (callback) callback();
                return;
            }

            // Create full player profile
            const newPlayer = {
                name: trimmed,
                observationsList: [],
                weaknesses: [],
                vpip: 0, limpBehavior: 0, coldcall: 0, openEP: 0, openLP: 0,
                pfrAggression: 0, threeBetProfile: 0, fold3bet: 0,
                flopStrategy: 0, foldcbet: 0, postflopAggression: 0,
                turnBehavior: 0, riverBehavior: 0,
                shortStack: 0, midStack: 0, deepStack: 0,
                tableTalk: 0, attention: 0, cunning: 0, thinking: 0,
                tiltProfile: 0, afterLoss: 0, tanking: 0, physicalConfidence: 0,
                stackProtection: 0, bubbleBehavior: 0, finalTableAdj: 0,
                payJumpAwareness: 0, skillLevel: 0,
                gender: 0, age: 0, ethnicity: 0, education: 0, profession: 0,
                tglChasesDraws: 0, tglLimpAny: 0, tglFaceCards: 0, tglRiverCheap: 0,
                tglLimpJam: 0, tglCantRiver: 0, tglOverfolds: 0, tglNeverBluffRiver: 0,
                tglLimpCall: 0, tglSetMines: 0, tglAfraidBust: 0, tglNoLight3bet: 0,
                tglNoStackDepth: 0,
                tglTiltProne: 0, tglScaredMoney: 0, tglEgoDriven: 0,
                tglResultOriented: 0, tglRecklessPressure: 0
            };

            database.realPlayers.push(newPlayer);
            database.realPlayers.sort((a, b) => a.name.localeCompare(b.name));
            saveDatabase();

            // Refresh dropdowns then select the new player
            hhPopulatePlayerDropdown();
            document.getElementById(selectId).value = trimmed;
            
            // Update the Players module drum list
            if (typeof updatePlayerList === 'function') updatePlayerList();

            if (callback) callback();
        }
        
        // Call on load and when database changes
        setTimeout(hhPopulatePlayerDropdown, 100);


        // Session info field editing
        const sessionFieldConfig = {
            buyin: {
                input: 'session-buyin',
                display: 'session-buyin-display',
                format: (val) => '$' + parseInt(val).toLocaleString(),
                numeric: true
            },
            blindmin: {
                input: 'session-blind-minutes',
                display: 'session-blindmin-display',
                format: (val) => parseInt(val) + ' min',
                numeric: true
            },
            stack: {
                input: 'session-stack',
                display: 'session-stack-display',
                format: (val) => parseInt(val).toLocaleString() + ' chips',
                numeric: true
            },
            venue: {
                input: 'session-venue',
                display: 'session-venue-display',
                format: (val) => val,
                numeric: false
            },
            tournotes: {
                input: 'session-tournotes',
                display: 'session-tournotes-display',
                format: (val) => val,
                numeric: false
            }
        };

        function editSessionField(field) {
            const cfg = sessionFieldConfig[field];
            const input = document.getElementById(cfg.input);
            const display = document.getElementById(cfg.display);

            // Show input, hide display
            input.classList.remove('hidden');
            display.classList.add('hidden');

            // Set raw value for editing
            input.value = input.dataset.rawValue || '';
            input.focus();
            setTimeout(() => input.select(), 0);
        }

        function commitSessionField(field) {
            const cfg = sessionFieldConfig[field];
            const input = document.getElementById(cfg.input);
            const display = document.getElementById(cfg.display);

            const raw = input.value.trim();
            const val = cfg.numeric !== false ? raw.replace(/[^0-9.]/g, '') : raw;

            if (cfg.numeric !== false ? (val && parseFloat(val) > 0) : val.length > 0) {
                // Has value - show formatted display, hide input
                input.dataset.rawValue = val;
                display.textContent = cfg.format(val);
                display.classList.remove('hidden');
                input.classList.add('hidden');
            } else {
                // No value - keep input visible, hide display
                input.dataset.rawValue = '';
                display.classList.add('hidden');
                input.classList.remove('hidden');
            }
            saveHandHistory();
        }

        // Wire up blur and enter for all fields
        Object.keys(sessionFieldConfig).forEach(field => {
            const cfg = sessionFieldConfig[field];
            const input = document.getElementById(cfg.input);

            input.addEventListener('blur', () => commitSessionField(field));
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
                if (e.key === 'Escape') { e.preventDefault(); input.blur(); }
            });
        });

        // Wire up blind level edit inputs
        ['blind-sb-input', 'blind-bb-input', 'blind-ante-input'].forEach(inputId => {
            const input = document.getElementById(inputId);
            
            input.addEventListener('blur', () => {
                // Delay to allow tab navigation between fields
                setTimeout(() => {
                    const editRow = document.getElementById('blind-level-edit-row');
                    // Only commit if no other blind input is focused
                    if (!editRow.contains(document.activeElement)) {
                        commitBlindLevel();
                    }
                }, 100);
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    commitBlindLevel();
                }
                if (e.key === 'Escape') { 
                    e.preventDefault(); 
                    commitBlindLevel();
                }
            });
        });

        // Format selector chip clicks
        document.getElementById('session-format-selector').addEventListener('click', function(e) {
            const chip = e.target.closest('.desc-chip');
            if (!chip) return;
            this.querySelectorAll('.desc-chip').forEach(c => c.classList.remove('active'));
            chip.classList.add('active');
            saveHandHistory();
        });

        // Initialize
        loadDatabase();

        // Auth state is handled by onAuthStateChanged in the Firebase init script above.
        // Cloud data is loaded automatically when user signs in.
        
        // Initialize street states after a short delay to ensure DOM is ready
        setTimeout(function() {
            // Only initialize if main container is visible (user is logged in)
            if (document.getElementById('main-container').style.display !== 'none') {
                hhUpdateStreetStates();
                // Restore saved session data
                if (window._pendingSessionRestore) {
                    restoreSessionSnapshot(window._pendingSessionRestore);
                    delete window._pendingSessionRestore;
                    // Force an immediate save to verify round-trip
                    setTimeout(function() {
                        saveHandHistory();
                    }, 50);
                }
            }
        }, 150);

        // Slider label highlighting
        function initSlider(sliderId) {
            const slider = document.getElementById(sliderId);
            if (!slider) return;
            
            const labels = document.querySelectorAll(`[data-slider="${sliderId}"]`);
            
            slider.addEventListener('input', function() {
                labels.forEach(label => {
                    if (parseInt(label.dataset.value) === parseInt(this.value)) {
                        label.classList.add('active');
                    } else {
                        label.classList.remove('active');
                    }
                });
                // Update inlay position when slider changes
                updateSliderInlay(this);
            });
            
            // Initial inlay position
            setTimeout(() => updateSliderInlay(slider), 10);
        }

        // Position purple inlay triangle on slider thumb
        function updateSliderInlay(slider) {
            const container = slider.closest('.slider-container');
            if (!container) return;
            
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            
            // Calculate percentage (0.0 to 1.0)
            const percentage = (value - min) / (max - min);
            
            // Calculate thumb center position
            const sliderRect = slider.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            // Sliders typically reserve space on each side for the thumb
            const thumbWidth = 18; // 9px on each side of triangle
            const availableWidth = sliderRect.width - thumbWidth;
            const thumbCenterX = (thumbWidth / 2) + (percentage * availableWidth);
            
            // Convert to position relative to container
            const containerOffsetX = sliderRect.left - containerRect.left;
            const inlayLeft = containerOffsetX + thumbCenterX;
            
            // Position the ::after pseudo-element via CSS variable
            container.style.setProperty('--inlay-left', `${inlayLeft}px`);
        }

        // Update CSS to use the variable
        const inlayStyle = document.createElement('style');
        inlayStyle.textContent = `
            .slider-container::after {
                left: var(--inlay-left, 50%) !important;
            }
        `;
        document.head.appendChild(inlayStyle);

        // Initialize all sliders
        ['vpip', 'pfr-aggression', 'fold3bet', 'coldcall',
         'postflop-aggression', 'foldcbet'].forEach(initSlider);

        // Initialize player sliders (legacy — now handled by chip system)
        ['player-vpip', 'player-limp-behavior', 'player-coldcall', 'player-open-ep', 'player-open-lp',
         'player-pfr-aggression', 'player-3bet-profile', 'player-fold3bet',
         'player-flop-strategy', 'player-foldcbet', 'player-postflop-aggression',
         'player-turn-behavior', 'player-river-behavior',
         'player-short-stack', 'player-mid-stack', 'player-deep-stack',
         'player-table-talk', 'player-attention',
         'player-cunning', 'player-thinking', 'player-tilt-profile',
         'player-after-loss', 'player-tanking', 'player-physical',
         'player-stack-protection', 'player-bubble', 'player-final-table',
         'player-pay-jump', 'player-skill-level'].forEach(initSlider);

        // Update inlay positions on window resize
        window.addEventListener('resize', () => {
            document.querySelectorAll('.range-slider').forEach(slider => {
                updateSliderInlay(slider);
            });
        });

        // Function to update all player slider labels
        function updatePlayerSliders() {
            // Now handled by chip system — no range sliders to update
        }
    </script>
</body>
</html>
